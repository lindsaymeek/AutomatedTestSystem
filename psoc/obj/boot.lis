 0000           ;$Id: //depot/Rel_3.1/BuildMediaPSoC/Executables/Templates/boot.tpl#3 $
 0000           ;=============================================================================
 0000           ;  FILENAME:   boot.asm
 0000           ;   VERSION:   3.06
 0000           ;      DATE:   2 April 2002
 0000           ;
 0000           ;  DESCRIPTION:
 0000           ;   M8C Boot Code from Reset.
 0000           ;
 0000           ;   Copyright (c) Cypress MicroSystems 2001, 2002. All rights reserved.
 0000           ;
 0000           ; NOTES:
 0000           ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
 0000           ; the project's root directory to create BOOT.ASM. Any changes made to 
 0000           ; BOOT.ASM will be  overwritten every time the project is generated; therfore
 0000           ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
 0000           ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
 0000           ; are not accidentally modified.
 0000           ;
 0000           ; The start of _main is at a fixed location so care must be taken when adding
 0000           ; user code for the Sleep Interrupt. If too much code is added, the end of 
 0000           ; BOOT.ASM will extend into _main and cause a linker error. The safest way
 0000           ; to add code for the Sleep Interrupt is to CALL a separate routine that 
 0000           ; contains the desired additional Sleep Interrupt code.
 0000           ;=============================================================================
 0000           
 0003           CPU_CLOCK:			equ	3h		;CPU clock value
 0007           CPU_CLOCK_MASK:		equ	7h		;CPU clock mask
 0003           CPU_CLOCK_JUST:		equ	3h		;CPU clock value justified
 0000           SELECT_32K:			equ	0h		;32K select value
 0080           SELECT_32K_MASK:	equ	80h		;32K select mask
 0000           SELECT_32K_JUST:	equ	0h		;32K select value justified
 0000           PLL_MODE:			equ	0h		;PLL mode value
 0040           PLL_MODE_MASK:		equ	40h		;PLL mode mask
 0000           PLL_MODE_JUST:		equ	0h		;PLL mode value justified
 0000           SLEEP_TIMER:		equ	0h		;Sleep Timer value
 0018           SLEEP_TIMER_MASK:	equ	18h		;Sleep Timer mask
 0000           SLEEP_TIMER_JUST:	equ	0h		;Sleep Timer value justified
 0001           VOLTAGE_RANGE:		equ 1h		;Voltage Range
 0001           SUPPLY_VOLTAGE:		equ 1h		;Supply Voltage 1 = 5.0V
 0000           								;				0 = 3.3V
 0000           ;
 0000           ; write only registers
 0000           ;
 0000           ANALOG_IO_CONTROL:	equ 0h	;Analog IO Control register
 0000           PORT_0_BYPASS:		equ 0h	;Port 0 bypass register
 0000           PORT_0_DRIVE_0:		equ 0h	;Port 0 drive mode 0 register
 00FF           PORT_0_DRIVE_1:		equ ffh	;Port 0 drive mode 1 register
 0000           PORT_0_INTENABLE:	equ 0h	;Port 0 interrupt enable register
 0000           PORT_0_INTCTRL_0:	equ 0h	;Port 0 interrupt control 0 register
 0000           PORT_0_INTCTRL_1:	equ 0h	;Port 0 interrupt control 1 register
 00F0           PORT_1_BYPASS:		equ f0h	;Port 0 bypass register
 00A0           PORT_1_DRIVE_0:		equ a0h	;Port 0 drive mode 0 register
 005F           PORT_1_DRIVE_1:		equ 5fh	;Port 0 drive mode 1 register
 0000           PORT_1_INTENABLE:	equ 0h	;Port 0 interrupt enable register
 0000           PORT_1_INTCTRL_0:	equ 0h	;Port 0 interrupt control 0 register
 0000           PORT_1_INTCTRL_1:	equ 0h	;Port 0 interrupt control 1 register
 0000           PORT_2_BYPASS:		equ 0h	;Port 0 bypass register
 0000           PORT_2_DRIVE_0:		equ 0h	;Port 0 drive mode 0 register
 0000           PORT_2_DRIVE_1:		equ 0h	;Port 0 drive mode 1 register
 0000           PORT_2_INTENABLE:	equ 0h	;Port 0 interrupt enable register
 0000           PORT_2_INTCTRL_0:	equ 0h	;Port 0 interrupt control 0 register
 0000           PORT_2_INTCTRL_1:	equ 0h	;Port 0 interrupt control 1 register
 0000           PORT_3_BYPASS:		equ 0h	;Port 0 bypass register
 0000           PORT_3_DRIVE_0:		equ 0h	;Port 0 drive mode 0 register
 0000           PORT_3_DRIVE_1:		equ 0h	;Port 0 drive mode 1 register
 0000           PORT_3_INTENABLE:	equ 0h	;Port 0 interrupt enable register
 0000           PORT_3_INTCTRL_0:	equ 0h	;Port 0 interrupt control 0 register
 0000           PORT_3_INTCTRL_1:	equ 0h	;Port 0 interrupt control 1 register
 0000           PORT_4_BYPASS:		equ 0h	;Port 0 bypass register
 0000           PORT_4_DRIVE_0:		equ 0h	;Port 0 drive mode 0 register
 0000           PORT_4_DRIVE_1:		equ 0h	;Port 0 drive mode 1 register
 0000           PORT_4_INTENABLE:	equ 0h	;Port 0 interrupt enable register
 0000           PORT_4_INTCTRL_0:	equ 0h	;Port 0 interrupt control 0 register
 0000           PORT_4_INTCTRL_1:	equ 0h	;Port 0 interrupt control 1 register
 0000           PORT_5_BYPASS:		equ 0h	;Port 0 bypass register
 0000           PORT_5_DRIVE_0:		equ 0h	;Port 0 drive mode 0 register
 0000           PORT_5_DRIVE_1:		equ 0h	;Port 0 drive mode 1 register
 0000           PORT_5_INTENABLE:	equ 0h	;Port 0 interrupt enable register
 0000           PORT_5_INTCTRL_0:	equ 0h	;Port 0 interrupt control 0 register
 0000           PORT_5_INTCTRL_1:	equ 0h	;Port 0 interrupt control 1 register
 0010           FlagXIOMask:  equ 10h
 0008           FlagSuper:    equ 08h
 0004           FlagCarry:    equ 04h
 0002           FlagZero:     equ 02h
 0001           FlagGlobalIE: equ 01h
 0000           
 0000           
 0000           ;;===================================
 0000           ;;      Register Space, Bank 0
 0000           ;;===================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Port Registers
 0000           ;  Note: Also see this address range in Bank 1.
 0000           ;------------------------------------------------
 0000           ; Port 0
 0000           PRT0DR:       equ 00h          ; Port 0 Data Register              (RW)
 0001           PRT0IE:       equ 01h          ; Port 0 Interrupt Enable Register  (WO)
 0002           PRT0GS:       equ 02h          ; Port 0 Global Select Register     (WO)
 0000           ; (Reserved)  equ 03h
 0000           ; Port 1
 0004           PRT1DR:       equ 04h          ; Port 1 Data Register              (RW)
 0005           PRT1IE:       equ 05h          ; Port 1 Interrupt Enable Register  (WO)
 0006           PRT1GS:       equ 06h          ; Port 1 Global Select Register     (WO)
 0000           ; (Reserved)  equ 07h
 0000           ; Port 2
 0008           PRT2DR:       equ 08h          ; Port 2 Data Register              (RW)
 0009           PRT2IE:       equ 09h          ; Port 2 Interrupt Enable Register  (WO)
 000A           PRT2GS:       equ 0Ah          ; Port 2 Global Select Register     (WO)
 0000           ; (Reserved)  equ 0Bh
 0000           ; Port 3
 000C           PRT3DR:       equ 0Ch          ; Port 3 Data Register              (RW)
 000D           PRT3IE:       equ 0Dh          ; Port 3 Interrupt Enable Register  (WO)
 000E           PRT3GS:       equ 0Eh          ; Port 3 Global Select Register     (WO)
 0000           ; (Reserved)  equ 0Fh
 0000           ; Port 4
 0010           PRT4DR:       equ 10h          ; Port 4 Data Register              (RW)
 0011           PRT4IE:       equ 11h          ; Port 4 Interrupt Enable Register  (WO)
 0012           PRT4GS:       equ 12h          ; Port 4 Global Select Register     (WO)
 0000           ; (Reserved)  equ 13h
 0000           ; Port 5
 0014           PRT5DR:       equ 14h          ; Port 5 Data Register              (RW)
 0015           PRT5IE:       equ 15h          ; Port 5 Interrupt Enable Register  (WO)
 0016           PRT5GS:       equ 16h          ; Port 5 Global Select Register     (WO)
 0000           ; (Reserved)  equ 17h
 0000           
 0000           ;------------------------------------------------
 0000           ;  Digital PSoC(tm) block Registers
 0000           ;  Note: Also see this address range in Bank 1.
 0000           ;------------------------------------------------
 0000           ; Digital PSoC block 0, Basic Type A
 0020           DBA00DR0:     equ 20h          ; data register 0                   (RO)
 0021           DBA00DR1:     equ 21h          ; data register 1                   (WO)
 0022           DBA00DR2:     equ 22h          ; data register 2                   (RW)
 0023           DBA00CR0:     equ 23h          ; control & status register 0       (RW)
 0000           
 0000           ; Digital PSoC block 1, Basic Type A
 0024           DBA01DR0:     equ 24h          ; data register 0                   (RO)
 0025           DBA01DR1:     equ 25h          ; data register 1                   (WO)
 0026           DBA01DR2:     equ 26h          ; data register 2                   (RW)
 0027           DBA01CR0:     equ 27h          ; control & status register 0       (RW)
 0000           
 0000           ; Digital PSoC block 2, Basic Type A
 0028           DBA02DR0:     equ 28h          ; data register 0                   (RO)
 0029           DBA02DR1:     equ 29h          ; data register 1                   (WO)
 002A           DBA02DR2:     equ 2Ah          ; data register 2                   (RW)
 002B           DBA02CR0:     equ 2Bh          ; control & status register 0       (RW)
 0000           
 0000           ; Digital PSoC block 3, Basic Type A
 002C           DBA03DR0:     equ 2Ch          ; data register 0                   (RO)
 002D           DBA03DR1:     equ 2Dh          ; data register 1                   (WO)
 002E           DBA03DR2:     equ 2Eh          ; data register 2                   (RW)
 002F           DBA03CR0:     equ 2Fh          ; control & status register 0       (RW)
 0000           
 0000           ; Digital PSoC block 4, Communications Type A
 0030           DCA04DR0:     equ 30h          ; data register 0                   (RO)
 0031           DCA04DR1:     equ 31h          ; data register 1                   (WO)
 0032           DCA04DR2:     equ 32h          ; data register 2                   (RW)
 0033           DCA04CR0:     equ 33h          ; control & status register 0       (RW)
 0000           
 0000           ; Digital PSoC block 5, Communications Type A
 0034           DCA05DR0:     equ 34h          ; data register 0                   (RO)
 0035           DCA05DR1:     equ 35h          ; data register 1                   (WO)
 0036           DCA05DR2:     equ 36h          ; data register 2                   (RW)
 0037           DCA05CR0:     equ 37h          ; control & status register 0       (RW)
 0000           
 0000           ; Digital PSoC block 6, Communications Type A
 0038           DCA06DR0:     equ 38h          ; data register 0                   (RO)
 0039           DCA06DR1:     equ 39h          ; data register 1                   (WO)
 003A           DCA06DR2:     equ 3Ah          ; data register 2                   (RW)
 003B           DCA06CR0:     equ 3Bh          ; control & status register 0       (RW)
 0000           
 0000           ; Digital PSoC block 7, Communications Type A
 003C           DCA07DR0:     equ 3Ch          ; data register 0                   (RO)
 003D           DCA07DR1:     equ 3Dh          ; data register 1                   (WO)
 003E           DCA07DR2:     equ 3Eh          ; data register 2                   (RW)
 003F           DCA07CR0:     equ 3Fh          ; control & status register 0       (RW)
 0000           
 0000           
 0000           ;-------------------------------------
 0000           ;  Analog Resource Control Registers
 0000           ;-------------------------------------
 0060           AMX_IN:       equ 60h          ; analog input multiplexor control  (RW)
 0000                                          ; AMX_IN Bit field masks:
 00C0           AMX_IN_ACI3:          equ C0h          ; column 3 input mux
 0030           AMX_IN_ACI2:          equ 30h          ; column 2 input mux
 000C           AMX_IN_ACI1:          equ 0Ch          ; column 1 input mux
 0003           AMX_IN_ACI0:          equ 03h          ; column 0 input mux
 0000           
 0000           ; (Reserved)  equ 61h          ; reserved
 0000           ; (Reserved)  equ 62h          ; reserved
 0000           
 0063           ARF_CR:       equ 63h          ; analog reference control          (RW)
 0000                                          ; ARF_CR Bit field masks:
 0080           ARF_CR_BGT:           equ 80h          ; Bandgap Test
 0040           ARF_CR_HBE:           equ 40h          ; Bias level control
 0038           ARF_CR_REF:           equ 38h          ; Analog array ref control
 0004           ARF_CR_APWR:          equ 04h          ; Analog Power
 0003           ARF_CR_SCPWR:         equ 03h          ; Switched Cap block power
 0000           
 0064           CMP_CR:       equ 64h          ; comparator control                (*)
 0000                                          ; CMP_CR Bit field masks:
 0080           CMP_CR_COMP3:         equ 80h          ; Column 3 comparator state     (R)
 0040           CMP_CR_COMP2:         equ 40h          ; Column 2 comparator state     (R)
 0020           CMP_CR_COMP1:         equ 20h          ; Column 1 comparator state     (R)
 0010           CMP_CR_COMP0:         equ 10h          ; Column 0 comparator state     (R)
 0008           CMP_CR_AINT3:         equ 08h          ; Column 3 interrupt source     (RW)
 0004           CMP_CR_AINT2:         equ 04h          ; Column 2 interrupt source     (RW)
 0002           CMP_CR_AINT1:         equ 02h          ; Column 1 interrupt source     (RW)
 0001           CMP_CR_AINT0:         equ 01h          ; Column 0 interrupt source     (RW)
 0000           
 0065           ASY_CR:       equ 65h          ; analog synchronizaton control     (*)
 0000                                          ; ASY_CR Bit field masks:
 0007           ASY_CR_SARCOUNT:      equ 07h          ; SAR support: resolution count (W0)
 0008           ASY_CR_SARSIGN:       equ 08h          ; SAR support: sign             (RW)
 0006           ASY_CR_SARCOL:        equ 06h          ; SAR support: column spec	   (RW)
 0001           ASY_CR_SYNCEN:        equ 01h          ; Stall bit                     (RW)
 0000           
 0000           
 0000           ;---------------------------------------------------
 0000           ;  Analog PSoC block Registers
 0000           ;
 0000           ;  Note: the following registers are mapped into
 0000           ;  both register bank 0 AND register bank 1.
 0000           ;---------------------------------------------------
 0000           
 0000           ; Continuous Time PSoC block Type A Row 0 Col 0
 0000           ; (Reserved)  equ 70h
 0071           ACA00CR0:     equ 71h          ; Control register 0                (RW)
 0072           ACA00CR1:     equ 72h          ; Control register 1                (RW)
 0073           ACA00CR2:     equ 73h          ; Control register 2                (RW)
 0000           
 0000           ; Continuous Time PSoC block Type A Row 0 Col 1
 0000           ; (Reserved)  equ 74h
 0075           ACA01CR0:     equ 75h          ; Control register 0                (RW)
 0076           ACA01CR1:     equ 76h          ; Control register 1                (RW)
 0077           ACA01CR2:     equ 77h          ; Control register 2                (RW)
 0000           
 0000           ; Continuous Time PSoC block Type A Row 0 Col 2
 0000           ; (Reserved)  equ 78h
 0079           ACA02CR0:     equ 79h          ; Control register 0                (RW)
 007A           ACA02CR1:     equ 7Ah          ; Control register 1                (RW)
 007B           ACA02CR2:     equ 7Bh          ; Control register 2                (RW)
 0000           
 0000           ; Continuous Time PSoC block Type A Row 0 Col 3
 0000           ; (Reserved)  equ 7Ch
 007D           ACA03CR0:     equ 7Dh          ; Control register 0                (RW)
 007E           ACA03CR1:     equ 7Eh          ; Control register 1                (RW)
 007F           ACA03CR2:     equ 7Fh          ; Control register 2                (RW)
 0000           
 0000           ; Switched Cap PSoC blockType A Row 1 Col 0
 0080           ASA10CR0:     equ 80h          ; Control register 0                (RW)
 0081           ASA10CR1:     equ 81h          ; Control register 1                (RW)
 0082           ASA10CR2:     equ 82h          ; Control register 2                (RW)
 0083           ASA10CR3:     equ 83h          ; Control register 3                (RW)
 0000           
 0000           ; Switched Cap PSoC blockType B Row 1 Col 1
 0084           ASB11CR0:     equ 84h          ; Control register 0                (RW)
 0085           ASB11CR1:     equ 85h          ; Control register 1                (RW)
 0086           ASB11CR2:     equ 86h          ; Control register 2                (RW)
 0087           ASB11CR3:     equ 87h          ; Control register 3                (RW)
 0000           
 0000           ; Switched Cap PSoC blockType A Row 1 Col 2
 0088           ASA12CR0:     equ 88h          ; Control register 0                (RW)
 0089           ASA12CR1:     equ 89h          ; Control register 1                (RW)
 008A           ASA12CR2:     equ 8Ah          ; Control register 2                (RW)
 008B           ASA12CR3:     equ 8Bh          ; Control register 3                (RW)
 0000           
 0000           ; Switched Cap PSoC blockType B Row 1 Col 3
 008C           ASB13CR0:     equ 8Ch          ; Control register 0                (RW)
 008D           ASB13CR1:     equ 8Dh          ; Control register 1                (RW)
 008E           ASB13CR2:     equ 8Eh          ; Control register 2                (RW)
 008F           ASB13CR3:     equ 8Fh          ; Control register 3                (RW)
 0000           
 0000           ; Switched Cap PSoC blockType B Row 2 Col 0
 0090           ASB20CR0:     equ 90h          ; Control register 0                (RW)
 0091           ASB20CR1:     equ 91h          ; Control register 1                (RW)
 0092           ASB20CR2:     equ 92h          ; Control register 2                (RW)
 0093           ASB20CR3:     equ 93h          ; Control register 3                (RW)
 0000           
 0000           ; Switched Cap PSoC blockType A Row 2 Col 1
 0094           ASA21CR0:     equ 94h          ; Control register 0                (RW)
 0095           ASA21CR1:     equ 95h          ; Control register 1                (RW)
 0096           ASA21CR2:     equ 96h          ; Control register 2                (RW)
 0097           ASA21CR3:     equ 97h          ; Control register 3                (RW)
 0000           
 0000           ; Switched Cap PSoC blockType B Row 2 Col 2
 0098           ASB22CR0:     equ 98h          ; Control register 0                (RW)
 0099           ASB22CR1:     equ 99h          ; Control register 1                (RW)
 009A           ASB22CR2:     equ 9Ah          ; Control register 2                (RW)
 009B           ASB22CR3:     equ 9Bh          ; Control register 3                (RW)
 0000           
 0000           ; Switched Cap PSoC blockType A Row 2 Col 3
 009C           ASA23CR0:     equ 9Ch          ; Control register 0                (RW)
 009D           ASA23CR1:     equ 9Dh          ; Control register 1                (RW)
 009E           ASA23CR2:     equ 9Eh          ; Control register 2                (RW)
 009F           ASA23CR3:     equ 9Fh          ; Control register 3                (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  System and Global Resource Registers
 0000           ;  Note: Also see this address range in Bank 1.
 0000           ;------------------------------------------------
 00E0           INT_MSK0:                  equ E0h   ; General Interrupt Mask Register   (RW)
 0040           INT_MSK0_Sleep:            equ 40h  ; MASK: enable/disable sleep interrupt
 0020           INT_MSK0_GPIO:             equ 20h  ; MASK: enable/disable GPIO  interrupt
 0010           INT_MSK0_AColumn3:         equ 10h  ; MASK: enable/disable Analog col 3 interrupt
 0008           INT_MSK0_AColumn2:         equ 08h  ; MASK: enable/disable Analog col 2 interrupt
 0004           INT_MSK0_AColumn1:         equ 04h  ; MASK: enable/disable Analog col 1 interrupt
 0002           INT_MSK0_AColumn0:         equ 02h  ; MASK: enable/disable Analog col 0 interrupt
 0001           INT_MSK0_VoltageMonitor:   equ 01h  ; MASK: enable/disable Volts interrupt
 0000           
 00E1           INT_MSK1:     equ E1h          ; Digital PSoC block Mask Register  (RW)
 00E2           INT_VC:       equ E2h          ; Interrupt vector register         (RW)
 00E3           RES_WDT:      equ E3h          ; Watch Dog Timer                   (RW)
 0000           
 0000           ; DECIMATOR Registers
 00E4           DEC_DH:       equ E4h          ; Data Register (high byte)         (RW)
 00E5           DEC_DL:       equ E5h          ; Data Register ( low byte)         (RO)
 00E6           DEC_CR:       equ E6h          ; Data Control Register             (RW)
 0000           
 0000           ; Multiplier and MAC (Multiply/Accumulate) Unit
 00E8           MUL_X:        equ E8h          ; Multiplier X Register (write)            (WO)
 00E9           MUL_Y:        equ E9h          ; Multiplier Y Register (write)            (WO)
 00EA           MUL_DH:       equ EAh          ; Multiplier Result Data (high byte read)  (RO)
 00EB           MUL_DL:       equ EBh          ; Multiplier Result Data ( low byte read)  (RO)
 00EC           MAC_X:        equ ECh          ; MAC X register (write) [also see ACC_DR1](WO)
 00ED           MAC_Y:        equ EDh          ; MAC Y register (write) [also see ACC_DR0](WO)
 00EE           MAC_CL0:      equ EEh          ; MAC Clear Accum (write)[also see ACC_DR3](WO)
 00EF           MAC_CL1:      equ EFh          ; MAC Clear Accum (write)[also see ACC_DR2](WO)
 00EC           ACC_DR1:      equ ECh          ; MAC Accumulator (Read, byte 0)           (RO)
 00ED           ACC_DR0:      equ EDh          ; MAC Accumulator (Read, byte 0)           (RO)
 00EE           ACC_DR3:      equ EEh          ; MAC Accumulator (Read, byte 0)           (RO)
 00EF           ACC_DR2:      equ EFh          ; MAC Accumulator (Read, byte 0)           (RO)
 0000           
 0000           ; Test Mode mapping of the CPU Flag (F) Register
 00F7           CPU_FLAG:     equ F7h          ; NOTE: Only mapped when in Test Mode !!!
 0000           
 0000           
 0000           ;------------------------------------------------
 0000           ;  System Status and Control Register
 0000           ;
 0000           ;  Note: the following register is mapped into
 0000           ;  both register bank 0 AND register bank 1.
 0000           ;------------------------------------------------
 00FF           CPU_SCR:                equ FFh   ;                                     (*)
 0080           CPUSCR_GIEMask:         equ 80h   ; MASK: flag reg Global Int Enable shadow
 0020           CPUSCR_WDRSMask:        equ 20h   ; MASK: Watch Dog Timer Reset
 0010           CPUSCR_PORSMask:        equ 10h   ; MASK: power-on reset bit PORS
 0008           CPUSCR_SleepMask:       equ 08h   ; MASK: Enable Sleep
 0001           CPUSCR_StopMask:        equ 01h   ; MASK: Halt CPU bit
 0000           
 0000           
 0000           ;;===================================
 0000           ;;      Register Space, Bank 1
 0000           ;;===================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Port Registers
 0000           ;  Note: Also see this address range in Bank 0.
 0000           ;------------------------------------------------
 0000           ; Port 0
 0000           PRT0DM0:      equ 00h          ; Port 0 Drive Mode 0               (WO)
 0001           PRT0DM1:      equ 01h          ; Port 0 Drive Mode 1               (WO)
 0002           PRT0IC0:      equ 02h          ; Port 0 Interrupt Control 0        (WO)
 0003           PRT0IC1:      equ 03h          ; Port 0 Interrupt Control 1        (WO)
 0000           
 0000           ; Port 1
 0004           PRT1DM0:      equ 04h          ; Port 1 Drive Mode 0               (WO)
 0005           PRT1DM1:      equ 05h          ; Port 1 Drive Mode 1               (WO)
 0006           PRT1IC0:      equ 06h          ; Port 1 Interrupt Control 0        (WO)
 0007           PRT1IC1:      equ 07h          ; Port 1 Interrupt Control 1        (WO)
 0000           
 0000           ; Port 2
 0008           PRT2DM0:      equ 08h          ; Port 2 Drive Mode 0               (WO)
 0009           PRT2DM1:      equ 09h          ; Port 2 Drive Mode 1               (WO)
 000A           PRT2IC0:      equ 0Ah          ; Port 2 Interrupt Control 0        (WO)
 000B           PRT2IC1:      equ 0Bh          ; Port 2 Interrupt Control 1        (WO)
 0000           
 0000           ; Port 3
 000C           PRT3DM0:      equ 0Ch          ; Port 3 Drive Mode 0               (WO)
 000D           PRT3DM1:      equ 0Dh          ; Port 3 Drive Mode 1               (WO)
 000E           PRT3IC0:      equ 0Eh          ; Port 3 Interrupt Control 0        (WO)
 000F           PRT3IC1:      equ 0Fh          ; Port 3 Interrupt Control 1        (WO)
 0000           
 0000           ; Port 4
 0010           PRT4DM0:      equ 10h          ; Port 4 Drive Mode 0               (WO)
 0011           PRT4DM1:      equ 11h          ; Port 4 Drive Mode 1               (WO)
 0012           PRT4IC0:      equ 12h          ; Port 4 Interrupt Control 0        (WO)
 0013           PRT4IC1:      equ 13h          ; Port 4 Interrupt Control 1        (WO)
 0000           
 0000           ; Port 5
 0014           PRT5DM0:      equ 14h          ; Port 5 Drive Mode 0               (WO)
 0015           PRT5DM1:      equ 15h          ; Port 5 Drive Mode 1               (WO)
 0016           PRT5IC0:      equ 16h          ; Port 5 Interrupt Control 0        (WO)
 0017           PRT5IC1:      equ 17h          ; Port 5 Interrupt Control 1        (WO)
 0000           
 0000           
 0000           ;------------------------------------------------
 0000           ;  Digital PSoC(tm) block Registers
 0000           ;  Note: Also see this address range in Bank 0.
 0000           ;------------------------------------------------
 0000           
 0000           ; Digital PSoC block 0, Basic Type A
 0020           DBA00FN:      equ 20h          ; Function Register                 (RW)
 0021           DBA00IN:      equ 21h          ;    Input Register                 (RW)
 0022           DBA00OU:      equ 22h          ;   Output Register                 (RW)
 0000           ; (Reserved)  equ 23h
 0000           
 0000           ; Digital PSoC block 1, Basic Type A
 0024           DBA01FN:      equ 24h          ; Function Register                 (RW)
 0025           DBA01IN:      equ 25h          ;    Input Register                 (RW)
 0026           DBA01OU:      equ 26h          ;   Output Register                 (RW)
 0000           ; (Reserved)  equ 27h
 0000           
 0000           ; Digital PSoC block 2, Basic Type A
 0028           DBA02FN:      equ 28h          ; Function Register                 (RW)
 0029           DBA02IN:      equ 29h          ;    Input Register                 (RW)
 002A           DBA02OU:      equ 2Ah          ;   Output Register                 (RW)
 0000           ; (Reserved)  equ 2Bh
 0000           
 0000           ; Digital PSoC block 3, Basic Type A
 002C           DBA03FN:      equ 2Ch          ; Function Register                 (RW)
 002D           DBA03IN:      equ 2Dh          ;    Input Register                 (RW)
 002E           DBA03OU:      equ 2Eh          ;   Output Register                 (RW)
 0000           ; (Reserved)  equ 2Fh
 0000           
 0000           ; Digital PSoC block 4, Communications Type A
 0030           DCA04FN:      equ 30h          ; Function Register                 (RW)
 0031           DCA04IN:      equ 31h          ;    Input Register                 (RW)
 0032           DCA04OU:      equ 32h          ;   Output Register                 (RW)
 0000           ; (Reserved)  equ 33h
 0000           
 0000           ; Digital PSoC block 5, Communications Type A
 0034           DCA05FN:      equ 34h          ; Function Register                 (RW)
 0035           DCA05IN:      equ 35h          ;    Input Register                 (RW)
 0036           DCA05OU:      equ 36h          ;   Output Register                 (RW)
 0000           ; (Reserved)  equ 37h
 0000           
 0000           ; Digital PSoC block 6, Communications Type A
 0038           DCA06FN:      equ 38h          ; Function Register                 (RW)
 0039           DCA06IN:      equ 39h          ;    Input Register                 (RW)
 003A           DCA06OU:      equ 3Ah          ;   Output Register                 (RW)
 0000           ; (Reserved)  equ 3Bh
 0000           
 0000           ; Digital PSoC block 7, Communications Type A
 003C           DCA07FN:      equ 3Ch          ; Function Register                 (RW)
 003D           DCA07IN:      equ 3Dh          ;    Input Register                 (RW)
 003E           DCA07OU:      equ 3Eh          ;   Output Register                 (RW)
 0000           ; (Reserved)  equ 3Fh
 0000           
 0000           
 0000           ;------------------------------------------------
 0000           ;  System and Global Resource Registers
 0000           ;  Note: Also see this address range in Bank 0.
 0000           ;------------------------------------------------
 0000           
 0060           CLK_CR0:      equ 60h          ; Analog Column Clock Select Register     (RW)
 00C0           CLK_CR0_AColumn3:     equ C0h  ; MASK: Specify clock for analog cloumn
 0030           CLK_CR0_AColumn2:     equ 30h  ; MASK: Specify clock for analog cloumn
 000C           CLK_CR0_AColumn1:     equ 0Ch  ; MASK: Specify clock for analog cloumn
 0003           CLK_CR0_AColumn0:     equ 03h  ; MASK: Specify clock for analog cloumn
 0000           
 0061           CLK_CR1:      equ 61h          ; Analog Clock Source Select Register     (RW)
 0040           CLK_CR1_SHDIS:        equ 40h  ; MASK: Sample and Hold Disable (all Columns)
 0031           CLK_CR1_ACLK1:        equ 31h  ; MASK: Digital PSoC block for analog source
 0007           CLK_CR1_ACLK2:        equ 07h  ; MASK: Digital PSoC block for analog source
 0000           
 0062           ABF_CR:       equ 62h          ; Analog Output Buffer Control Register   (RW)
 00C0           ABF_CR_ACI3:          equ C0h  ; MASK: Level 1 input mux for analog column 3
 0030           ABF_CR_ACI2:          equ 30h  ; MASK: Level 1 input mux for analog column 2
 000C           ABF_CR_ACI1:          equ 0Ch  ; MASK: Level 1 input mux for analog column 1
 0003           ABF_CR_ACI0:          equ 03h  ; MASK: Level 1 input mux for analog column 0
 0000           
 0063           AMD_CR:       equ 63h          ; Analog Modulator Control Register       (RW)
 000C           AMD_CR_AMOD2:         equ 0Ch  ; MASK: Modulation source for analog column 2
 0003           AMD_CR_AMOD0:         equ 03h  ; MASK: Modulation source for analog column 1
 0000           
 0000           
 00E0           OSC_CR0:      equ E0h          ; System Oscillator Control Register      (RW)
 0080           OSC_CR0_32K_Select:   equ 80h  ; MASK: Enable/Disable External XTAL Oscillator
 0040           OSC_CR0_PLL_Mode:     equ 40h  ; MASK: Enable/Disable PLL
 0018           OSC_CR0_Sleep:        equ 18h  ; MASK: Set Sleep timer freq/period
 0000           OSC_CR0_Sleep_512Hz:  equ 00h  ;     Set sleep bits for 1.95ms period
 0008           OSC_CR0_Sleep_64Hz:   equ 08h  ;     Set sleep bits for 15.6ms period
 0010           OSC_CR0_Sleep_8Hz:    equ 10h  ;     Set sleep bits for 125ms period
 0018           OSC_CR0_Sleep_1Hz:    equ 18h  ;     Set sleep bits for 1 sec period
 0007           OSC_CR0_CPU:          equ 07h  ; MASK: Set CPU Frequency
 0000           OSC_CR0_CPU_3MHz:     equ 00h  ;     set CPU Freq bits for 3MHz Operation
 0001           OSC_CR0_CPU_6MHz:     equ 01h  ;     set CPU Freq bits for 6MHz Operation
 0002           OSC_CR0_CPU_12MHz:    equ 02h  ;     set CPU Freq bits for 12MHz Operation
 0003           OSC_CR0_CPU_24MHz:    equ 03h  ;     set CPU Freq bits for 24MHz Operation
 0004           OSC_CR0_CPU_1d5MHz:   equ 04h  ;     set CPU Freq bits for 1.5MHz Operation
 0005           OSC_CR0_CPU_750kHz:   equ 05h  ;     set CPU Freq bits for 750kHz Operation
 0006           OSC_CR0_CPU_187d5kHz: equ 06h  ;     set CPU Freq bits for 187.5kHz Operation
 0007           OSC_CR0_CPU_93d7kHz:  equ 07h  ;     set CPU Freq bits for 93.7kHz Operation
 0000           
 00E1           OSC_CR1:      equ E1h          ; System V1/V2 Divider Control Register   (RW)
 00F0           OSC_CR1_V1:           equ F0h  ; MASK System V1 24MHz divider
 000F           OSC_CR1_V2:           equ 0Fh  ; MASK System V2 24MHz divider
 0000           
 0000           ;Reserved     equ E2h
 00E3           VLT_CR:       equ E3h          ; Voltage Monitor Control Register        (RW)
 0000           
 00E8           IMO_TR:       equ E8h          ; Internal Main Oscillator Trim Register  (WO)
 00E9           ILO_TR:       equ E9h          ; Internal Low-speed Oscillator Trim      (WO)
 00EA           BDG_TR:       equ EAh          ; Band Gap Trim Register                  (WO)
 00EB           ECO_TR:       equ EBh          ; External Oscillator Trim Register       (WO)
 0000           
 0000           
 0000           
 0000           ;;===================================
 0000           ;;      M8C System Macros
 0000           ;;===================================
 0000           
 0000           
 0000           ;-------------------------------
 0000           ;  Swapping Register Banks
 0000           ;-------------------------------
 0000           
 0000               macro M8C_SetBank0
 0000               and   F, ~FlagXIOMask
 0000               macro M8C_SetBank1
 0000               or    F, FlagXIOMask
 0000               macro M8C_EnableGInt
 0000               or    F, FlagGlobalIE
 0000               macro M8C_DisableGInt
 0000               and   F, ~FlagGlobalIE
 0001           DISABLE_INT_FIX:   equ   1
 0000           ;---------------------------------------------------
 0000           ;  Use the following macros to enable/disable
 0000           ;  either of the two global interrupt mask registers,
 0000           ;  INT_MSK0 or INT_MSK1.
 0000           ; 
 0000           ;  This is a fix to a noted problem in which an 
 0000           ;  inadvertant reset can occur if an interrupt occurs
 0000           ;  while clearing an interrupt mask bit.
 0000           ; 
 0000           ;  Usage:    M8C_DisableIntMask INT_MSKN, MASK
 0000           ;            M8C_EnableIntMask  INT_MSKN, MASK
 0000           ;            
 0000           ;  where INT_MSKN is INT_MSK0 or INT_MSK1 and
 0000           ;        MASK is the bit set to enable or disable
 0000           ;-------------------------------------------------
 0000           ; Disable Interrupt Bit Mask(s) 
 0000               macro M8C_DisableIntMask
 0000           if DISABLE_INT_FIX
 0000               mov   A, reg[CPU_SCR]           ; save the current Global interrupt state
 0000               M8C_DisableGInt                 ; disable global interrupts
 0000           endif
 0000               and   reg[@0], ~@1              ; disable specified interrupt enable bit
 0000           if DISABLE_INT_FIX
 0000               and   A, CPUSCR_GIEMask         ; determine if global interrupt was set
 0000               jz    . + 4                     ; jump if global interrupt disabled
 0000               M8C_EnableGInt                  ; set global interrupt
 0000           endif
 0000               macro M8C_EnableIntMask                             
 0000               or    reg[@0], @1              
 0000               macro M8C_EnableWatchDog
 0000               ; Clearing the Power-On Reset bit starts up the Watchdog timer
 0000               ; See the 25xxx/26xxx Family Datasheet, Section 9.3.4.
 0000               and   reg[CPU_SCR], ~CPUSCR_PORSMask & ~CPUSCR_WDRSMask
 0000               macro M8C_ClearWDT
 0000               mov   reg[RES_WDT], 00h
 0000               macro M8C_ClearWDTAndSleep
 0000               mov   reg[RES_WDT], 38h
 0000               macro M8C_Stall
 0000               or    reg[ASY_CR], ASY_CR_SYNCEN
 0000               macro M8C_Unstall
 0000               and   reg[ASY_CR], ~ASY_CR_SYNCEN
 0000               macro M8C_Sleep
 0000               or    reg[CPU_SCR], CPUSCR_SleepMask
 0000               ; The next instruction to be executed depends on the state of the
 0000               ; various interrupt enable bits. If some interrupts are enabled
 0000               ; and the global interrupts are disabled, the next instruction will
 0000               ; be the one that follows the invocation of this macro. If global
 0000               ; interrupts are also enabled then the next instruction will be
 0000               ; from the interrupt vector table. If no interrupts are enabled
 0000               ; then RIP.
 0000               macro M8C_Stop
 0000               ; In general, you probably don't want to do this, but here's how:
 0000               or    reg[CPU_SCR], CPUSCR_StopMask
 0000               ; Next instruction to be executed is located in the interrupt
 0000               ; vector table entry for Power-On Reset.
 0000               macro M8C_Reset
 0000               ; Restore everything to the power-on reset state.
 0000               mov A, 0
 0000               SSC
 0000               ; Next non-supervisor instruction will be at interrupt vector 0.
 0000               macro SSC
 0000               db 0
 00F8              bSSC_KEY1:                       equ      F8h   ; supervisory key
 00F9              bSSC_KEYSP:                      equ      F9h   ; supervisory stack ptr key
 00FA              bSSC_TABLE_TableId:              equ      FAh   ; table ID
 0000                    
 003A           OPER_KEY:		                    equ      3Ah   ; operation key
 0000           ;--------------------------------
 0000           ; SSC_Action macro command codes 
 0000           ;--------------------------------
 0001           FLASH_READ:                         equ      1     ; flash read command
 0002           FLASH_WRITE:                        equ      2     ; flash write command
 0003           FLASH_ERASE:                        equ      3     ; flash erase command
 0004           PROTECT_BLOCK:						equ		 4	   ; flash protect block command
 0006           TABLE_READ:							equ      6     ; table read command
 0007           FLASH_CHECKSUM:						equ      7	   ; flash checksum calculation command
 0000           ;--------------------------------
 0000           ; SSC_Action table read addresses
 0000           ;--------------------------------
 00F8           SILICON_ID_1:						equ		 F8h   ; first byte of silicon ID
 00F9           SILICON_ID_0:						equ		 F9h   ; second byte of silicon ID
 00F8           VOLTAGE_TRIM_3V:					equ		 F8h   ; 3.3V internal voltage reference trim value
 00F9           OSCILLATOR_TRIM_3V:					equ		 F9h   ; 3.3V internal main oscillator trim value
 00FC           VOLTAGE_TRIM_5V:					equ		 FCh   ; 5V internal voltage reference trim value
 00FD           OSCILLATOR_TRIM_5V:					equ		 FDh   ; 5V internal main oscillator trim value
 0000           ;-----------------------------------------------------------------------------
 0000           ;  MACRO NAME: SSC_Action
 0000           ;
 0000           ;  DESCRIPTION:
 0000           ;     Performs locally defined supervisory operations.
 0000           ;     Macro Instantiation: SSC_Action bOperation
 0000           ;
 0000           ;     !!! DO NOT CHANGE THIS CODE !!!
 0000           ;        This sequence of opcodes provides a 
 0000           ;        signature for the debugger and ICE.
 0000           ;     !!! DO NOT CHANGE THIS CODE !!!
 0000           ;
 0000           ;  ARGUMENTS:
 0000           ;     BYTE  bOperation   - specified supervisory operation - defined operations
 0000           ;                          are:  FLASH_WRITE, FLASH_ERASE, FLASH_READ, TABLE_READ,
 0000           ;                                FLASH_CHECKSUM, PROTECT_BLOCK
 0000           ;
 0000           ;  RETURNS:
 0000           ;     none.
 0000           ;
 0000           ;  SIDE EFFECTS:
 0000           ;     A and X registers are destroyed
 0000           ;
 0000           ;  PROCEDURE:  
 0000           ;     1) specify a 3 byte stack frame.  Save in [KEYSP]
 0000           ;     2) insert the flash Supervisory key in [KEY1]
 0000           ;     3) store function code in A
 0000           ;     4) call the supervisory code
 0000           ;-----------------------------------------------------------------------------
 0000           macro SSC_Action  
 0000                 mov   X, SP                         ; copy SP into X
 0000                 mov   A, X                          ; mov to A
 0000                 add   A, 3                          ; create 3 byte stack frame
 0000                 mov   [bSSC_KEYSP], A               ; save stack frame for supervisory code
 0000                 mov   [bSSC_KEY1], OPER_KEY                 ; load the supervisory code for supervisory operations
 0000                 mov   A, @0                         ; load A with specific Flash operation
 0000                 SSC                                 ; SSC call the supervisory code
 0000           C_LANGUAGE_SUPPORT: equ 0         ;Set to 0 to optimize for ASM only
 0000           
 0000           ;-----------------------------------------------------------------------------
 0000           ; Export Declarations
 0000           ;-----------------------------------------------------------------------------
 0000           
                export __start
                export _exit
                export __bss_start
                
                export __lit_start
                export __idata_start
                export __data_start
                export __func_lit_start
                export __text_start
                
                
                ;-----------------------------------------------------------------------------
                ; Interrupt Vector Table
                ;-----------------------------------------------------------------------------
                ;
                ; Interrupt vector table entries are 4 bytes long and contain the code
                ; that services the interrupt (or causes it to be serviced).
                ;
                ;-----------------------------------------------------------------------------
                
                
                    AREA    TOP(ROM, ABS)
                
                    org 0                         ;Reset Interrupt Vector
 0000 8041          jmp __start                   ;First instruction executed following a Reset
 0002           
                    org 04h                       ;Supply Monitor Interrupt Vector
 0004 30            halt                          ;Stop execution if power falls too low
 0005 7E            reti
 0006           
                    org 08h                       ;PSoC Block DBA00 Interrupt Vector
 0008 7D0000        ljmp        ADC_TMR_INT
 000B 7E            reti
 000C           
                    org 0Ch                       ;PSoC Block DBA01 Interrupt Vector
 000C 7D0000        ljmp        ADC_CNT_INT
 000F 7E            reti
 0010           
                    org 10h                       ;PSoC Block DBA02 Interrupt Vector
 0010 7D0000        ljmp        BAUDCLKINT
 0013 7E            reti
 0014           
                    org 14h                       ;PSoC Block DBA03 Interrupt Vector
 0014 7D0000        ljmp        SampleCLKINT
 0017 7E            reti
 0018           
                    org 18h                       ;PSoC Block DCA04 Interrupt Vector
 0018 7D0000        ljmp        UARTOUTTX_INT
 001B 7E            reti
 001C           
                    org 1Ch                       ;PSoC Block DCA05 Interrupt Vector
 001C 7D0000        ljmp        UARTOUTRX_INT
 001F 7E            reti
 0020           
                    org 20h                       ;PSoC Block DCA06 Interrupt Vector
 0020 7D0000        ljmp        UARTINRX_INT
 0023 7E            reti
 0024           
                    org 24h                       ;PSoC Block DCA07 Interrupt Vector
 0024 7D0000        ljmp        UARTINTX_INT
 0027 7E            reti
 0028           
                    org 28h                       ;Analog Column 0 Interrupt Vector
                    // call     void_handler
 0028 7E            reti
 0029           
                    org 2Ch                       ;Analog Column 1 Interrupt Vector
                    // call     void_handler
 002C 7E            reti
 002D           
                    org 30h                       ;Analog Column 2 Interrupt Vector
                    // call     void_handler
 0030 7E            reti
 0031           
                    org 34h                       ;Analog Column 3 Interrupt Vector
                    // call     void_handler
 0034 7E            reti
 0035           
                    org 38h                       ;GPIO Interrupt Vector
                    // call     void_handler
 0038 7E            reti
 0039           
                    org 3Ch                       ;Sleep Timer Interrupt Vector
 003C 8002          jmp SleepTimerISR
 003E 7E            reti
 003F           
 003F           ;-----------------------------------------------------------------------------
 003F           ;  Sleep Timer ISR
 003F           ;-----------------------------------------------------------------------------
 003F           ;  This code uses conditional compiler flags to enable code to initialize the 
 003F           ;  External Crystal Oscillator (ECO) and the PLL_Lock mode of the Internal 
 003F           ;  Main Oscillator (IMO).  If the ECO and the IMO PLL_Lock mode are not used,
 003F           ;  the initialization code is not compiled.
 003F           ;-----------------------------------------------------------------------------
                IF SELECT_32K
                    export  _ClockNotStable
                    FIRST_TIME:       equ  2h
                    SECOND_TIME:      equ  1h
                    CLOCK_STABLE:     equ  0h
                ENDIF
                
 003F           SleepTimerISR:
 003F 08            push A
 0040           
 0001               NO_USER_SLEEP_ISR:  equ  1    ;Change this equate to 0 if adding ISR
 0040           	// Insert user Sleep Timer Interrupt code here. //
 0040           	// See NOTES at the top of this file.           //
 0040           
                    IF SELECT_32K
                        mov A,[ClockNotStable]    ;ClockNotStable is also state of clock init
                        jz   NormalSleep
                        IF PLL_MODE        
                            dec A
                            jz  SecondTime        ;This case is only needed if PLL_Lock
                        ENDIF
                            jmp  FirstTime        ;This case is only needed if the ECO is used
                    ENDIF
                
 0040           NormalSleep:
 0040 18            pop A                         ;normal sleep 
 0041 7E            reti
 0042           
                   IF SELECT_32K
                   FirstTime:
                   ; 1st time through the SleepISR. Will arrive here 1 second after boot
                   ; the External Crystal Oscillator (ECO) is now stable.
                   ; If both ECO and PLL_Lock, then turn on PLL_Lock and wait for it to 
                   ; stabilize. Set SleepClock to 64 Hz, set PLL Mode bit, set CPU_Clock to
                   ; 3 MHz, set ClockNotStable to SECOND_TIME. The clock initialization is
                   ; not yet complete.
                   ; If ECO but not PLL_Lock, set SleepClock to user selection, set 
                   ; ClockNotStable to CLOCK_STABLE. The clock initialization is complete.
                
                      IF PLL_MODE
                    or    F, FlagXIOMask
                         IF (CPU_CLOCK_JUST & 04h)   ;CPU setting in Device Editor is <3MHz
                            ;Enable PLL, set sleep timer to 64Hz and CPU per Device Editor
                            mov reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_Sleep_64Hz |CPU_CLOCK_JUST)
                         ELSE             ;CPU setting in Device Editor is >=3MHz
                            ;Enable PLL, set sleep timer to 64Hz and CPU clock to 3MHz
                            mov reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_Sleep_64Hz | OSC_CR0_CPU_3MHz)
                         ENDIF
                    and   F, ~FlagXIOMask
                         mov [ClockNotStable],SECOND_TIME
                      ELSE
                         ;Set the sleep timer, PLL (disabled) & CPU per Device Editor
                    or    F, FlagXIOMask
                         mov reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
                    and   F, ~FlagXIOMask
                         mov [ClockNotStable],CLOCK_STABLE
                         IF NO_USER_SLEEP_ISR     ;turn off Sleep Int if no longer needed
                if DISABLE_INT_FIX
                    mov   A, reg[CPU_SCR]           ; save the current Global interrupt state
                    and   F, ~FlagGlobalIE
                endif
                    and   reg[INT_MSK0], ~INT_MSK0_Sleep              ; disable specified interrupt enable bit
                if DISABLE_INT_FIX
                    and   A, CPUSCR_GIEMask         ; determine if global interrupt was set
                    jz    . + 4                     ; jump if global interrupt disabled
                    or    F, FlagGlobalIE
                endif
                         ENDIF
                      ENDIF
                      pop A
                      reti
                   ENDIF
                   
                   IF PLL_MODE
                SecondTime:    
                      ; 2nd time through SleepISR. Compiled only if PLL_Mode set to Ext Lock
                    or    F, FlagXIOMask
                      ; Set the sleep timer and CPU per Device Editor
                      mov reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
                    and   F, ~FlagXIOMask
                      mov [_ClockNotStable],CLOCK_STABLE
                      IF NO_USER_SLEEP_ISR
                if DISABLE_INT_FIX
                    mov   A, reg[CPU_SCR]           ; save the current Global interrupt state
                    and   F, ~FlagGlobalIE
                endif
                    and   reg[INT_MSK0], ~INT_MSK0_Sleep              ; disable specified interrupt enable bit
                if DISABLE_INT_FIX
                    and   A, CPUSCR_GIEMask         ; determine if global interrupt was set
                    jz    . + 4                     ; jump if global interrupt disabled
                    or    F, FlagGlobalIE
                endif
                      ENDIF
                      pop A
                      reti
                   ENDIF
                
                   IF (PLL_MODE & ~SELECT_32K)
                      These lines intentionally generate syntax errors to alert you that you
                      have selected an invalid state.  Setting PLL Mode to Ext Lock without
                      32K_Select set to External is not allowed.
                   ENDIF
                
                ;-----------------------------------------------------------------------------
                ;  Start of Execution
                ;-----------------------------------------------------------------------------
 0042           __start:
 0042 5000          mov A,__bss_end               ;Set top of stack to end of used RAM
 0044 4E            swap SP,A
 0045               ;-------------------------------------------------------------------------
 0045               ; Set clock trim if the operating voltage is 3.3V. On power up, 5V is
 0045               ; loaded, so this is only needed for 3.3V operation.
 0045               ;-------------------------------------------------------------------------
                    IF (SUPPLY_VOLTAGE)               ; 1 means 5.0V
                    ELSE                              ; 0 means 3.3V
                       mov  [bSSC_TABLE_TableId], 1   ; Point to the Trim table
                      mov   X, SP                         ; copy SP into X
                      mov   A, X                          ; mov to A
                      add   A, 3                          ; create 3 byte stack frame
                      mov   [bSSC_KEYSP], A               ; save stack frame for supervisory code
                      mov   [bSSC_KEY1], OPER_KEY                 ; load the supervisory code for supervisory operations
                      mov   A, TABLE_READ                         ; load A with specific Flash operation
                    db 0
                    or    F, FlagXIOMask
                       mov  A, [OSCILLATOR_TRIM_3V]   
                       mov  reg[IMO_TR], A            ; Load the 3V trim oscillator setting
                       mov  A, [VOLTAGE_TRIM_3V]
                       mov  reg[BDG_TR], A            ; Load the bandgap trim setting for 3V
                       IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
                       ELSE
                          These lines intentionally generate syntax errors to alert you
                          that you have selected an invalid state.  The CPU_CLock cannot
                          be run at 24 MHz when the chip operating voltage is below 4.75V
                       ENDIF
                    ENDIF
                
                
                    ;-------------------------------------------------------------------------
                    ; Initialize oscillator register
                    ;-------------------------------------------------------------------------
                    IF SELECT_32K
                       ;If 32K is set to External, turn the pins used by the crystal to Hi-Z.
                       ;Then, set the sleep timer to 1Hz & reset the sleep timer.  (Don't turn
                       ;on the ECO yet, because if the Sleep Timer happens to time out it will
                       ;enable the ECO too soon).  Then enable ECO, enable sleep interrupt,
                       ;and initialize ClockNotStable, which can be used as a flag in _main to
                       ;indicate that the clocks are stable.  It is also used as a state
                       ;variable for the clock initialization.
                    
                    or    F, FlagXIOMask
                       mov reg[PRT1DM0],00h       ;P1[0] & P1[1] Drive Mode to High Z because
                       mov reg[PRT1DM1],03h       ; LoadConfigInit not run yet.
                       mov reg[ECO_TR],0Fh        ;adjust ECO trim
                       IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
                          ; set sleep to 1 sec and CPU to 12MHz during configuration
                          mov reg[OSC_CR0], (OSC_CR0_CPU_12MHz | OSC_CR0_Sleep_1Hz)
                       ELSE
                          ; set sleep to 1 sec and CPU to 24MHz
                          mov reg[OSC_CR0], (OSC_CR0_CPU_24MHz | OSC_CR0_Sleep_1Hz)
                       ENDIF
                    and   F, ~FlagXIOMask
                
                    mov   reg[RES_WDT], 38h
                    or    F, FlagXIOMask
                       or  reg[OSC_CR0],SELECT_32K_JUST  ;enable the ECO
                
                    and   F, ~FlagXIOMask
                    or    reg[INT_MSK0], INT_MSK0_Sleep              
                       mov [ClockNotStable],FIRST_TIME  ;initialize ClockNotStable
                    ELSE    ; If 32K is set to Internal, then no further initialization needed
 0045 7110          or    F, FlagXIOMask
                       IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
                          ; set sleep to 1 sec and CPU to 12MHz during configuration
                          mov reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                       ELSE
                          ; set sleep to 1 sec and CPU to 24MHz
 0047 62E003              mov reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST )
                       ENDIF
 004A 70EF          and   F, ~FlagXIOMask
                    ENDIF
                
                    ; default CT block RTopMux to OUT and RBotMux to AGND
 004C 627105        mov reg[ACA00CR0],05h
 004F 627505        mov reg[ACA01CR0],05h
 0052 627905        mov reg[ACA02CR0],05h
 0055 627D05        mov reg[ACA03CR0],05h
 0058 7C0000        lcall LoadConfigInit          ;Configure PSoC blocks per Dev Editor
 005B           
                    IF C_LANGUAGE_SUPPORT
                       call InitCRunTime          ;Initialize for C language
                    ENDIF
                    IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
                       ; Set the CPU clock to the user's selection
                    or    F, FlagXIOMask
                       mov reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
                    and   F, ~FlagXIOMask
                    ENDIF    
                
 005B 62E200        mov reg[INT_VC],0             ;Clear any pending interrupts which may
 005E                                             ; have been set during the boot process. 
                    IF SELECT_32K
                    or    F, FlagGlobalIE
                    ENDIF
                
 005E 7C0000        lcall _main                   ;Call main
 0061           _exit:
 0061 8FFF          jmp _exit
 0063           
                IF C_LANGUAGE_SUPPORT
                ;-----------------------------------------------------------------------------
                ;;    C Runtime Environment Initialization
                ;-----------------------------------------------------------------------------
                
                InitCRunTime:
                    ;-----------------------------
                    ; clear bss segment
                    ;-----------------------------
                    mov A,0
                    mov [__r0],<__bss_start
                BssLoop:
                    cmp [__r0],<__bss_end
                    jz BssDone
                    mvi [__r0],A
                    jmp BssLoop
                BssDone:
                    ;----------------------------
                    ; copy idata to data segment
                    ;----------------------------
                    mov A,>__idata_start
                    mov X,<__idata_start
                    mov [__r0],<__data_start
                IDataLoop:
                    cmp [__r0],<__data_end
                    jz IDataDone
                    push A
                    romx
                    mvi [__r0],A
                    pop A
                    inc X
                    adc A,0
                    jmp IDataLoop
                IDataDone:
                    ret
                
                ENDIF
                ;------------------------------------------------------
                ;;  RAM segments for C CONST, static & global items
                ;------------------------------------------------------
                
                    AREA lit
 0000           __lit_start:
 0000           
                    AREA idata
 0000           __idata_start:
 0000           
                        AREA func_lit
 0000           __func_lit_start:
 0000           
 0000           ;---------------------------------------------
 0000           ;         CODE segment for general use
 0000           ;---------------------------------------------
                        AREA text(rom)
 0000           __text_start:
 0000           
 0000           ;---------------------------------------------
 0000           ;         Begin RAM area usage
 0000           ;---------------------------------------------
                    AREA data(ram)
 0000           __data_start:
 0000           
                    AREA virtual_registers(ram)
 0000           __virtual_registers_end:
 0000           
                IF SELECT_32K              ;Used to track initialization of ECO and PLL
                   AREA eco_pll(ram)
                   ClockNotStable:
                   _ClockNotStable:      BLK   1
                ENDIF
                
                
                ;---------------------------------------------
                ;         RAM segment for general use
                ;---------------------------------------------
                    AREA bss(ram)
 0000           __bss_start:
 0000           
 0000           ; end of file
