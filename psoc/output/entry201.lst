    0000: 80 41    JMP   0x0042
    0002: 30       HALT  
    0003: 30       HALT  
FILE: E:\CONTES~1\ENTRY201\BOOT.ASM
(0001) ;$Id: //depot/Rel_3.1/BuildMediaPSoC/Executables/Templates/boot.tpl#3 $
(0002) ;=============================================================================
(0003) ;  FILENAME:   boot.asm
(0004) ;   VERSION:   3.06
(0005) ;      DATE:   2 April 2002
(0006) ;
(0007) ;  DESCRIPTION:
(0008) ;   M8C Boot Code from Reset.
(0009) ;
(0010) ;   Copyright (c) Cypress MicroSystems 2001, 2002. All rights reserved.
(0011) ;
(0012) ; NOTES:
(0013) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
(0014) ; the project's root directory to create BOOT.ASM. Any changes made to 
(0015) ; BOOT.ASM will be  overwritten every time the project is generated; therfore
(0016) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
(0017) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
(0018) ; are not accidentally modified.
(0019) ;
(0020) ; The start of _main is at a fixed location so care must be taken when adding
(0021) ; user code for the Sleep Interrupt. If too much code is added, the end of 
(0022) ; BOOT.ASM will extend into _main and cause a linker error. The safest way
(0023) ; to add code for the Sleep Interrupt is to CALL a separate routine that 
(0024) ; contains the desired additional Sleep Interrupt code.
(0025) ;=============================================================================
(0026) 
(0027) include ".\lib\entry201_GlobalParams.inc"
(0028) include "m8c.inc"
(0029) include "m8ssc.inc"
(0030) 
(0031) ;-----------------------------------------------------------------------------
(0032) ; Optimization flags
(0033) ;-----------------------------------------------------------------------------
(0034) 
(0035) C_LANGUAGE_SUPPORT: equ 0         ;Set to 0 to optimize for ASM only
(0036) 
(0037) ;-----------------------------------------------------------------------------
(0038) ; Export Declarations
(0039) ;-----------------------------------------------------------------------------
(0040) 
(0041) export __start
(0042) export _exit
(0043) export __bss_start
(0044) 
(0045) export __lit_start
(0046) export __idata_start
(0047) export __data_start
(0048) export __func_lit_start
(0049) export __text_start
(0050) 
(0051) 
(0052) ;-----------------------------------------------------------------------------
(0053) ; Interrupt Vector Table
(0054) ;-----------------------------------------------------------------------------
(0055) ;
(0056) ; Interrupt vector table entries are 4 bytes long and contain the code
(0057) ; that services the interrupt (or causes it to be serviced).
(0058) ;
(0059) ;-----------------------------------------------------------------------------
(0060) 
(0061) 
(0062)     AREA    TOP(ROM, ABS)
(0063) 
(0064)     org 0                         ;Reset Interrupt Vector
(0065)     jmp __start                   ;First instruction executed following a Reset
(0066) 
(0067)     org 04h                       ;Supply Monitor Interrupt Vector
(0068)     halt                          ;Stop execution if power falls too low
    0004: 30       HALT  
(0069)     reti
    0005: 7E       RETI  
    0006: 30       HALT  
    0007: 30       HALT  
(0070) 
(0071)     org 08h                       ;PSoC Block DBA00 Interrupt Vector
(0072)     ljmp	ADC_TMR_INT
    0008: 7D 0C B5 LJMP  ADC_TMR_INT
(0073)     reti
    000B: 7E       RETI  
(0074) 
(0075)     org 0Ch                       ;PSoC Block DBA01 Interrupt Vector
(0076)     ljmp	ADC_CNT_INT
    000C: 7D 0C B2 LJMP  ADC_CNT_INT
(0077)     reti
    000F: 7E       RETI  
(0078) 
(0079)     org 10h                       ;PSoC Block DBA02 Interrupt Vector
(0080)     ljmp	BAUDCLKINT
    0010: 7D 0C 53 LJMP  BAUDCLKINT
(0081)     reti
    0013: 7E       RETI  
(0082) 
(0083)     org 14h                       ;PSoC Block DBA03 Interrupt Vector
(0084)     ljmp	SampleCLKINT
    0014: 7D 09 69 LJMP  SampleCLKINT
(0085)     reti
    0017: 7E       RETI  
(0086) 
(0087)     org 18h                       ;PSoC Block DCA04 Interrupt Vector
(0088)     ljmp	UARTOUTTX_INT
    0018: 7D 08 CD LJMP  UARTOUTTX_INT
(0089)     reti
    001B: 7E       RETI  
(0090) 
(0091)     org 1Ch                       ;PSoC Block DCA05 Interrupt Vector
(0092)     ljmp	UARTOUTRX_INT
    001C: 7D 08 CE LJMP  UARTOUTRX_INT
(0093)     reti
    001F: 7E       RETI  
(0094) 
(0095)     org 20h                       ;PSoC Block DCA06 Interrupt Vector
(0096)     ljmp	UARTINRX_INT
    0020: 7D 09 0C LJMP  UARTINRX_INT
(0097)     reti
    0023: 7E       RETI  
(0098) 
(0099)     org 24h                       ;PSoC Block DCA07 Interrupt Vector
(0100)     ljmp	UARTINTX_INT
    0024: 7D 09 0B LJMP  UARTINTX_INT
(0101)     reti
    0027: 7E       RETI  
(0102) 
(0103)     org 28h                       ;Analog Column 0 Interrupt Vector
(0104)     // call	void_handler
(0105)     reti
    0028: 7E       RETI  
    0029: 30       HALT  
    002A: 30       HALT  
    002B: 30       HALT  
(0106) 
(0107)     org 2Ch                       ;Analog Column 1 Interrupt Vector
(0108)     // call	void_handler
(0109)     reti
    002C: 7E       RETI  
    002D: 30       HALT  
    002E: 30       HALT  
    002F: 30       HALT  
(0110) 
(0111)     org 30h                       ;Analog Column 2 Interrupt Vector
(0112)     // call	void_handler
(0113)     reti
    0030: 7E       RETI  
    0031: 30       HALT  
    0032: 30       HALT  
    0033: 30       HALT  
(0114) 
(0115)     org 34h                       ;Analog Column 3 Interrupt Vector
(0116)     // call	void_handler
(0117)     reti
    0034: 7E       RETI  
    0035: 30       HALT  
    0036: 30       HALT  
    0037: 30       HALT  
(0118) 
(0119)     org 38h                       ;GPIO Interrupt Vector
(0120)     // call	void_handler
(0121)     reti
    0038: 7E       RETI  
    0039: 30       HALT  
    003A: 30       HALT  
    003B: 30       HALT  
(0122) 
(0123)     org 3Ch                       ;Sleep Timer Interrupt Vector
(0124)     jmp SleepTimerISR
    003C: 80 02    JMP   0x003F
(0125)     reti
    003E: 7E       RETI  
(0126) 
(0127) ;-----------------------------------------------------------------------------
(0128) ;  Sleep Timer ISR
(0129) ;-----------------------------------------------------------------------------
(0130) ;  This code uses conditional compiler flags to enable code to initialize the 
(0131) ;  External Crystal Oscillator (ECO) and the PLL_Lock mode of the Internal 
(0132) ;  Main Oscillator (IMO).  If the ECO and the IMO PLL_Lock mode are not used,
(0133) ;  the initialization code is not compiled.
(0134) ;-----------------------------------------------------------------------------
(0135) IF SELECT_32K
(0136)     export  _ClockNotStable
(0137)     FIRST_TIME:       equ  2h
(0138)     SECOND_TIME:      equ  1h
(0139)     CLOCK_STABLE:     equ  0h
(0140) ENDIF
(0141) 
(0142) SleepTimerISR:
(0143)     push A
    003F: 08       PUSH  A
(0144) 
(0145)     NO_USER_SLEEP_ISR:  equ  1    ;Change this equate to 0 if adding ISR
(0146) 	// Insert user Sleep Timer Interrupt code here. //
(0147) 	// See NOTES at the top of this file.           //
(0148) 
(0149)     IF SELECT_32K
(0150)         mov A,[ClockNotStable]    ;ClockNotStable is also state of clock init
(0151)         jz   NormalSleep
(0152)         IF PLL_MODE        
(0153)             dec A
(0154)             jz  SecondTime        ;This case is only needed if PLL_Lock
(0155)         ENDIF
(0156)             jmp  FirstTime        ;This case is only needed if the ECO is used
(0157)     ENDIF
(0158) 
(0159) NormalSleep:
(0160)     pop A                         ;normal sleep 
    0040: 18       POP   A
(0161)     reti
    0041: 7E       RETI  
(0162) 
(0163)    IF SELECT_32K
(0164)    FirstTime:
(0165)    ; 1st time through the SleepISR. Will arrive here 1 second after boot
(0166)    ; the External Crystal Oscillator (ECO) is now stable.
(0167)    ; If both ECO and PLL_Lock, then turn on PLL_Lock and wait for it to 
(0168)    ; stabilize. Set SleepClock to 64 Hz, set PLL Mode bit, set CPU_Clock to
(0169)    ; 3 MHz, set ClockNotStable to SECOND_TIME. The clock initialization is
(0170)    ; not yet complete.
(0171)    ; If ECO but not PLL_Lock, set SleepClock to user selection, set 
(0172)    ; ClockNotStable to CLOCK_STABLE. The clock initialization is complete.
(0173) 
(0174)       IF PLL_MODE
(0175)          M8C_SetBank1
(0176)          IF (CPU_CLOCK_JUST & 04h)   ;CPU setting in Device Editor is <3MHz
(0177)             ;Enable PLL, set sleep timer to 64Hz and CPU per Device Editor
(0178)             mov reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_Sleep_64Hz |CPU_CLOCK_JUST)
(0179)          ELSE             ;CPU setting in Device Editor is >=3MHz
(0180)             ;Enable PLL, set sleep timer to 64Hz and CPU clock to 3MHz
(0181)             mov reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_Sleep_64Hz | OSC_CR0_CPU_3MHz)
(0182)          ENDIF
(0183)          M8C_SetBank0
(0184)          mov [ClockNotStable],SECOND_TIME
(0185)       ELSE
(0186)          ;Set the sleep timer, PLL (disabled) & CPU per Device Editor
(0187)          M8C_SetBank1
(0188)          mov reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
(0189)          M8C_SetBank0
(0190)          mov [ClockNotStable],CLOCK_STABLE
(0191)          IF NO_USER_SLEEP_ISR     ;turn off Sleep Int if no longer needed
(0192)             M8C_DisableIntMask INT_MSK0,INT_MSK0_Sleep
(0193)          ENDIF
(0194)       ENDIF
(0195)       pop A
(0196)       reti
(0197)    ENDIF
(0198)    
(0199)    IF PLL_MODE
(0200) SecondTime:    
(0201)       ; 2nd time through SleepISR. Compiled only if PLL_Mode set to Ext Lock
(0202)       M8C_SetBank1
(0203)       ; Set the sleep timer and CPU per Device Editor
(0204)       mov reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
(0205)       M8C_SetBank0
(0206)       mov [_ClockNotStable],CLOCK_STABLE
(0207)       IF NO_USER_SLEEP_ISR
(0208)          M8C_DisableIntMask INT_MSK0,INT_MSK0_Sleep
(0209)       ENDIF
(0210)       pop A
(0211)       reti
(0212)    ENDIF
(0213) 
(0214)    IF (PLL_MODE & ~SELECT_32K)
(0215)       These lines intentionally generate syntax errors to alert you that you
(0216)       have selected an invalid state.  Setting PLL Mode to Ext Lock without
(0217)       32K_Select set to External is not allowed.
(0218)    ENDIF
(0219) 
(0220) ;-----------------------------------------------------------------------------
(0221) ;  Start of Execution
(0222) ;-----------------------------------------------------------------------------
(0223) __start:
(0224)     mov A,__bss_end               ;Set top of stack to end of used RAM
    0042: 50 46    MOV   A,70
(0225)     swap SP,A
    0044: 4E       SWAP  SP,A
    0045: 71 10    OR    F,16
(0226)     ;-------------------------------------------------------------------------
(0227)     ; Set clock trim if the operating voltage is 3.3V. On power up, 5V is
(0228)     ; loaded, so this is only needed for 3.3V operation.
(0229)     ;-------------------------------------------------------------------------
(0230)     IF (SUPPLY_VOLTAGE)               ; 1 means 5.0V
(0231)     ELSE                              ; 0 means 3.3V
(0232)        mov  [bSSC_TABLE_TableId], 1   ; Point to the Trim table
(0233)        SSC_Action TABLE_READ          ; Perform a table read supervisor call
(0234)        M8C_SetBank1
(0235)        mov  A, [OSCILLATOR_TRIM_3V]   
(0236)        mov  reg[IMO_TR], A            ; Load the 3V trim oscillator setting
(0237)        mov  A, [VOLTAGE_TRIM_3V]
(0238)        mov  reg[BDG_TR], A            ; Load the bandgap trim setting for 3V
(0239)        IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
(0240)        ELSE
(0241)           These lines intentionally generate syntax errors to alert you
(0242)           that you have selected an invalid state.  The CPU_CLock cannot
(0243)           be run at 24 MHz when the chip operating voltage is below 4.75V
(0244)        ENDIF
(0245)     ENDIF
(0246) 
(0247) 
(0248)     ;-------------------------------------------------------------------------
(0249)     ; Initialize oscillator register
(0250)     ;-------------------------------------------------------------------------
(0251)     IF SELECT_32K
(0252)        ;If 32K is set to External, turn the pins used by the crystal to Hi-Z.
(0253)        ;Then, set the sleep timer to 1Hz & reset the sleep timer.  (Don't turn
(0254)        ;on the ECO yet, because if the Sleep Timer happens to time out it will
(0255)        ;enable the ECO too soon).  Then enable ECO, enable sleep interrupt,
(0256)        ;and initialize ClockNotStable, which can be used as a flag in _main to
(0257)        ;indicate that the clocks are stable.  It is also used as a state
(0258)        ;variable for the clock initialization.
(0259)     
(0260)        M8C_SetBank1
(0261)        mov reg[PRT1DM0],00h       ;P1[0] & P1[1] Drive Mode to High Z because
(0262)        mov reg[PRT1DM1],03h       ; LoadConfigInit not run yet.
(0263)        mov reg[ECO_TR],0Fh        ;adjust ECO trim
(0264)        IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
(0265)           ; set sleep to 1 sec and CPU to 12MHz during configuration
(0266)           mov reg[OSC_CR0], (OSC_CR0_CPU_12MHz | OSC_CR0_Sleep_1Hz)
(0267)        ELSE
(0268)           ; set sleep to 1 sec and CPU to 24MHz
(0269)           mov reg[OSC_CR0], (OSC_CR0_CPU_24MHz | OSC_CR0_Sleep_1Hz)
(0270)        ENDIF
(0271)        M8C_SetBank0
(0272) 
(0273)        M8C_ClearWDTAndSleep       ;reset the sleep timer
(0274)        M8C_SetBank1
(0275)        or  reg[OSC_CR0],SELECT_32K_JUST  ;enable the ECO
(0276) 
(0277)        M8C_SetBank0
(0278)        M8C_EnableIntMask INT_MSK0, INT_MSK0_Sleep
(0279)        mov [ClockNotStable],FIRST_TIME  ;initialize ClockNotStable
(0280)     ELSE    ; If 32K is set to Internal, then no further initialization needed
(0281)        M8C_SetBank1
(0282)        IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
(0283)           ; set sleep to 1 sec and CPU to 12MHz during configuration
(0284)           mov reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
(0285)        ELSE
(0286)           ; set sleep to 1 sec and CPU to 24MHz
(0287)           mov reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST )
    0047: 62 E0 03 MOV   REG[224],3
    004A: 70 EF    AND   F,239
(0288)        ENDIF
(0289)        M8C_SetBank0
(0290)     ENDIF
(0291) 
(0292)     ; default CT block RTopMux to OUT and RBotMux to AGND
(0293)     mov reg[ACA00CR0],05h
    004C: 62 71 05 MOV   REG[113],5
(0294)     mov reg[ACA01CR0],05h
    004F: 62 75 05 MOV   REG[117],5
(0295)     mov reg[ACA02CR0],05h
    0052: 62 79 05 MOV   REG[121],5
(0296)     mov reg[ACA03CR0],05h
    0055: 62 7D 05 MOV   REG[125],5
(0297)     lcall LoadConfigInit          ;Configure PSoC blocks per Dev Editor
    0058: 7C 0A C6 LCALL _LoadConfigInit
(0298) 
(0299)     IF C_LANGUAGE_SUPPORT
(0300)        call InitCRunTime          ;Initialize for C language
(0301)     ENDIF
(0302)     IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
(0303)        ; Set the CPU clock to the user's selection
(0304)        M8C_SetBank1
(0305)        mov reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
(0306)        M8C_SetBank0
(0307)     ENDIF    
(0308) 
(0309)     mov reg[INT_VC],0             ;Clear any pending interrupts which may
    005B: 62 E2 00 MOV   REG[226],0
(0310)                                   ; have been set during the boot process. 
(0311)     IF SELECT_32K
(0312)        M8C_EnableGInt             ;Enable global interrupts
(0313)     ENDIF
(0314) 
(0315)     lcall _main                   ;Call main
    005E: 7C 05 E8 LCALL _main
(0316) _exit:
(0317)     jmp _exit
    0061: 8F FF    JMP   0x0061
    0063: 30       HALT  
    0064: 30       HALT  
    0065: 30       HALT  
    0066: 30       HALT  
    0067: 30       HALT  
    0068: 30       HALT  
    0069: 30       HALT  
    006A: 30       HALT  
    006B: 30       HALT  
    006C: 30       HALT  
    006D: 30       HALT  
    006E: 30       HALT  
    006F: 30       HALT  
    0070: 30       HALT  
    0071: 30       HALT  
    0072: 30       HALT  
    0073: 30       HALT  
    0074: 30       HALT  
    0075: 30       HALT  
    0076: 30       HALT  
    0077: 30       HALT  
    0078: 30       HALT  
    0079: 30       HALT  
    007A: 30       HALT  
    007B: 30       HALT  
    007C: 30       HALT  
    007D: 30       HALT  
    007E: 30       HALT  
    007F: 30       HALT  
    0080: 30       HALT  
    0081: 30       HALT  
    0082: 30       HALT  
    0083: 30       HALT  
    0084: 30       HALT  
    0085: 30       HALT  
    0086: 30       HALT  
    0087: 30       HALT  
    0088: 30       HALT  
    0089: 30       HALT  
    008A: 30       HALT  
    008B: 30       HALT  
    008C: 30       HALT  
    008D: 30       HALT  
    008E: 30       HALT  
    008F: 30       HALT  
    0090: 30       HALT  
    0091: 30       HALT  
    0092: 30       HALT  
    0093: 30       HALT  
    0094: 30       HALT  
    0095: 30       HALT  
    0096: 30       HALT  
    0097: 30       HALT  
    0098: 30       HALT  
    0099: 30       HALT  
    009A: 30       HALT  
    009B: 30       HALT  
    009C: 30       HALT  
    009D: 30       HALT  
    009E: 30       HALT  
    009F: 30       HALT  
    00A0: 30       HALT  
    00A1: 30       HALT  
    00A2: 30       HALT  
    00A3: 30       HALT  
    00A4: 30       HALT  
    00A5: 30       HALT  
    00A6: 30       HALT  
    00A7: 30       HALT  
    00A8: 30       HALT  
    00A9: 30       HALT  
    00AA: 30       HALT  
    00AB: 30       HALT  
    00AC: 30       HALT  
    00AD: 30       HALT  
    00AE: 30       HALT  
    00AF: 30       HALT  
    00B0: 30       HALT  
    00B1: 30       HALT  
    00B2: 30       HALT  
    00B3: 30       HALT  
    00B4: 30       HALT  
    00B5: 30       HALT  
    00B6: 30       HALT  
    00B7: 30       HALT  
    00B8: 30       HALT  
    00B9: 30       HALT  
    00BA: 30       HALT  
    00BB: 30       HALT  
    00BC: 30       HALT  
    00BD: 30       HALT  
    00BE: 30       HALT  
    00BF: 30       HALT  
    00C0: 30       HALT  
    00C1: 30       HALT  
    00C2: 30       HALT  
    00C3: 30       HALT  
    00C4: 30       HALT  
    00C5: 30       HALT  
    00C6: 30       HALT  
    00C7: 30       HALT  
    00C8: 30       HALT  
    00C9: 30       HALT  
    00CA: 30       HALT  
    00CB: 30       HALT  
    00CC: 30       HALT  
    00CD: 30       HALT  
    00CE: 30       HALT  
    00CF: 30       HALT  
    00D0: 30       HALT  
    00D1: 30       HALT  
    00D2: 30       HALT  
    00D3: 30       HALT  
    00D4: 30       HALT  
    00D5: 30       HALT  
    00D6: 30       HALT  
    00D7: 30       HALT  
    00D8: 30       HALT  
    00D9: 30       HALT  
    00DA: 30       HALT  
    00DB: 30       HALT  
    00DC: 30       HALT  
    00DD: 30       HALT  
    00DE: 30       HALT  
    00DF: 30       HALT  
    00E0: 30       HALT  
    00E1: 30       HALT  
    00E2: 30       HALT  
    00E3: 30       HALT  
    00E4: 30       HALT  
    00E5: 30       HALT  
    00E6: 30       HALT  
    00E7: 30       HALT  
    00E8: 30       HALT  
    00E9: 30       HALT  
    00EA: 30       HALT  
    00EB: 30       HALT  
    00EC: 30       HALT  
    00ED: 30       HALT  
    00EE: 30       HALT  
    00EF: 30       HALT  
    00F0: 30       HALT  
    00F1: 30       HALT  
    00F2: 30       HALT  
    00F3: 30       HALT  
    00F4: 30       HALT  
    00F5: 30       HALT  
    00F6: 30       HALT  
    00F7: 30       HALT  
    00F8: 30       HALT  
    00F9: 30       HALT  
    00FA: 30       HALT  
    00FB: 30       HALT  
    00FC: 30       HALT  
    00FD: 30       HALT  
    00FE: 30       HALT  
    00FF: 30       HALT  
    0100: 30       HALT  
__text_start:
    0101: 01 02    ADD   A,2
    0103: 04 08    ADD   [8],A
    0105: 10       PUSH  X
    0106: 20       POP   X
    0107: 40       NOP   
    0108: 80 FE    JMP   0x0207
    010A: FD FB    INDEX 0xFF07
    010C: F7 EF    INDEX 0x08FD
    010E: DF BF    JNC   0x00CE
    0110: 7F       RET   
    0111: 21 07    AND   A,7
    0113: 53 00    MOV   [0],A
    0115: 6D       RRC   A
    0116: C0 45    JC    0x015C
    0118: 51 00    MOV   A,[0]
    011A: FF ED    INDEX 0x0109
    011C: 53 01    MOV   [1],A
    011E: 71 10    OR    F,16
    0120: 51 04    MOV   A,[4]
    0122: 22 01    AND   A,[1]
    0124: 60 00    MOV   REG[0],A
    0126: 53 04    MOV   [4],A
    0128: 51 00    MOV   A,[0]
    012A: FF D5    INDEX __text_start
    012C: 53 01    MOV   [1],A
    012E: 51 07    MOV   A,[7]
    0130: 2A 01    OR    A,[1]
    0132: 60 01    MOV   REG[1],A
    0134: 53 07    MOV   [7],A
    0136: 2E 03 40 OR    [3],64
    0139: 08       PUSH  A
    013A: 51 03    MOV   A,[3]
    013C: 71 10    OR    F,16
    013E: 60 62    MOV   REG[98],A
    0140: 70 EF    AND   F,239
    0142: 18       POP   A
    0143: 6B 00    RLC   [0]
    0145: 6B 00    RLC   [0]
    0147: 6B 00    RLC   [0]
    0149: 6B 00    RLC   [0]
    014B: 6B 00    RLC   [0]
    014D: 26 00 C0 AND   [0],192
    0150: 70 EF    AND   F,239
    0152: 5D 60    MOV   A,REG[96]
    0154: 21 3F    AND   A,63
    0156: 2A 00    OR    A,[0]
    0158: 60 60    MOV   REG[96],A
    015A: 80 21    JMP   0x017C
    015C: 26 03 BF AND   [3],191
    015F: 08       PUSH  A
    0160: 51 03    MOV   A,[3]
    0162: 71 10    OR    F,16
    0164: 60 62    MOV   REG[98],A
    0166: 70 EF    AND   F,239
    0168: 18       POP   A
    0169: 6B 00    RLC   [0]
    016B: 6B 00    RLC   [0]
    016D: 6B 00    RLC   [0]
    016F: 26 00 30 AND   [0],48
    0172: 70 EF    AND   F,239
    0174: 5D 60    MOV   A,REG[96]
    0176: 21 CF    AND   A,207
    0178: 2A 00    OR    A,[0]
    017A: 60 60    MOV   REG[96],A
    017C: 5D 7A    MOV   A,REG[122]
    017E: 21 E1    AND   A,225
    0180: 29 21    OR    A,33
    0182: 60 7A    MOV   REG[122],A
    0184: 51 0D    MOV   A,[13]
    0186: 97 CF    CALL  _SingleEnded_SetGain
    0188: 50 02    MOV   A,2
    018A: 97 BD    CALL  _SingleEnded_SetPower
    018C: 7C 0B 22 LCALL Invert_Stop
    018F: 7C 0B 58 LCALL DoubleEnded_Stop
    0192: 70 EF    AND   F,239
    0194: 41 89 1F AND   REG[137],31
    0197: 70 FB    AND   F,251
    0199: 7F       RET   
    019A: 21 07    AND   A,7
    019C: 53 00    MOV   [0],A
    019E: 6D       RRC   A
    019F: C0 45    JC    0x01E5
    01A1: 51 00    MOV   A,[0]
    01A3: FF 64    INDEX 0x0109
    01A5: 53 01    MOV   [1],A
    01A7: 71 10    OR    F,16
    01A9: 51 04    MOV   A,[4]
    01AB: 22 01    AND   A,[1]
    01AD: 60 00    MOV   REG[0],A
    01AF: 53 04    MOV   [4],A
    01B1: 51 00    MOV   A,[0]
    01B3: FF 4C    INDEX __text_start
    01B5: 53 01    MOV   [1],A
    01B7: 51 07    MOV   A,[7]
    01B9: 2A 01    OR    A,[1]
    01BB: 60 01    MOV   REG[1],A
    01BD: 53 07    MOV   [7],A
    01BF: 2E 03 40 OR    [3],64
    01C2: 08       PUSH  A
    01C3: 51 03    MOV   A,[3]
    01C5: 71 10    OR    F,16
    01C7: 60 62    MOV   REG[98],A
    01C9: 70 EF    AND   F,239
    01CB: 18       POP   A
    01CC: 6B 00    RLC   [0]
    01CE: 6B 00    RLC   [0]
    01D0: 6B 00    RLC   [0]
    01D2: 6B 00    RLC   [0]
    01D4: 6B 00    RLC   [0]
    01D6: 26 00 C0 AND   [0],192
    01D9: 70 EF    AND   F,239
    01DB: 5D 60    MOV   A,REG[96]
    01DD: 21 3F    AND   A,63
    01DF: 2A 00    OR    A,[0]
    01E1: 60 60    MOV   REG[96],A
    01E3: 80 21    JMP   0x0205
    01E5: 26 03 BF AND   [3],191
    01E8: 08       PUSH  A
    01E9: 51 03    MOV   A,[3]
    01EB: 71 10    OR    F,16
    01ED: 60 62    MOV   REG[98],A
    01EF: 70 EF    AND   F,239
    01F1: 18       POP   A
    01F2: 6B 00    RLC   [0]
    01F4: 6B 00    RLC   [0]
    01F6: 6B 00    RLC   [0]
    01F8: 26 00 30 AND   [0],48
    01FB: 70 EF    AND   F,239
    01FD: 5D 60    MOV   A,REG[96]
    01FF: 21 CF    AND   A,207
    0201: 2A 00    OR    A,[0]
    0203: 60 60    MOV   REG[96],A
    0205: 5D 7A    MOV   A,REG[122]
    0207: 21 C1    AND   A,193
    0209: 29 21    OR    A,33
    020B: 60 7A    MOV   REG[122],A
    020D: 51 0D    MOV   A,[13]
    020F: 97 46    CALL  _SingleEnded_SetGain
    0211: 50 02    MOV   A,2
    0213: 97 34    CALL  _SingleEnded_SetPower
    0215: 50 02    MOV   A,2
    0217: 7C 0B 06 LCALL Invert_Start
    021A: 50 70    MOV   A,112
    021C: 7C 0B 14 LCALL _Invert_SetGain
    021F: 7C 0B 58 LCALL DoubleEnded_Stop
    0222: 70 EF    AND   F,239
    0224: 41 89 9F AND   REG[137],159
    0227: 43 89 80 OR    REG[137],128
    022A: 70 FB    AND   F,251
    022C: 7F       RET   
    022D: 53 00    MOV   [0],A
    022F: 21 07    AND   A,7
    0231: FE D6    INDEX 0x0109
    0233: 53 01    MOV   [1],A
    0235: 71 10    OR    F,16
    0237: 51 04    MOV   A,[4]
    0239: 22 01    AND   A,[1]
    023B: 60 00    MOV   REG[0],A
    023D: 53 04    MOV   [4],A
    023F: 51 00    MOV   A,[0]
    0241: 21 07    AND   A,7
    0243: FE BC    INDEX __text_start
    0245: 53 01    MOV   [1],A
    0247: 51 07    MOV   A,[7]
    0249: 2A 01    OR    A,[1]
    024B: 60 01    MOV   REG[1],A
    024D: 53 07    MOV   [7],A
    024F: 53 00    MOV   [0],A
    0251: 6D       RRC   A
    0252: 6D       RRC   A
    0253: 6D       RRC   A
    0254: 6D       RRC   A
    0255: 21 07    AND   A,7
    0257: FE B0    INDEX 0x0109
    0259: 53 01    MOV   [1],A
    025B: 71 10    OR    F,16
    025D: 51 04    MOV   A,[4]
    025F: 22 01    AND   A,[1]
    0261: 60 00    MOV   REG[0],A
    0263: 53 04    MOV   [4],A
    0265: 51 00    MOV   A,[0]
    0267: 6D       RRC   A
    0268: 6D       RRC   A
    0269: 6D       RRC   A
    026A: 6D       RRC   A
    026B: 21 07    AND   A,7
    026D: FE 92    INDEX __text_start
    026F: 53 01    MOV   [1],A
    0271: 51 07    MOV   A,[7]
    0273: 2A 01    OR    A,[1]
    0275: 60 01    MOV   REG[1],A
    0277: 53 07    MOV   [7],A
    0279: 47 00 01 TST   [0],1
    027C: B0 20    JNZ   0x029D
    027E: 47 00 10 TST   [0],16
    0281: A0 23    JZ    0x02A5
    0283: 2E 01 01 OR    [1],1
    0286: 51 00    MOV   A,[0]
    0288: 6B 00    RLC   [0]
    028A: 6B 00    RLC   [0]
    028C: 6B 00    RLC   [0]
    028E: 6B 00    RLC   [0]
    0290: 26 00 F0 AND   [0],240
    0293: 6D       RRC   A
    0294: 6D       RRC   A
    0295: 6D       RRC   A
    0296: 6D       RRC   A
    0297: 21 0F    AND   A,15
    0299: 2C 00    OR    [0],A
    029B: 80 0C    JMP   0x02A8
    029D: 26 01 FE AND   [1],254
    02A0: 47 00 10 TST   [0],16
    02A3: A0 04    JZ    0x02A8
    02A5: 71 04    OR    F,4
    02A7: 7F       RET   
    02A8: 70 EF    AND   F,239
    02AA: 5D 60    MOV   A,REG[96]
    02AC: 21 FC    AND   A,252
    02AE: 47 00 02 TST   [0],2
    02B1: A0 03    JZ    0x02B5
    02B3: 29 01    OR    A,1
    02B5: 47 00 04 TST   [0],4
    02B8: A0 03    JZ    0x02BC
    02BA: 29 02    OR    A,2
    02BC: 21 F3    AND   A,243
    02BE: 47 00 20 TST   [0],32
    02C1: A0 03    JZ    0x02C5
    02C3: 29 04    OR    A,4
    02C5: 47 00 40 TST   [0],64
    02C8: A0 03    JZ    0x02CC
    02CA: 29 08    OR    A,8
    02CC: 60 60    MOV   REG[96],A
    02CE: 50 02    MOV   A,2
    02D0: 7C 0B 26 LCALL _DoubleEnded_Start
    02D3: 50 70    MOV   A,112
    02D5: 7C 0B 3C LCALL _DoubleEnded_SetGain
    02D8: 70 EF    AND   F,239
    02DA: 41 7A E0 AND   REG[122],224
    02DD: 43 7A 20 OR    REG[122],32
    02E0: 51 0D    MOV   A,[13]
    02E2: 96 73    CALL  _SingleEnded_SetGain
    02E4: 50 02    MOV   A,2
    02E6: 96 61    CALL  _SingleEnded_SetPower
    02E8: 47 01 01 TST   [1],1
    02EB: B0 0B    JNZ   0x02F7
    02ED: 70 EF    AND   F,239
    02EF: 41 89 1F AND   REG[137],31
    02F2: 7C 0B 22 LCALL Invert_Stop
    02F5: 80 12    JMP   0x0308
    02F7: 70 EF    AND   F,239
    02F9: 43 89 80 OR    REG[137],128
    02FC: 41 89 9F AND   REG[137],159
    02FF: 50 02    MOV   A,2
    0301: 7C 0B 14 LCALL _Invert_SetGain
    0304: 50 70    MOV   A,112
    0306: 97 FE    CALL  Invert_Start
    0308: 70 FB    AND   F,251
    030A: 7F       RET   
    030B: 55 0C 01 MOV   [12],1
    030E: 55 11 19 MOV   [17],25
    0311: 96 5B    CALL  _SampleCLK_DisableInt
    0313: 7C 0D 2A LCALL _ADC_Stop
    0316: 7C 0B 22 LCALL Invert_Stop
    0319: 96 4A    CALL  SingleEnded_Stop
    031B: 7C 0B 58 LCALL DoubleEnded_Stop
    031E: 7F       RET   
    031F: 3C 0C 00 CMP   [12],0
    0322: A0 0D    JZ    0x0330
    0324: 51 11    MOV   A,[17]
    0326: 39 03    CMP   A,3
    0328: C0 07    JC    0x0330
    032A: 51 11    MOV   A,[17]
    032C: 39 B8    CMP   A,184
    032E: C0 04    JC    0x0333
    0330: 71 04    OR    F,4
    0332: 7F       RET   
    0333: 96 4F    CALL  _SampleCLK_WritePeriod
    0335: 51 11    MOV   A,[17]
    0337: 70 FB    AND   F,251
    0339: 6D       RRC   A
    033A: 96 68    CALL  _SampleCLK_WriteCompareValue
    033C: 96 3E    CALL  _SampleCLK_Start
    033E: 50 03    MOV   A,3
    0340: 7C 0D 1A LCALL _ADC_SetPower
    0343: 95 7D    CALL  0x08C2
    0345: 55 0E 00 MOV   [14],0
    0348: 55 0F 00 MOV   [15],0
    034B: 55 10 00 MOV   [16],0
    034E: 51 0C    MOV   A,[12]
    0350: 53 01    MOV   [1],A
    0352: 7C 0D 2E LCALL ADC_GetSamples
    0355: 51 44    MOV   A,[ADC_fIncr]
    0357: AF FD    JZ    0x0355
    0359: 55 44 00 MOV   [ADC_fIncr],0
    035C: 58 42    MOV   X,[ADC_iIncr]
    035E: 51 43    MOV   A,[ADC_iIncr+1]
    0360: 4B       SWAP  A,X
    0361: 01 08    ADD   A,8
    0363: 4B       SWAP  A,X
    0364: 04 0E    ADD   [14],A
    0366: 4B       SWAP  A,X
    0367: 0C 0F    ADC   [15],A
    0369: 0E 10 00 ADC   [16],0
    036C: 7A 01    DEC   [1]
    036E: BF E6    JNZ   0x0355
    0370: 7C 0D 2A LCALL _ADC_Stop
    0373: 3C 0C 01 CMP   [12],1
    0376: A0 3D    JZ    0x03B4
    0378: 55 01 18 MOV   [1],24
    037B: 55 00 00 MOV   [0],0
    037E: 70 FB    AND   F,251
    0380: 6B 0E    RLC   [14]
    0382: 6B 0F    RLC   [15]
    0384: 6B 10    RLC   [16]
    0386: 6B 00    RLC   [0]
    0388: C0 11    JC    0x039A
    038A: 51 00    MOV   A,[0]
    038C: 12 0C    SUB   A,[12]
    038E: C0 17    JC    0x03A6
    0390: 53 00    MOV   [0],A
    0392: 7A 01    DEC   [1]
    0394: A0 19    JZ    0x03AE
    0396: 71 04    OR    F,4
    0398: 8F E7    JMP   0x0380
    039A: 51 0C    MOV   A,[12]
    039C: 14 00    SUB   [0],A
    039E: 7A 01    DEC   [1]
    03A0: A0 0D    JZ    0x03AE
    03A2: 71 04    OR    F,4
    03A4: 8F DB    JMP   0x0380
    03A6: 7A 01    DEC   [1]
    03A8: A0 05    JZ    0x03AE
    03AA: 70 FB    AND   F,251
    03AC: 8F D3    JMP   0x0380
    03AE: 6B 0E    RLC   [14]
    03B0: 6B 0F    RLC   [15]
    03B2: 6B 10    RLC   [16]
    03B4: 16 0F 08 SUB   [15],8
    03B7: 51 0E    MOV   A,[14]
    03B9: 58 0F    MOV   X,[15]
    03BB: 70 FB    AND   F,251
    03BD: 7F       RET   
    03BE: 53 00    MOV   [0],A
    03C0: 6D       RRC   A
    03C1: 6D       RRC   A
    03C2: 6D       RRC   A
    03C3: 21 03    AND   A,3
    03C5: 4B       SWAP  A,X
    03C6: 51 00    MOV   A,[0]
    03C8: 21 07    AND   A,7
    03CA: FD 35    INDEX __text_start
    03CC: 53 01    MOV   [1],A
    03CE: 71 10    OR    F,16
    03D0: 52 04    MOV   A,[X+4]
    03D2: 2A 01    OR    A,[1]
    03D4: 61 00    MOV   REG[X+0],A
    03D6: 54 04    MOV   [X+4],A
    03D8: 51 00    MOV   A,[0]
    03DA: 50 07    MOV   A,7
    03DC: FD 2B    INDEX 0x0109
    03DE: 53 01    MOV   [1],A
    03E0: 52 07    MOV   A,[X+7]
    03E2: 22 01    AND   A,[1]
    03E4: 61 01    MOV   REG[X+1],A
    03E6: 54 07    MOV   [X+7],A
    03E8: 51 00    MOV   A,[0]
    03EA: 70 EF    AND   F,239
    03EC: 7F       RET   
    03ED: 53 00    MOV   [0],A
    03EF: 6D       RRC   A
    03F0: 6D       RRC   A
    03F1: 6D       RRC   A
    03F2: 21 03    AND   A,3
    03F4: 4B       SWAP  A,X
    03F5: 51 00    MOV   A,[0]
    03F7: 21 07    AND   A,7
    03F9: FD 0E    INDEX 0x0109
    03FB: 53 01    MOV   [1],A
    03FD: 71 10    OR    F,16
    03FF: 52 04    MOV   A,[X+4]
    0401: 22 01    AND   A,[1]
    0403: 61 00    MOV   REG[X+0],A
    0405: 54 04    MOV   [X+4],A
    0407: 52 07    MOV   A,[X+7]
    0409: 22 01    AND   A,[1]
    040B: 61 01    MOV   REG[X+1],A
    040D: 54 07    MOV   [X+7],A
    040F: 51 00    MOV   A,[0]
    0411: 70 EF    AND   F,239
    0413: 94 AD    CALL  0x08C2
    0415: 7F       RET   
    0416: 53 00    MOV   [0],A
    0418: 6D       RRC   A
    0419: 6D       RRC   A
    041A: 6D       RRC   A
    041B: 21 03    AND   A,3
    041D: 4B       SWAP  A,X
    041E: 51 00    MOV   A,[0]
    0420: 21 07    AND   A,7
    0422: FC DD    INDEX __text_start
    0424: 53 01    MOV   [1],A
    0426: 71 10    OR    F,16
    0428: 52 04    MOV   A,[X+4]
    042A: 2A 01    OR    A,[1]
    042C: 61 00    MOV   REG[X+0],A
    042E: 54 04    MOV   [X+4],A
    0430: 52 07    MOV   A,[X+7]
    0432: 2A 01    OR    A,[1]
    0434: 61 01    MOV   REG[X+1],A
    0436: 54 07    MOV   [X+7],A
    0438: 51 00    MOV   A,[0]
    043A: 70 EF    AND   F,239
    043C: 94 84    CALL  0x08C2
    043E: 7F       RET   
    043F: 53 00    MOV   [0],A
    0441: 6D       RRC   A
    0442: 6D       RRC   A
    0443: 6D       RRC   A
    0444: 21 03    AND   A,3
    0446: 4B       SWAP  A,X
    0447: 51 00    MOV   A,[0]
    0449: 21 07    AND   A,7
    044B: FC BC    INDEX 0x0109
    044D: 53 01    MOV   [1],A
    044F: 71 10    OR    F,16
    0451: 52 04    MOV   A,[X+4]
    0453: 22 01    AND   A,[1]
    0455: 61 00    MOV   REG[X+0],A
    0457: 54 04    MOV   [X+4],A
    0459: 51 00    MOV   A,[0]
    045B: 50 07    MOV   A,7
    045D: FC A2    INDEX __text_start
    045F: 53 01    MOV   [1],A
    0461: 52 07    MOV   A,[X+7]
    0463: 2A 01    OR    A,[1]
    0465: 61 01    MOV   REG[X+1],A
    0467: 54 07    MOV   [X+7],A
    0469: 51 00    MOV   A,[0]
    046B: 70 EF    AND   F,239
    046D: 94 53    CALL  0x08C2
    046F: 7F       RET   
    0470: 21 07    AND   A,7
    0472: FC 8D    INDEX __text_start
    0474: 53 01    MOV   [1],A
    0476: 70 EF    AND   F,239
    0478: 61 00    MOV   REG[X+0],A
    047A: 2A 01    OR    A,[1]
    047C: 5E 00    MOV   A,REG[X+0]
    047E: 7F       RET   
    047F: 21 07    AND   A,7
    0481: FC 86    INDEX 0x0109
    0483: 53 01    MOV   [1],A
    0485: 70 EF    AND   F,239
    0487: 61 00    MOV   REG[X+0],A
    0489: 22 01    AND   A,[1]
    048B: 5E 00    MOV   A,REG[X+0]
    048D: 7F       RET   
    048E: 21 07    AND   A,7
    0490: FC 6F    INDEX __text_start
    0492: 53 01    MOV   [1],A
    0494: 70 EF    AND   F,239
    0496: 5E 00    MOV   A,REG[X+0]
    0498: 22 01    AND   A,[1]
    049A: 7F       RET   
    049B: 55 03 00 MOV   [3],0
    049E: 08       PUSH  A
    049F: 51 03    MOV   A,[3]
    04A1: 71 10    OR    F,16
    04A3: 60 62    MOV   REG[98],A
    04A5: 70 EF    AND   F,239
    04A7: 18       POP   A
    04A8: 90 3C    CALL  0x04E6
    04AA: 90 84    CALL  0x0530
    04AC: 90 CC    CALL  0x057A
    04AE: 91 14    CALL  0x05C4
    04B0: 7F       RET   
    04B1: 11 02    SUB   A,2
    04B3: 70 FB    AND   F,251
    04B5: 6A       RLC   A
    04B6: E0 01    JACC  0x04B8
    04B8: 81 0B    JMP   0x05C4
    04BA: 80 2B    JMP   0x04E6
    04BC: 80 BD    JMP   0x057A
    04BE: 80 71    JMP   0x0530
    04C0: 71 10    OR    F,16
    04C2: 2E 07 08 OR    [7],8
    04C5: 26 04 F7 AND   [4],247
    04C8: 08       PUSH  A
    04C9: 51 04    MOV   A,[4]
    04CB: 60 00    MOV   REG[0],A
    04CD: 51 07    MOV   A,[7]
    04CF: 60 01    MOV   REG[1],A
    04D1: 18       POP   A
    04D2: 70 EF    AND   F,239
    04D4: 50 02    MOV   A,2
    04D6: 97 01    CALL  _DAC_P03_SetPower
    04D8: 2E 03 08 OR    [3],8
    04DB: 08       PUSH  A
    04DC: 51 03    MOV   A,[3]
    04DE: 71 10    OR    F,16
    04E0: 60 62    MOV   REG[98],A
    04E2: 70 EF    AND   F,239
    04E4: 18       POP   A
    04E5: 7F       RET   
    04E6: 71 10    OR    F,16
    04E8: 26 07 F7 AND   [7],247
    04EB: 26 04 F7 AND   [4],247
    04EE: 08       PUSH  A
    04EF: 51 04    MOV   A,[4]
    04F1: 60 00    MOV   REG[0],A
    04F3: 51 07    MOV   A,[7]
    04F5: 60 01    MOV   REG[1],A
    04F7: 18       POP   A
    04F8: 70 EF    AND   F,239
    04FA: 26 03 F7 AND   [3],247
    04FD: 08       PUSH  A
    04FE: 51 03    MOV   A,[3]
    0500: 71 10    OR    F,16
    0502: 60 62    MOV   REG[98],A
    0504: 70 EF    AND   F,239
    0506: 18       POP   A
    0507: 97 09    CALL  _DAC_P03_Stop
    0509: 7F       RET   
    050A: 71 10    OR    F,16
    050C: 2E 07 20 OR    [7],32
    050F: 26 04 DF AND   [4],223
    0512: 08       PUSH  A
    0513: 51 04    MOV   A,[4]
    0515: 60 00    MOV   REG[0],A
    0517: 51 07    MOV   A,[7]
    0519: 60 01    MOV   REG[1],A
    051B: 18       POP   A
    051C: 70 EF    AND   F,239
    051E: 50 02    MOV   A,2
    0520: 96 3D    CALL  DAC_P05_Start
    0522: 2E 03 20 OR    [3],32
    0525: 08       PUSH  A
    0526: 51 03    MOV   A,[3]
    0528: 71 10    OR    F,16
    052A: 60 62    MOV   REG[98],A
    052C: 70 EF    AND   F,239
    052E: 18       POP   A
    052F: 7F       RET   
    0530: 71 10    OR    F,16
    0532: 26 07 DF AND   [7],223
    0535: 26 04 DF AND   [4],223
    0538: 08       PUSH  A
    0539: 51 04    MOV   A,[4]
    053B: 60 00    MOV   REG[0],A
    053D: 51 07    MOV   A,[7]
    053F: 60 01    MOV   REG[1],A
    0541: 18       POP   A
    0542: 70 EF    AND   F,239
    0544: 26 03 DF AND   [3],223
    0547: 08       PUSH  A
    0548: 51 03    MOV   A,[3]
    054A: 71 10    OR    F,16
    054C: 60 62    MOV   REG[98],A
    054E: 70 EF    AND   F,239
    0550: 18       POP   A
    0551: 96 45    CALL  DAC_P05_Stop
    0553: 7F       RET   
    0554: 71 10    OR    F,16
    0556: 2E 07 10 OR    [7],16
    0559: 26 04 EF AND   [4],239
    055C: 08       PUSH  A
    055D: 51 04    MOV   A,[4]
    055F: 60 00    MOV   REG[0],A
    0561: 51 07    MOV   A,[7]
    0563: 60 01    MOV   REG[1],A
    0565: 18       POP   A
    0566: 70 EF    AND   F,239
    0568: 50 02    MOV   A,2
    056A: 96 30    CALL  DAC_P04_Start
    056C: 2E 03 10 OR    [3],16
    056F: 08       PUSH  A
    0570: 51 03    MOV   A,[3]
    0572: 71 10    OR    F,16
    0574: 60 62    MOV   REG[98],A
    0576: 70 EF    AND   F,239
    0578: 18       POP   A
    0579: 7F       RET   
    057A: 71 10    OR    F,16
    057C: 26 07 EF AND   [7],239
    057F: 26 04 EF AND   [4],239
    0582: 08       PUSH  A
    0583: 51 04    MOV   A,[4]
    0585: 60 00    MOV   REG[0],A
    0587: 51 07    MOV   A,[7]
    0589: 60 01    MOV   REG[1],A
    058B: 18       POP   A
    058C: 70 EF    AND   F,239
    058E: 26 03 EF AND   [3],239
    0591: 08       PUSH  A
    0592: 51 03    MOV   A,[3]
    0594: 71 10    OR    F,16
    0596: 60 62    MOV   REG[98],A
    0598: 70 EF    AND   F,239
    059A: 18       POP   A
    059B: 96 38    CALL  DAC_P04_Stop
    059D: 7F       RET   
    059E: 71 10    OR    F,16
    05A0: 2E 07 04 OR    [7],4
    05A3: 26 04 FB AND   [4],251
    05A6: 08       PUSH  A
    05A7: 51 04    MOV   A,[4]
    05A9: 60 00    MOV   REG[0],A
    05AB: 51 07    MOV   A,[7]
    05AD: 60 01    MOV   REG[1],A
    05AF: 18       POP   A
    05B0: 70 EF    AND   F,239
    05B2: 50 02    MOV   A,2
    05B4: 96 60    CALL  _DAC_P02_Start
    05B6: 2E 03 04 OR    [3],4
    05B9: 08       PUSH  A
    05BA: 51 03    MOV   A,[3]
    05BC: 71 10    OR    F,16
    05BE: 60 62    MOV   REG[98],A
    05C0: 70 EF    AND   F,239
    05C2: 18       POP   A
    05C3: 7F       RET   
    05C4: 71 10    OR    F,16
    05C6: 26 07 FB AND   [7],251
    05C9: 26 04 FB AND   [4],251
    05CC: 08       PUSH  A
    05CD: 51 04    MOV   A,[4]
    05CF: 60 00    MOV   REG[0],A
    05D1: 51 07    MOV   A,[7]
    05D3: 60 01    MOV   REG[1],A
    05D5: 18       POP   A
    05D6: 70 EF    AND   F,239
    05D8: 26 03 FB AND   [3],251
    05DB: 08       PUSH  A
    05DC: 51 03    MOV   A,[3]
    05DE: 71 10    OR    F,16
    05E0: 60 62    MOV   REG[98],A
    05E2: 70 EF    AND   F,239
    05E4: 18       POP   A
    05E5: 96 68    CALL  DAC_P02_Stop
    05E7: 7F       RET   
_main:
    05E8: 90 12    CALL  0x05FC
    05EA: 9E AF    CALL  0x049B
    05EC: 9D 1D    CALL  0x030B
    05EE: 71 01    OR    F,1
    05F0: 92 D0    CALL  0x08C2
    05F2: 90 C9    CALL  0x06BD
    05F4: 90 DB    CALL  0x06D1
    05F6: AF FD    JZ    0x05F4
    05F8: 90 FB    CALL  0x06F5
    05FA: 8F F9    JMP   0x05F4
FILE: E:\CONTES~1\ENTRY201\MAIN.ASM
(0001) 
(0002) ;
(0003) ;Circuit Cellar Cypress PSOC Design Contest
(0004) ;Contest Entry 201
(0005) ;
(0006) ;Title:				Reconfigurable Test System
(0007) ;Version:			21/5/02
(0008) ;Description:		This is the main code for reconfiguring and
(0009) ;					operating the PSOC as a cascadable test POD
(0010) ;					
(0011) 
(0012) export _main
(0013) 
(0014) include "m8c.inc"					;include m8c specific declarations 
(0015) 
(0016) ;
(0017) ;Some useful macro definitions
(0018) ;
(0019) 
(0020) 
(0021) ;
(0022) ;load effective address of operand into A:X
(0023) ;
(0024) macro	lea
(0025) 		mov		a,#>@0
(0026) 		mov		x,#<@0
(0027) endm
(0028) 
(0029) ;
(0030) ;and/or ABF_CR register bits (write only register)
(0031) ;
(0032) macro	loadabf
(0033) 		push	a
(0034) 		mov		a,[ABF_TMP]
(0035) 		M8C_SetBank1
(0036) 		mov		reg[ABF_CR],a
(0037) 		M8C_SetBank0
(0038) 		pop		a
(0039) 		endm
(0040) 		
(0041) macro	andabf
(0042) 		and		[ABF_TMP],#@0
(0043) 		loadabf
(0044) endm
(0045) 
(0046) macro	orabf
(0047) 		or		[ABF_TMP],#@0
(0048) 		loadabf
(0049) endm
(0050) 	
(0051) macro	loadddr0
(0052) 		push	a
(0053) 		mov		a,[PRTDM0_T+0]
(0054) 		mov		reg[PRT0DM0],a
(0055) 		mov		a,[PRTDM1_T+0]
(0056) 		mov		reg[PRT0DM1],a
(0057) 		pop		a
(0058) endm
(0059) 	
(0060) macro	loadddr1
(0061) 		push	a
(0062) 		mov		a,[PRTDM0_T+1]
(0063) 		mov		reg[PRT1DM0],a
(0064) 		mov		a,[PRTDM1_T+1]
(0065) 		mov		reg[PRT1DM1],a
(0066) 		pop		a
(0067) endm
(0068) 	
(0069) macro	loadddr2
(0070) 		push	a
(0071) 		mov		a,[PRTDM0_T+2]
(0072) 		mov		reg[PRT2DM0],a
(0073) 		mov		a,[PRTDM1_T+2]
(0074) 		mov		reg[PRT2DM1],a
(0075) 		pop		a
(0076) endm
(0077) 	
(0078) ;
(0079) ;Carry set/clear
(0080) ;
(0081) macro	clc
(0082) 		and		F,#~4
(0083) endm
(0084) 
(0085) macro	sec
(0086) 		or		F,#4
(0087) endm		
(0088) 
(0089) ;
(0090) ;Echo a character upstream
(0091) ;
(0092) macro	echo
(0093) 		push	a
(0094) 		mov		a,#@0
(0095) 		call	TxIN
(0096) 		pop		a
(0097) endm
(0098) 
(0099) MAXLINE:		equ		16				;number of characters in a line
(0100) 
(0101) ;
(0102) ;Register memory usage
(0103) ;		
(0104) area bss(RAM)
(0105) 	TMP:		blk	1					;working register
(0106) 	TMP2:		blk 1					;working mask register
(0107) 	TMP3:		blk	1					;working index register
(0108) 	ABF_TMP:	blk 1					;stores current state of ABF_CR
(0109) 	PRTDM0_T:	blk 3					;stores current state of PRT0..2DM0
(0110) 	PRTDM1_T:	blk	3					;stores current state of PRT0..2DM1
(0111) 	PORT:		blk 2					;active port(s)
(0112) 	NOSAMPLES:	blk 1					;number of samples to take
(0113) 	GAINK:		blk	1					;gain constant
(0114) 	RESULT:		blk 3					;averaging accumulator
(0115) 	SAMPLECLK:	blk 1					;clock divider for ADC
(0116) 	RX_STATUS:	blk 1					;temp uart rx status
(0117) 	COMMBUF:	blk MAXLINE				;incoming command storage
(0118) 	RAMPADDING:	blk	64-(19+MAXLINE)		;skip RX corruption area
(0119) 
(0120) ;
(0121) ;Code memory
(0122) ;
(0123) area text(ROM,REL)
(0124) 
(0125) 		
(0126) ;
(0127) ;Analog input section
(0128) ;
(0129) include "doubleended.inc"
(0130) include "invert.inc"
(0131) include "singleended.inc"
(0132) include "adc.inc"
(0133) 
(0134) ;
(0135) ;Convert bit number to bit mask
(0136) ;
(0137) MASK1LUT:
(0138) 		db		1,2,4,8,16,32,64,128			;OR operation
(0139) MASK0LUT:
(0140) 		db		~1,~2,~4,~8,~16,~32,~64,~128	;AND operation
(0141) 		
(0142) ;		
(0143) ;Configure ADC for single ended input and initialise
(0144) ;
(0145) ;A=Input select P0[0]..P0[7]
(0146) ;GAINK = gain
(0147) ;
(0148) SingleEndedPort:
(0149) 		and		a,#7
(0150) 		mov		[TMP],a
(0151) 		rrc		a						;check if port is odd or even
(0152) 		jc		OddPort
(0153) EvenPort:
(0154) 		mov		a,[TMP]
(0155) 		index	MASK0LUT
(0156) 		mov		[TMP2],a
(0157) 		M8C_SetBank1
(0158) 		mov		a,[PRTDM0_T+0]
(0159) 		and		a,[TMP2]
(0160) 		mov		reg[PRT0DM0],a			;select high Z on that pin
(0161) 		mov		[PRTDM0_T+0],a			;update local latched value
(0162) 		mov		a,[TMP]
(0163) 		index	MASK1LUT
(0164) 		mov		[TMP2],a
(0165) 		mov		a,[PRTDM1_T+0]
(0166) 		or		a,[TMP2]
(0167) 		mov		reg[PRT0DM1],a
(0168) 		mov		[PRTDM1_T+0],a
(0169) 
(0170) 		orabf	40h						;select mux 3 (even ports)
(0171) 		rlc		[TMP]
(0172) 		rlc		[TMP]
(0173) 		rlc		[TMP]
(0174) 		rlc		[TMP]
(0175) 		rlc		[TMP]
(0176) 		and		[TMP],#128+64
(0177) 		M8C_SetBank0
(0178) 		mov		a,reg[AMX_IN]
(0179) 		and		a,#~(128+64)
(0180) 		or		a,[TMP]
(0181) 		mov		reg[AMX_IN],a				;select even port
(0182) 		jmp		DonePort				
(0183) OddPort:
(0184) 		andabf	~40h						;select mux 2 (odd ports)
(0185) 		rlc		[TMP]
(0186) 		rlc		[TMP]
(0187) 		rlc		[TMP]
(0188) 		and		[TMP],#32+16
(0189) 		M8C_SetBank0
(0190) 		mov		a,reg[AMX_IN]				;select odd port
(0191) 		and		a,#~(32+16)
(0192) 		or		a,[TMP]
(0193) 		mov		reg[AMX_IN],a
(0194) DonePort:
(0195) 		
(0196) 		mov		a,reg[ACA02CR1]
(0197) 		and		a,#~(2+4+16+8)
(0198) 		or		a,#1+32						;select column input wrt ACA02
(0199) 		mov		reg[ACA02CR1],a
(0200) 		
(0201) 		mov		a,[GAINK]
(0202) 		call	SingleEnded_SetGain			;user selected gain
(0203) 		mov		a,#SingleEnded_MEDPOWER
(0204) 		call	SingleEnded_Start		
(0205) 		
(0206) 		lcall	Invert_Stop					;shut down inverting amp
(0207) 		lcall	DoubleEnded_Stop			;shut down balanced amp
(0208) 			
(0209) 		M8C_SetBank0				
(0210) 		and		reg[ASA12CR1],#~(128+64+32)	;select ASA12 input for ACA02
(0211) 																		
(0212) 		
(0213) 		clc
(0214) 		ret
(0215) 
(0216) ;		
(0217) ;Configure ADC for single ended inverted input and initialise
(0218) ;
(0219) ;A=Input select P0[0]..P0[7]
(0220) ;GAINK = gain
(0221) ;
(0222) SingleEndedInvPort:
(0223) 		and		a,#7
(0224) 		mov		[TMP],a
(0225) 		rrc		a						;check if port is odd or even
(0226) 		jc		OddPort2
(0227) EvenPort2:
(0228) 		mov		a,[TMP]
(0229) 		index	MASK0LUT
(0230) 		mov		[TMP2],a
(0231) 		M8C_SetBank1
(0232) 		mov		a,[PRTDM0_T+0]
(0233) 		and		a,[TMP2]
(0234) 		mov		reg[PRT0DM0],a			;select high Z on that pin
(0235) 		mov		[PRTDM0_T+0],a
(0236) 		mov		a,[TMP]
(0237) 		index	MASK1LUT
(0238) 		mov		[TMP2],a
(0239) 		mov		a,[PRTDM1_T+0]
(0240) 		or		a,[TMP2]
(0241) 		mov		reg[PRT0DM1],a
(0242) 		mov		[PRTDM1_T+0],a
(0243) 
(0244) 		orabf	40h				;select mux 3 (even ports)
(0245) 		rlc		[TMP]
(0246) 		rlc		[TMP]
(0247) 		rlc		[TMP]
(0248) 		rlc		[TMP]
(0249) 		rlc		[TMP]
(0250) 		and		[TMP],#128+64
(0251) 		M8C_SetBank0
(0252) 		mov		a,reg[AMX_IN]
(0253) 		and		a,#~(128+64)
(0254) 		or		a,[TMP]
(0255) 		mov		reg[AMX_IN],a				;select even port
(0256) 		jmp		DonePort2
(0257) OddPort2:
(0258) 		andabf	~40h						;select mux 2 (odd ports)
(0259) 		rlc		[TMP]
(0260) 		rlc		[TMP]
(0261) 		rlc		[TMP]
(0262) 		and		[TMP],#32+16
(0263) 		M8C_SetBank0
(0264) 		mov		a,reg[AMX_IN]				;select odd port
(0265) 		and		a,#~(32+16)
(0266) 		or		a,[TMP]
(0267) 		mov		reg[AMX_IN],a
(0268) DonePort2:
(0269) 		
(0270) 		mov		a,reg[ACA02CR1]
(0271) 		and		a,#~(2+4+16+32+8)
(0272) 		or		a,#1+32						;select column input
(0273) 		mov		reg[ACA02CR1],a
(0274) 		
(0275) 		mov		a,[GAINK]
(0276) 		call	SingleEnded_SetGain			;user selected gain
(0277) 		mov		a,#SingleEnded_MEDPOWER
(0278) 		call	SingleEnded_Start		
(0279) 		
(0280) 		mov		a,#Invert_MEDPOWER
(0281) 		lcall	Invert_Start				;start inverting amp
(0282) 		mov		a,#Invert_G1_00				;gain = -1.0
(0283) 		lcall	Invert_SetGain
(0284) 		lcall	DoubleEnded_Stop			;shut down balanced amp
(0285) 			
(0286) 		M8C_SetBank0				
(0287) 		and		reg[ASA12CR1],#~(64+32)		;select ASA12 input for ACA03
(0288) 		or		reg[ASA12CR1],#128
(0289) 															
(0290) 		
(0291) 		clc
(0292) 		ret
(0293) ;
(0294) ;Configure ADC for double ended input and initialise
(0295) ;		
(0296) ;A.MSN	= V+ input P0[0]..P0[7]
(0297) ;A.LSN  = V- input P0[0]..P0[7]
(0298) ;GAINK  = Gain
(0299) ;
(0300) ;Carry is clear if configuration is possible
(0301) ;
(0302) DoubleEndedPort:
(0303) 		
(0304) 		mov		[TMP],a
(0305) 		
(0306) 		and		a,#7
(0307) 		index	MASK0LUT
(0308) 		mov		[TMP2],a
(0309) 		M8C_SetBank1
(0310) 		mov		a,[PRTDM0_T+0]
(0311) 		and		a,[TMP2]
(0312) 		mov		reg[PRT0DM0],a			;select high Z on that V- input
(0313) 		mov		[PRTDM0_T+0],a
(0314) 		mov		a,[TMP]
(0315) 		and		a,#7
(0316) 		index	MASK1LUT
(0317) 		mov		[TMP2],a
(0318) 		mov		a,[PRTDM1_T+0]
(0319) 		or		a,[TMP2]
(0320) 		mov		reg[PRT0DM1],a
(0321) 		mov		[PRTDM1_T+0],a
(0322) 		
(0323) 		mov		[TMP],a
(0324) 		rrc		a
(0325) 		rrc		a
(0326) 		rrc		a
(0327) 		rrc		a
(0328) 		and		a,#7
(0329) 		index	MASK0LUT
(0330) 		mov		[TMP2],a
(0331) 		M8C_SetBank1
(0332) 		mov		a,[PRTDM0_T+0]
(0333) 		and		a,[TMP2]
(0334) 		mov		reg[PRT0DM0],a			;select high Z on that V+ input
(0335) 		mov		[PRTDM0_T+0],a
(0336) 		mov		a,[TMP]
(0337) 		rrc		a
(0338) 		rrc		a
(0339) 		rrc		a
(0340) 		rrc		a
(0341) 		and		a,#7
(0342) 		index	MASK1LUT
(0343) 		mov		[TMP2],a
(0344) 		mov		a,[PRTDM1_T+0]
(0345) 		or		a,[TMP2]
(0346) 		mov		reg[PRT0DM1],a
(0347) 		mov		[PRTDM1_T+0],a
(0348) 			
(0349) 		tst		[TMP],#1			;check if V+ and V- are even/odd or odd/even
(0350) 		jnz		NegIsOdd
(0351) NegIsEven:		
(0352) 
(0353) 		tst		[TMP],#16
(0354) 		jz		InvalidConfig
(0355) 
(0356) 		or		[TMP2],#1			;use invert
(0357) 
(0358) 		mov		a,[TMP]
(0359) 		rlc		[TMP]	
(0360) 		rlc		[TMP]	
(0361) 		rlc		[TMP]	
(0362) 		rlc		[TMP]	
(0363) 		and		[TMP],#240
(0364) 		rrc		a
(0365) 		rrc		a
(0366) 		rrc		a
(0367) 		rrc		a
(0368) 		and		a,#15
(0369) 		or		[TMP],a				;swap nibbles
(0370) 		jmp		ValidConfig
(0371) 						
(0372) NegIsOdd:
(0373) 
(0374) 		and		[TMP2],#~1			;don't use invert
(0375) 		tst		[TMP],#16
(0376) 		jz		ValidConfig
(0377) InvalidConfig:
(0378) 		sec
(0379) 		ret							;both odd.. error!
(0380) 
(0381) ValidConfig:
(0382) 		M8C_SetBank0
(0383) 		mov		a,reg[AMX_IN]	
(0384) 		and		a,#~(1+2)			;mask column 0 (V-) mux select
(0385) 		tst		[TMP],#2
(0386) 		jz		NoSet0
(0387) 		or		a,#1
(0388) NoSet0:
(0389) 		tst		[TMP],#4
(0390) 		jz		NoSet1
(0391) 		or		a,#2
(0392) NoSet1:
(0393) 		and		a,#~(4+8)			;mask column 1 (V+) mux select
(0394) 		tst		[TMP],#32
(0395) 		jz		NoSet2
(0396) 		or		a,#4
(0397) NoSet2:
(0398) 		tst		[TMP],#64
(0399) 		jz		NoSet3
(0400) 		or		a,#8
(0401) NoSet3:
(0402) 		mov		reg[AMX_IN],a
(0403) 		
(0404) 		mov		a,#DoubleEnded_MEDPOWER		;power up differential amp
(0405) 		lcall	DoubleEnded_Start
(0406) 		mov		a,#DoubleEnded_G2_00		;nominal gain of 2.0
(0407) 		lcall	DoubleEnded_SetGain
(0408) 		
(0409) 		M8C_SetBank0
(0410) 		and		reg[ACA02CR1],#~(1+2+4+16+8)		;select ACA02 input to ACA01/AGND
(0411) 		or		reg[ACA02CR1],#32
(0412) 		
(0413) 		mov		a,[GAINK]
(0414) 		call	SingleEnded_SetGain			;user selected gain
(0415) 		mov		a,#SingleEnded_MEDPOWER
(0416) 		call	SingleEnded_Start			;power up cascade opamp
(0417) 
(0418) 		tst		[TMP2],#1					;invert enabled?
(0419) 		jnz		InvertOn					;yes, turn it on
(0420) 								
(0421) InvertOff:
(0422) 
(0423) 		M8C_SetBank0				
(0424) 		and		reg[ASA12CR1],#~(128+64+32)	;select ASA12 input for ACA02
(0425) 														
(0426) 											
(0427) 		lcall	Invert_Stop					;shut down unused opamp
(0428) 		jmp		InvertDone
(0429) 		
(0430) InvertOn:
(0431) 
(0432) 		M8C_SetBank0					
(0433) 		or		reg[ASA12CR1],#128
(0434) 		and		reg[ASA12CR1],#~(64+32)		;select ASA12 input to ACA03
(0435) 																					
(0436) 					
(0437) 		mov		a,#Invert_MEDPOWER
(0438) 		lcall	Invert_SetGain				;nominal gain of 1.0
(0439) 		mov		a,#Invert_G1_00
(0440) 		call	Invert_Start	
(0441) 
(0442) InvertDone:
(0443) 
(0444) 		clc
(0445) 		ret
(0446) 
(0447) ;
(0448) ;Initialise ADC and sample clock
(0449) ;		
(0450) ;Sample rate = Data clock / (65*256)	must be between 7.8 and 480 
(0451) ;
(0452) InitADC:
(0453) 		mov		[NOSAMPLES],#1
(0454) 		mov		[SAMPLECLK],#25				;57 hz
(0455) 		call	SampleCLK_DisableInt
(0456) 		lcall	ADC_Stop
(0457) 		lcall	Invert_Stop
(0458) 		call	SingleEnded_Stop
(0459) 		lcall	DoubleEnded_Stop
(0460) 		ret
(0461) 		
(0462) ;
(0463) ;Initialise ADC and take some samples, apply averaging filter
(0464) ;		
(0465) ;Sample rate = Data clock / (65*256)	must be between 7.8 and 480 
(0466) ;
(0467) ;Carry is set if sample rate is invalid
(0468) ;
(0469) ;Returns data in X:A
(0470) ;
(0471) RunADC:		
(0472) 		cmp		[NOSAMPLES],#0
(0473) 		jz		ADCInvalid
(0474) 		mov		a,[SAMPLECLK]
(0475) 		cmp		a,#3
(0476) 		jc		ADCInvalid
(0477) 		mov		a,[SAMPLECLK]
(0478) 		cmp		a,#184
(0479) 		jc		ADCOK
(0480) ADCInvalid:
(0481) 		sec
(0482) 		ret
(0483) ADCOK:	
(0484) 
(0485) 		call	SampleCLK_WritePeriod
(0486) 		
(0487) 		mov		a,[SAMPLECLK]
(0488) 		clc
(0489) 		rrc		a							;compare = 50% duty
(0490) 		call	SampleCLK_WriteCompareValue
(0491) 		call	SampleCLK_Start
(0492) 		
(0493) 		mov		a,#ADC_HIGHPOWER
(0494) 		lcall	ADC_Start
(0495) 
(0496) 		call	SettleDelay
(0497) 		
(0498) 		mov		[RESULT],#0
(0499) 		mov		[RESULT+1],#0
(0500) 		mov		[RESULT+2],#0				;reset accumulator
(0501) 		
(0502) 		mov		a,[NOSAMPLES]				;how many samples
(0503) 		mov		[TMP2],a
(0504)   		lcall 	ADC_GetSamples				;start sampler
(0505) 		
(0506) LoopADC:
(0507)         ADC_ISDATA			        ;poll flag
(0508)       	jz 		LoopADC				;wait for ADC
(0509)         ADC_CLEARFLAG		        ;reset flag
(0510)         
(0511)         ADC_GETDATA			        ;get data
(0512)         swap	a,x
(0513)         add		a,8					;convert to unsigned
(0514)         swap	a,x
(0515) 		add		[RESULT],a
(0516) 		swap	a,x
(0517) 		adc		[RESULT+1],a
(0518) 		adc		[RESULT+2],#0
(0519) 		dec		[TMP2]
(0520) 		jnz		LoopADC
(0521) 
(0522) 		lcall	ADC_Stop
(0523) 
(0524) 		cmp		[NOSAMPLES],#1
(0525) 		jz		SkipDiv				;any need to divide?
(0526) 
(0527) ;		
(0528) ;Divide 24-bit result by number of 8-bit number of samples
(0529) ;
(0530) 		mov		[TMP2],#24
(0531) 		mov		[TMP],#0
(0532) 		clc
(0533) DivLoop:
(0534) 		rlc		[RESULT]
(0535) 		rlc		[RESULT+1]
(0536) 		rlc		[RESULT+2]
(0537) 		rlc		[TMP]
(0538) 		jc		DivOver
(0539) 		mov		a,[TMP]
(0540) 		sub		a,[NOSAMPLES]
(0541) 		jc		DivUnder
(0542) 		mov		[TMP],a
(0543) 		dec		[TMP2]
(0544) 		jz		DivDone
(0545) 		sec
(0546) 		jmp		DivLoop
(0547) 		
(0548) DivOver:
(0549) 		mov		a,[NOSAMPLES]
(0550) 		sub		[TMP],a
(0551) 		dec		[TMP2]
(0552) 		jz		DivDone
(0553) 		sec
(0554) 		jmp		DivLoop
(0555) 		
(0556) DivUnder:
(0557) 		dec		[TMP2]
(0558) 		jz		DivDone
(0559) 		clc
(0560) 		jmp		DivLoop
(0561) 
(0562) DivDone:
(0563) 		rlc		[RESULT]
(0564) 		rlc		[RESULT+1]
(0565) 		rlc		[RESULT+2]
(0566) SkipDiv:
(0567) 		sub		[RESULT+1],8
(0568) 		mov		a,[RESULT]
(0569) 		mov		x,[RESULT+1]		
(0570) 		clc		
(0571) 		ret
(0572) 		
(0573) 
(0574) ;
(0575) ;Digital input/output section
(0576) ;
(0577) 
(0578) ;
(0579) ;Set data direction on pin for strong drive
(0580) ;
(0581) ;Inputs:	A=Port / Bit
(0582) ;
(0583) ;Outputs:	X=Port Offset
(0584) ;			A=Port / Bit
(0585) ;
(0586) SetDDROut:
(0587) 		mov		[TMP],a
(0588) 		rrc		a
(0589) 		rrc		a
(0590) 		rrc		a		
(0591) 		and		a,#3				;port number
(0592) 		swap	a,x
(0593) 		mov		a,[TMP]
(0594) 		and		a,#7
(0595) 		index	MASK1LUT			;lookup mask for OR'ing
(0596) 		mov		[TMP2],a
(0597) 		M8C_SetBank1
(0598) 		mov		a,[X+PRTDM0_T]
(0599) 		or		a,[TMP2]
(0600) 		mov		reg[X+PRT0DM0],a
(0601) 		mov		[X+PRTDM0_T],a
(0602) 		mov		a,[TMP]
(0603) 		mov		a,#7
(0604) 		index	MASK0LUT
(0605) 		mov		[TMP2],a
(0606) 		mov		a,[X+PRTDM1_T]
(0607) 		and		a,[TMP2]
(0608) 		mov		reg[X+PRT0DM1],a	;strong drive
(0609) 		mov		[X+PRTDM1_T],a
(0610) 		mov		a,[TMP]
(0611) 		M8C_SetBank0
(0612) 		ret
(0613) 
(0614) ;
(0615) ;Set data direction on pin for pulldown
(0616) ;
(0617) ;Inputs:	A=Port / Bit
(0618) ;
(0619) ;Outputs:	X=Port Offset
(0620) ;			A=Port / Bit
(0621) ;
(0622) SetDDRPulldown:
(0623) 		mov		[TMP],a
(0624) 		rrc		a
(0625) 		rrc		a
(0626) 		rrc		a		
(0627) 		and		a,#3				;port number
(0628) 		swap	a,x
(0629) 		mov		a,[TMP]
(0630) 		and		a,#7
(0631) 		index	MASK0LUT			;lookup mask for AND'ing
(0632) 		mov		[TMP2],a
(0633) 		M8C_SetBank1
(0634) 		mov		a,[X+PRTDM0_T]
(0635) 		and		a,[TMP2]
(0636) 		mov		reg[X+PRT0DM0],a
(0637) 		mov		[X+PRTDM0_T],a
(0638) 		mov		a,[X+PRTDM1_T]
(0639) 		and		a,[TMP2]
(0640) 		mov		reg[X+PRT0DM1],a	;pulldown
(0641) 		mov		[X+PRTDM1_T],a
(0642) 		mov		a,[TMP]
(0643) 		M8C_SetBank0
(0644) 		call	SettleDelay
(0645) 		ret
(0646) 
(0647) ;
(0648) ;Set data direction on pin for pullup
(0649) ;
(0650) ;Inputs:	A=Port / Bit
(0651) ;
(0652) ;Outputs:	X=Port Offset
(0653) ;			A=Port / Bit
(0654) ;
(0655) SetDDRPullup:
(0656) 		mov		[TMP],a
(0657) 		rrc		a
(0658) 		rrc		a
(0659) 		rrc		a		
(0660) 		and		a,#3				;port number
(0661) 		swap	a,x
(0662) 		mov		a,[TMP]
(0663) 		and		a,#7
(0664) 		index	MASK1LUT			;lookup mask for OR'ing
(0665) 		mov		[TMP2],a
(0666) 		M8C_SetBank1
(0667) 		mov		a,[X+PRTDM0_T]
(0668) 		or		a,[TMP2]
(0669) 		mov		reg[X+PRT0DM0],a
(0670) 		mov		[X+PRTDM0_T],a
(0671) 		mov		a,[X+PRTDM1_T]
(0672) 		or		a,[TMP2]
(0673) 		mov		reg[X+PRT0DM1],a	;pullup
(0674) 		mov		[X+PRTDM1_T],a
(0675) 		mov		a,[TMP]
(0676) 		M8C_SetBank0
(0677) 		call	SettleDelay
(0678) 		ret
(0679) 
(0680) ;
(0681) ;Set data direction on pin for high Z input
(0682) ;
(0683) ;Inputs:	A=Port / Bit
(0684) ;
(0685) ;Outputs:	X=Port Offset
(0686) ;			A=Port / Bit
(0687) ;
(0688) SetDDRIn:
(0689) 		mov		[TMP],a
(0690) 		rrc		a
(0691) 		rrc		a
(0692) 		rrc		a		
(0693) 		and		a,#3				;port number
(0694) 		swap	a,x
(0695) 		mov		a,[TMP]
(0696) 		and		a,#7
(0697) 		index	MASK0LUT			;lookup mask
(0698) 		mov		[TMP2],a
(0699) 		M8C_SetBank1
(0700) 		mov		a,[X+PRTDM0_T]
(0701) 		and		a,[TMP2]
(0702) 		mov		reg[X+PRT0DM0],a
(0703) 		mov		[X+PRTDM0_T],a
(0704) 		mov		a,[TMP]
(0705) 		mov		a,#7
(0706) 		index	MASK1LUT
(0707) 		mov		[TMP2],a
(0708) 		mov		a,[X+PRTDM1_T]
(0709) 		or		a,[TMP2]
(0710) 		mov		reg[X+PRT0DM1],a	;high Z
(0711) 		mov		[X+PRTDM1_T],a
(0712) 		mov		a,[TMP]
(0713) 		M8C_SetBank0
(0714) 		call	SettleDelay
(0715) 		ret
(0716) 				
(0717) ;
(0718) ;Drive digital output high
(0719) ;		
(0720) ;A	P0[0]..P2[7]
(0721) ;
(0722) SetDigitalOutput:
(0723) 		and		a,#7
(0724) 		index	MASK1LUT
(0725) 		mov		[TMP2],a			;lookup bit
(0726) 		M8C_SetBank0
(0727) 		mov		reg[X+PRT0DR],a
(0728) 		or		a,[TMP2]
(0729) 		mov		a,reg[X+PRT0DR]		;set bit				
(0730) 		ret		
(0731) 		
(0732) ;
(0733) ;Drive digital output low
(0734) ;		
(0735) ;A	P0[0]..P2[7]
(0736) ;
(0737) ClrDigitalOutput:
(0738) 		and		a,#7
(0739) 		index	MASK0LUT
(0740) 		mov		[TMP2],a			;lookup bit
(0741) 		M8C_SetBank0
(0742) 		mov		reg[X+PRT0DR],a
(0743) 		and		a,[TMP2]
(0744) 		mov		a,reg[X+PRT0DR]		;clear bit				
(0745) 		ret		
(0746) 		
(0747) ;
(0748) ;Read digital input
(0749) ;
(0750) ;A	P0[0]..P2[7]
(0751) ;
(0752) ;Returns result in Z (Z=1 if bit is clear)
(0753) ;
(0754) ReadDigitalInput:
(0755) 		and		a,#7
(0756) 		index	MASK1LUT
(0757) 		mov		[TMP2],a
(0758) 		M8C_SetBank0
(0759) 		mov		a,reg[X+PRT0DR]
(0760) 		and		a,[TMP2]
(0761) 		ret
(0762) ;
(0763) ;Analog output section (DAC6)
(0764) ;
(0765) include "dac_p02.inc"
(0766) include "dac_p03.inc"
(0767) include "dac_p04.inc"
(0768) include "dac_p05.inc"
(0769) 
(0770) ;
(0771) ;Control signal routing for DAC outputs
(0772) ;
(0773) InitDAC:
(0774) 		mov		[ABF_TMP],#0			;turn off all outputs, reset latch
(0775) 		loadabf
(0776) 		
(0777) 		call	DAC_P03_Off
(0778) 		call	DAC_P05_Off
(0779) 		call	DAC_P04_Off
(0780) 		call	DAC_P02_Off
(0781) 		ret
(0782) 
(0783) ;
(0784) ;Turn off DAC indicated by bit in A
(0785) ;		
(0786) DisableDAC:
(0787) 		sub		a,#2
(0788) 		clc
(0789) 		rlc		a
(0790) 		jacc	DisableLUT
(0791) 		
(0792) DisableLUT:
(0793) 		jmp		DAC_P02_Off
(0794) 		jmp		DAC_P03_Off
(0795) 		jmp		DAC_P04_Off
(0796) 		jmp		DAC_P05_Off
(0797) 		
(0798) DAC_P03_On:
(0799) 		M8C_SetBank1
(0800) 		or		[PRTDM1_T+0],8				;high-Z mode for P0[3]
(0801) 		and		[PRTDM0_T+0],~8
(0802) 		loadddr0
(0803) 		M8C_SetBank0
(0804) 		mov		a,#DAC_P03_MEDPOWER
(0805) 		call	DAC_P03_Start
(0806) 
(0807) 		orabf	8							;enable output buffer
(0808) 		ret
(0809) 		
(0810) DAC_P03_Off:
(0811) 		M8C_SetBank1
(0812) 		and		[PRTDM1_T+0],~8				;pulldown mode for P0[3]
(0813) 		and		[PRTDM0_T+0],~8
(0814) 		loadddr0
(0815) 		M8C_SetBank0
(0816) 		andabf	~8							;disable output buffer
(0817) 
(0818) 		call	DAC_P03_Stop
(0819) 		ret
(0820) 		
(0821) DAC_P05_On:
(0822) 		M8C_SetBank1
(0823) 		or		[PRTDM1_T+0],20h			;high-Z mode for P0[5]
(0824) 		and		[PRTDM0_T+0],~20h
(0825) 		loadddr0
(0826) 		M8C_SetBank0
(0827) 		mov		a,#DAC_P05_MEDPOWER
(0828) 		call	DAC_P05_Start
(0829) 
(0830) 		orabf	20h							;enable output buffer 			
(0831) 		ret
(0832) 		
(0833) DAC_P05_Off:
(0834) 		M8C_SetBank1
(0835) 		and		[PRTDM1_T+0],~20h			;pulldown mode for P0[5]
(0836) 		and		[PRTDM0_T+0],~20h
(0837) 		loadddr0
(0838) 		M8C_SetBank0
(0839) 		andabf	~20h						;disable output buffer
(0840) 
(0841) 		call	DAC_P05_Stop
(0842) 		ret
(0843) 		
(0844) DAC_P04_On:
(0845) 		M8C_SetBank1
(0846) 		or		[PRTDM1_T+0],10h			;high-Z mode for P0[4]
(0847) 		and		[PRTDM0_T+0],~10h
(0848) 		loadddr0
(0849) 		M8C_SetBank0
(0850) 		mov		a,#DAC_P04_MEDPOWER
(0851) 		call	DAC_P04_Start
(0852) 
(0853) 		orabf	10h							;enable output buffer 				
(0854) 		ret
(0855) 		
(0856) DAC_P04_Off:
(0857) 		M8C_SetBank1
(0858) 		and		[PRTDM1_T+0],~10h			;pulldown mode for P0[4]
(0859) 		and		[PRTDM0_T+0],~10h
(0860) 		loadddr0
(0861) 		M8C_SetBank0
(0862) 		andabf	~10h						;disable output buffer
(0863) 
(0864) 		call	DAC_P04_Stop
(0865) 		ret
(0866) 		
(0867) DAC_P02_On:
(0868) 		M8C_SetBank1
(0869) 		or		[PRTDM1_T+0],4   			;high-Z mode for P0[2]
(0870) 		and		[PRTDM0_T+0],~4
(0871) 		loadddr0
(0872) 		M8C_SetBank0
(0873) 		mov		a,#DAC_P02_MEDPOWER
(0874) 		call	DAC_P02_Start
(0875) 
(0876) 		orabf	4							;enable output buffer			
(0877) 		ret
(0878) 		
(0879) DAC_P02_Off:
(0880) 		M8C_SetBank1
(0881) 		and		[PRTDM1_T+0],~4  			;pulldown mode for P0[2]
(0882) 		and		[PRTDM0_T+0],~4
(0883) 		loadddr0
(0884) 		M8C_SetBank0
(0885) 		andabf	~4							;disable output buffer
(0886) 
(0887) 		call	DAC_P02_Stop
(0888) 		ret
(0889) 		
(0890) _main:
(0891) 
(0892) 		
(0893) 		call	InitComms
(0894) 		call	InitDAC
(0895) 		call	InitADC
(0896) 						
(0897) 		M8C_EnableGInt
(0898) 
(0899) 		call	SettleDelay
(0900) 		call	Signon
(0901) 				
(0902) main_loop:	
(0903) 		call	GetLine			;Get command line
(0904) 		jz		main_loop		;Skip length=0
(0905) 		call	ProcessCmd		;Process command line
(0906) 		jmp		main_loop		;Loop 4 ever
(0907) 
(0908) 
(0909) ;
(0910) ;Communications section
(0911) ;
(0912) include "baudclk.inc"
(0913) include "uartin.inc"
(0914) include "uartout.inc"
(0915) 
(0916) ;
(0917) ;Initialise both UARTs
(0918) ;
(0919) InitComms:
(0920) 
(0921) 		mov		[PRTDM0_T+0],#0
    05FC: 55 04 00 MOV   [4],0
(0922) 		mov		[PRTDM1_T+0],#0			
    05FF: 55 07 00 MOV   [7],0
(0923) 		mov		[PRTDM0_T+1],#0
    0602: 55 05 00 MOV   [5],0
(0924) 		mov		[PRTDM1_T+1],#0			
    0605: 55 08 00 MOV   [8],0
(0925) 		mov		[PRTDM0_T+2],#0
    0608: 55 06 00 MOV   [6],0
(0926) 		mov		[PRTDM1_T+2],#0			;initialise latch storage registers
    060B: 55 09 00 MOV   [9],0
(0927) 
(0928) 		or		[PRTDM0_T+1],#128+32	;P1[7],P1[5]=Strong out (TX)
    060E: 2E 05 A0 OR    [5],160
(0929) 		or		[PRTDM1_T+1],#64+16 	;P1[6],P1[4]=High Z     (RX)
    0611: 2E 08 50 OR    [8],80
    0614: 71 10    OR    F,16
    0616: 08       PUSH  A
    0617: 51 04    MOV   A,[4]
    0619: 60 00    MOV   REG[0],A
    061B: 51 07    MOV   A,[7]
    061D: 60 01    MOV   REG[1],A
    061F: 18       POP   A
    0620: 08       PUSH  A
    0621: 51 05    MOV   A,[5]
    0623: 60 04    MOV   REG[4],A
    0625: 51 08    MOV   A,[8]
    0627: 60 05    MOV   REG[5],A
    0629: 18       POP   A
    062A: 08       PUSH  A
    062B: 51 06    MOV   A,[6]
    062D: 60 08    MOV   REG[8],A
    062F: 51 09    MOV   A,[9]
    0631: 60 09    MOV   REG[9],A
    0633: 18       POP   A
    0634: 70 EF    AND   F,239
(0930) 		
(0931) 		M8C_SetBank1
(0932) 		loadddr0
(0933) 		loadddr1
(0934) 		loadddr2
(0935) 		M8C_SetBank0					;load DDRs
(0936) 
(0937) 		mov		a,#UART_PARITY_NONE
    0636: 50 00    MOV   A,0
(0938) 		call	UARTIN_Start
    0638: 92 F5    CALL  _UARTIN_Start
(0939) 		mov		a,#UART_PARITY_NONE
    063A: 50 00    MOV   A,0
(0940) 		call	UARTOUT_Start
    063C: 92 B3    CALL  _UARTOUT_Start
(0941) 		call	BAUDCLK_Start
    063E: 96 26    CALL  _BAUDCLK_Start
(0942) 		ret
    0640: 7F       RET   
(0943) 
(0944) ;
(0945) ;Transmit A upstream 
(0946) ;
(0947) TxIN:
(0948) 		tst		reg[UARTIN_TX_CONTROL_REG],UART_TX_BUFFER_EMPTY
    0641: 49 3F 10 TST   REG[63],16
(0949)  		jz		TxIN
    0644: AF FC    JZ    0x0641
(0950)  		call	UARTIN_SendData
    0646: 92 F5    CALL  UARTIN_SendData
(0951) 		ret	
    0648: 7F       RET   
(0952) 
(0953) ;
(0954) ;Transmit a newline upstream
(0955) ;
(0956) NewLine:
(0957) 		mov		a,#10
    0649: 50 0A    MOV   A,10
(0958) 		call	TxIN
    064B: 9F F4    CALL  0x0641
(0959) 		mov		a,#13
    064D: 50 0D    MOV   A,13
(0960) 		jmp		TxIN
    064F: 8F F1    JMP   0x0641
(0961) 
(0962) ;
(0963) ;Transmit a 16-bit hex digit upstream
(0964) ;
(0965) ;X:A=Value
(0966) ;		
(0967) DumpHex16:
(0968) 		push	a
    0651: 08       PUSH  A
(0969) 		swap	a,x
    0652: 4B       SWAP  A,X
(0970) 		call	DumpHex
    0653: 90 03    CALL  0x0658
(0971) 		pop		a
    0655: 18       POP   A
(0972) 		jmp		DumpHex
    0656: 80 01    JMP   0x0658
(0973) 		
(0974) 
(0975) ;
(0976) ;Transmit a 8-bit hex digit upstream
(0977) ;
(0978) ;A=Value
(0979) ;		
(0980) DumpHex:
(0981) 		mov		[TMP2],a
    0658: 53 01    MOV   [1],A
(0982) 		rrc		a
    065A: 6D       RRC   A
(0983) 		rrc		a
    065B: 6D       RRC   A
(0984) 		rrc		a
    065C: 6D       RRC   A
(0985) 		rrc		a
    065D: 6D       RRC   A
(0986) 		and		a,#15
    065E: 21 0F    AND   A,15
(0987) 		index	HEXLUT
    0660: F0 0A    INDEX 0x066C
(0988) 		call	TxIN
    0662: 9F DD    CALL  0x0641
(0989) 		mov		a,[TMP2]
    0664: 51 01    MOV   A,[1]
(0990) 		and		a,#15
    0666: 21 0F    AND   A,15
(0991) 		index	HEXLUT
    0668: F0 02    INDEX 0x066C
(0992) 		jmp		TxIN
    066A: 8F D6    JMP   0x0641
    066C: 30       HALT  
    066D: 31 32    XOR   A,50
    066F: 33 34    XOR   A,[X+52]
    0671: 35 36    XOR   [X+54],A
    0673: 37 38 39 XOR   [X+56],57
    0676: 41 42 43 AND   REG[66],67
    0679: 44 45 46 OR    REG[X+69],70
(0993) 
(0994) ;
(0995) ;Hex digit codes
(0996) ;
(0997) HEXLUT:
(0998) 		ds		"0123456789ABCDEF"
(0999) 		
(1000) ;
(1001) ;Dump null terminated string pointed to by A:X
(1002) ;
(1003) DumpString:
(1004) 		mov		[TMP],a
    067C: 53 00    MOV   [0],A
(1005) 		romx
    067E: 28       ROMX  
(1006) 		jz		DumpDone
    067F: A0 0B    JZ    0x068B
(1007) 		call	TxIN
    0681: 9F BE    CALL  0x0641
(1008) 		mov		a,[TMP]
    0683: 51 00    MOV   A,[0]
(1009) 		inc		x
    0685: 75       INC   X
(1010) 		jnz	    DumpString
    0686: BF F5    JNZ   0x067C
(1011) 		inc		a
    0688: 74       INC   A
(1012) 		jnz		DumpString
    0689: BF F2    JNZ   0x067C
(1013) DumpDone:
(1014) 		ret
    068B: 7F       RET   
(1015) 			
(1016) ;
(1017) ;Transmit A downstream 
(1018) ;
(1019) TxOUT:
(1020) 		tst		reg[UARTOUT_TX_CONTROL_REG],UART_TX_BUFFER_EMPTY
    068C: 49 33 10 TST   REG[51],16
(1021)  		jz		TxOUT
    068F: AF FC    JZ    0x068C
(1022)  		call	UARTOUT_SendData
    0691: 92 6C    CALL  _UARTOUT_SendData
(1023) 		ret	
    0693: 7F       RET   
(1024) ;
(1025) ;Receive A from upstream controller (blocking)
(1026) ;If a byte is received from downstream controller, 
(1027) ;	echo it to upstream controller for daisy chaining
(1028) ;
(1029) RxIN:
(1030) 		call	bUARTOUT_ReadRxStatus
    0694: 92 72    CALL  _bUARTOUT_ReadRxStatus
(1031) 		mov		[RX_STATUS],a
    0696: 53 12    MOV   [18],A
(1032) 		and		a,#UART_RX_COMPLETE
    0698: 21 08    AND   A,8
(1033) 		jz		NoRxOUT
    069A: A0 0E    JZ    0x06A9
(1034) 		tst		[RX_STATUS],#UART_RX_NO_ERROR
    069C: 47 12 E0 TST   [18],224
(1035) 		jnz		NoRxOUT
    069F: B0 09    JNZ   0x06A9
(1036) 		call	bUARTOUT_ReadRxData			;fetch data
    06A1: 92 62    CALL  _bUARTOUT_ReadRxData
(1037) 		cmp		a,#0
    06A3: 39 00    CMP   A,0
(1038) 		jz		NoRxOUT						;screen nulls
    06A5: A0 03    JZ    0x06A9
(1039) 		call	TxIN						;pass it up
    06A7: 9F 98    CALL  0x0641
(1040) NoRxOUT:
(1041) 		call	bUARTIN_ReadRxStatus
    06A9: 92 9B    CALL  _bUARTIN_ReadRxStatus
(1042) 		mov		[RX_STATUS],a
    06AB: 53 12    MOV   [18],A
(1043) 		and		a,#UART_RX_COMPLETE
    06AD: 21 08    AND   A,8
(1044) 		jz		RxIN
    06AF: AF E4    JZ    0x0694
(1045) 		tst		[RX_STATUS],#UART_RX_NO_ERROR
    06B1: 47 12 E0 TST   [18],224
(1046) 		jnz		RxIN
    06B4: BF DF    JNZ   0x0694
(1047) 		call	bUARTIN_ReadRxData
    06B6: 92 8B    CALL  _bUARTIN_ReadRxData
(1048) 		cmp		a,#0
    06B8: 39 00    CMP   A,0
(1049) 		jz		RxIN						;screen nulls
    06BA: AF D9    JZ    0x0694
(1050) 		ret
    06BC: 7F       RET   
    06BD: 50 06    MOV   A,6
    06BF: 57 C6    MOV   X,198
(1051) 
(1052) ;
(1053) ;Print the signon message
(1054) ;	
(1055) Signon:
(1056) 		lea		Signon_MSG
(1057) 		call	DumpString
    06C1: 9F B9    CALL  0x067C
(1058) 		call	NewLine
    06C3: 9F 84    CALL  0x0649
(1059) 		ret
    06C5: 7F       RET   
    06C6: 50 6F    MOV   A,111
    06C8: 64       ASL   A
    06C9: 20       POP   X
    06CA: 4F       MOV   X,SP
    06CB: 6E 6C    RRC   [108]
    06CD: 69 6E    ASR   [X+110]
    06CF: 65 00    ASL   [0]
(1060) 
(1061) Signon_MSG:
(1062) 		asciz		"Pod Online"
(1063) 
(1064) ;
(1065) ;Get a LF terminated line from the upstream controller
(1066) ;Strip LF,CR and NULL terminate it
(1067) ;
(1068) ;Returns string length in A (not including NULL)
(1069) ;
(1070) LF:		equ		10
(1071) CR:		equ		13
(1072) 
(1073) GetLine:
(1074) 
(1075) 		mov		[TMP3],#COMMBUF			;set up storage pointer
    06D1: 55 02 13 MOV   [2],19
(1076) GetSyncLoop:
(1077) 		call	RxIN					;get a char (blocking)
    06D4: 9F BE    CALL  0x0694
(1078) 		cmp		a,#'!'					;scan for start character
    06D6: 39 21    CMP   A,33
(1079) 		jnz		GetSyncLoop				;ignore everything 
    06D8: BF FB    JNZ   0x06D4
(1080) GetCmdLoop:
(1081) 		call	RxIN					;get a char (blocking)
    06DA: 9F B8    CALL  0x0694
(1082) 		cmp		a,#CR					;terminate character?
    06DC: 39 0D    CMP   A,13
(1083) 		jz		GetDone
    06DE: A0 0C    JZ    0x06EB
(1084) 		cmp		a,#31					;disregard control chars
    06E0: 39 1F    CMP   A,31
(1085) 		jc		GetCmdLoop
    06E2: CF F7    JC    0x06DA
(1086) 		mvi		[TMP3],a				;store char, advance ptr
    06E4: 3F 02    MVI   [2],A
(1087) 		cmp		[TMP3],COMMBUF+MAXLINE-1	;out of storage space?
    06E6: 3C 02 22 CMP   [2],34
(1088) 		jnz		GetCmdLoop				;no, next char
    06E9: BF F0    JNZ   0x06DA
(1089) GetDone:
(1090) 		mov		a,#0
    06EB: 50 00    MOV   A,0
(1091) 		mvi		[TMP3],a				;null terminate string
    06ED: 3F 02    MVI   [2],A
(1092) 		sub		[TMP3],#COMMBUF+1		;work out length
    06EF: 16 02 14 SUB   [2],20
(1093) 		mov		a,[TMP3]
    06F2: 51 02    MOV   A,[2]
(1094) 		ret					
    06F4: 7F       RET   
(1095) 
(1096) ;
(1097) ;Process a command
(1098) ;
(1099) ProcessCmd:
(1100) 		mov		[TMP3],#COMMBUF			;initialise pointer
    06F5: 55 02 13 MOV   [2],19
(1101) 		
(1102) 		mvi		a,[TMP3]				;fetch address byte
    06F8: 3E 02    MVI   A,[2]
(1103) 		jz		ProcessDone				;unexepected NULL
    06FA: A0 1F    JZ    0x071A
(1104) 		
(1105) 		cmp		a,#'0'					;command for this pod?
    06FC: 39 30    CMP   A,48
(1106) 		jz		ProcessMatch			;yes, interpret command
    06FE: A0 1C    JZ    0x071B
(1107) 				
(1108) ProcessEcho:
(1109) 		jc		ProcessDone				;invalid address - discard
    0700: C0 19    JC    0x071A
(1110) 		
(1111) 		dec		a						;consume one hop 
    0702: 78       DEC   A
(1112) 		push	a
    0703: 08       PUSH  A
(1113) 		mov		a,#'!'					;command header
    0704: 50 21    MOV   A,33
(1114) 		call	TxOUT
    0706: 9F 84    CALL  0x068C
(1115) 		pop		a
    0708: 18       POP   A
(1116) 		call	TxOUT					;address
    0709: 9F 81    CALL  0x068C
(1117) EchoLoop:
(1118) 		mvi		a,[TMP3]				;echo command downstream
    070B: 3E 02    MVI   A,[2]
(1119) 		jz		EchoDone
    070D: A0 08    JZ    0x0716
(1120) 		call	TxOUT
    070F: 9F 7B    CALL  0x068C
(1121) 		cmp		[TMP3],#COMMBUF+MAXLINE
    0711: 3C 02 23 CMP   [2],35
(1122) 		jnz		EchoLoop
    0714: BF F6    JNZ   0x070B
(1123) EchoDone:
(1124) 		mov		a,#CR
    0716: 50 0D    MOV   A,13
(1125) 		call	TxOUT					;terminate
    0718: 9F 72    CALL  0x068C
(1126) ProcessDone:
(1127) 		ret
    071A: 7F       RET   
(1128) 
(1129) ;
(1130) ;Command destination is this unit - 
(1131) ;process command and generate appropriate response 
(1132) ;
(1133) ProcessMatch:
(1134) 
(1135) 		mvi		a,[TMP3]		;Fetch command
    071B: 3E 02    MVI   A,[2]
(1136) 		jz		ProcessDone		;Unexpected NULL - discard
    071D: AF FC    JZ    0x071A
(1137) 		cmp		a,#'W'			;Write DAC
    071F: 39 57    CMP   A,87
(1138) 		jz		ProcessAnaOut
    0721: A1 24    JZ    0x0846
(1139) 		cmp		a,#'='			;Write digital output
    0723: 39 3D    CMP   A,61
(1140) 		jz		ProcessDigOut
    0725: A0 C5    JZ    0x07EB
(1141) 		cmp		a,#'?'
    0727: 39 3F    CMP   A,63
(1142) 		jz		ProcessDigIn	;Read digital input
    0729: A0 7A    JZ    0x07A4
(1143) 		cmp		a,#'R'
    072B: 39 52    CMP   A,82
(1144) 		jnz		ProcessDone		;Unsupported command - discard
    072D: BF EC    JNZ   0x071A
(1145) 
(1146) ;
(1147) ;Read analog input command
(1148) ;
(1149) ;Command syntax !0R+-GGNNDD	
(1150) ;
(1151) ;+		Positive Input Port 0 (0..7). Note that 8 is the ground.
(1152) ;-		Negative Input Port 0 (0..7)
(1153) ;GG		Gain constant
(1154) ;NN		Number of samples
(1155) ;DD		Sampling frequency
(1156) ;
(1157) ProcessAnaIn:
(1158) 		call	GetHexDigit				;Scan + input
    072F: 91 77    CALL  0x08A8
(1159) 		jc		CmdError
    0731: C1 0F    JC    0x0841
(1160) 		cmp		a,#9
    0733: 39 09    CMP   A,9
(1161) 		jnc		CmdError
    0735: D1 0B    JNC   0x0841
(1162) 		mov		[PORT],a
    0737: 53 0A    MOV   [10],A
(1163) 		call	GetHexDigit				;Scan - input
    0739: 91 6D    CALL  0x08A8
(1164) 		jc		CmdError
    073B: C1 05    JC    0x0841
(1165) 		cmp		a,#9
    073D: 39 09    CMP   A,9
(1166) 		jnc		CmdError
    073F: D1 01    JNC   0x0841
(1167) 		mov		[PORT+1],a
    0741: 53 0B    MOV   [11],A
(1168) 
(1169) 		call	GetHexByte
    0743: 91 50    CALL  0x0895
(1170) 		jc		CmdError
    0745: C0 FB    JC    0x0841
(1171) 		mov		[GAINK],a
    0747: 53 0D    MOV   [13],A
(1172) 		call	GetHexByte
    0749: 91 4A    CALL  0x0895
(1173) 		jc		CmdError
    074B: C0 F5    JC    0x0841
(1174) 		mov		[NOSAMPLES],a		
    074D: 53 0C    MOV   [12],A
(1175) 		call	GetHexByte
    074F: 91 44    CALL  0x0895
(1176) 		jc		CmdError
    0751: C0 EF    JC    0x0841
(1177) 		mov		[SAMPLECLK],a
    0753: 53 11    MOV   [17],A
(1178) 
(1179) 		cmp		[PORT+1],#8			;Single ended +VE input
    0755: 3C 0B 08 CMP   [11],8
(1180) 		jz		Single
    0758: A0 21    JZ    0x077A
(1181) 		cmp		[PORT],#8			;Single ended -VE input
    075A: 3C 0A 08 CMP   [10],8
(1182) 		jz		SingleInverted
    075D: A0 31    JZ    0x078F
(1183) Double:
(1184) 		mov		a,[PORT]
    075F: 51 0A    MOV   A,[10]
(1185) 		rlc		a
    0761: 6A       RLC   A
(1186) 		rlc		a
    0762: 6A       RLC   A
(1187) 		rlc		a
    0763: 6A       RLC   A
(1188) 		rlc		a
    0764: 6A       RLC   A
(1189) 		and		a,#240
    0765: 21 F0    AND   A,240
(1190) 		or		a,[PORT+1]
    0767: 2A 0B    OR    A,[11]
(1191) 		call	DoubleEndedPort
    0769: 9A C2    CALL  0x022D
(1192) 		jc		CmdError			;Not possible?
    076B: C0 D5    JC    0x0841
(1193) 		mov		a,#'*'
    076D: 50 2A    MOV   A,42
(1194) 		call	TxIN
    076F: 9E D0    CALL  0x0641
(1195) 		call	RunADC
    0771: 9B AC    CALL  0x031F
(1196) 		jc		CmdError
    0773: C0 CD    JC    0x0841
(1197) 		call	DumpHex16
    0775: 9E DA    CALL  0x0651
(1198) 		call	NewLine				
    0777: 9E D0    CALL  0x0649
(1199) 		ret
    0779: 7F       RET   
(1200) 
(1201) Single:
(1202) 		mov		a,[PORT]
    077A: 51 0A    MOV   A,[10]
(1203) 		cmp		a,#8
    077C: 39 08    CMP   A,8
(1204) 		jz		CmdError
    077E: A0 C2    JZ    0x0841
(1205) 		call	SingleEndedPort
    0780: 99 8F    CALL  0x0111
(1206) 		mov		a,#'*'
    0782: 50 2A    MOV   A,42
(1207) 		call	TxIN
    0784: 9E BB    CALL  0x0641
(1208) 		call	RunADC
    0786: 9B 97    CALL  0x031F
(1209) 		jc		CmdError
    0788: C0 B8    JC    0x0841
(1210) 		call	DumpHex16
    078A: 9E C5    CALL  0x0651
(1211) 		call	NewLine
    078C: 9E BB    CALL  0x0649
(1212) 		ret
    078E: 7F       RET   
(1213) 
(1214) SingleInverted:
(1215) 		mov		a,[PORT+1]
    078F: 51 0B    MOV   A,[11]
(1216) 		cmp		a,#8
    0791: 39 08    CMP   A,8
(1217) 		jz		CmdError
    0793: A0 AD    JZ    0x0841
(1218) 		call	SingleEndedInvPort
    0795: 9A 03    CALL  0x019A
(1219) 		mov		a,#'*'
    0797: 50 2A    MOV   A,42
(1220) 		call	TxIN
    0799: 9E A6    CALL  0x0641
(1221) 		call	RunADC
    079B: 9B 82    CALL  0x031F
(1222) 		jc		CmdError
    079D: C0 A3    JC    0x0841
(1223) 		call	DumpHex16
    079F: 9E B0    CALL  0x0651
(1224) 		call	NewLine
    07A1: 9E A6    CALL  0x0649
(1225) 		ret
    07A3: 7F       RET   
(1226) 
(1227) ;
(1228) ;Read digital input command
(1229) ;								
(1230) ;
(1231) ;Command syntax !0?PBM		P=Port 0..1 B=Bit 0..7 M=Set DDR (1=Yes 0=No)
(1232) ;
(1233) ProcessDigIn:
(1234) 
(1235) 		call	GetPortBit			;Scan port & bit settings
    07A4: 90 26    CALL  0x07CC
(1236) 		jc		CmdError
    07A6: C0 9A    JC    0x0841
(1237) 		
(1238) 		call	GetHexDigit			;Scan mode setting
    07A8: 90 FE    CALL  0x08A8
(1239) 		jc		CmdError
    07AA: C0 96    JC    0x0841
(1240) 		cmp		a,#0				;Don't force DDR?
    07AC: 39 00    CMP   A,0
(1241) 		jz		SkipDDR				;Yes, skip it
    07AE: A0 05    JZ    0x07B4
(1242) 		mov		a,[PORT]
    07B0: 51 0A    MOV   A,[10]
(1243) 		call	SetDDRIn
    07B2: 9C 8B    CALL  0x043F
(1244) SkipDDR:
(1245) 		mov		a,#'*'
    07B4: 50 2A    MOV   A,42
(1246) 		call	TxIN
    07B6: 9E 89    CALL  0x0641
(1247) 		mov		a,[PORT]
    07B8: 51 0A    MOV   A,[10]
(1248) 		call	ReadDigitalInput
    07BA: 9C D2    CALL  0x048E
(1249) 		jnz		DigIsHigh
    07BC: B0 08    JNZ   0x07C5
(1250) DigIsLow:
(1251) 		mov		a,#'0'
    07BE: 50 30    MOV   A,48
(1252) 		call	TxIN
    07C0: 9E 7F    CALL  0x0641
(1253) 		call	NewLine
    07C2: 9E 85    CALL  0x0649
(1254) 		ret
    07C4: 7F       RET   
(1255) DigIsHigh:
(1256) 		mov		a,#'1'
    07C5: 50 31    MOV   A,49
(1257) 		call	TxIN
    07C7: 9E 78    CALL  0x0641
(1258) 		call	NewLine
    07C9: 9E 7E    CALL  0x0649
(1259) 		ret
    07CB: 7F       RET   
(1260) 
(1261) ;
(1262) ;Interpret the port/bit combination
(1263) ;
(1264) GetPortBit:
(1265) 
(1266) 		call	GetHexDigit
    07CC: 90 DA    CALL  0x08A8
(1267) 		jc		PortBitErr
    07CE: C0 19    JC    0x07E8
(1268) 		cmp		a,#2			;Port 0 or 1
    07D0: 39 02    CMP   A,2
(1269) 		jnc		PortBitErr
    07D2: D0 15    JNC   0x07E8
(1270) 		rlc		a
    07D4: 6A       RLC   A
(1271) 		rlc		a
    07D5: 6A       RLC   A
(1272) 		rlc		a
    07D6: 6A       RLC   A
(1273) 		and		a,#8			;Shift up
    07D7: 21 08    AND   A,8
(1274) 		mov		[PORT],a		;Save
    07D9: 53 0A    MOV   [10],A
(1275) 		call	GetHexDigit
    07DB: 90 CB    CALL  0x08A8
(1276) 		jc		PortBitErr
    07DD: C0 0A    JC    0x07E8
(1277) 		cmp		a,#8
    07DF: 39 08    CMP   A,8
(1278) 		jnc		PortBitErr		;Bit 0..7
    07E1: D0 06    JNC   0x07E8
(1279) 		or		[PORT],a
    07E3: 2C 0A    OR    [10],A
    07E5: 70 FB    AND   F,251
(1280) 		clc
(1281) 		ret
    07E7: 7F       RET   
    07E8: 71 04    OR    F,4
(1282) PortBitErr:
(1283) 		sec
(1284) 		ret
    07EA: 7F       RET   
(1285) 
(1286) ;
(1287) ;Drive digital output command
(1288) ;		
(1289) ;
(1290) ;Command syntax !0=PBMS		P=Port 0..1 B=Bit 0..7 M=Mode S=State
(1291) ;
(1292) ;
(1293) ProcessDigOut:
(1294) 
(1295) 		call	GetPortBit
    07EB: 9F DF    CALL  0x07CC
(1296) 		jc		CmdError
    07ED: C0 53    JC    0x0841
(1297) 			
(1298) 		mov		a,[PORT]
    07EF: 51 0A    MOV   A,[10]
(1299) 		rrc		a
    07F1: 6D       RRC   A
(1300) 		rrc		a
    07F2: 6D       RRC   A
(1301) 		rrc		a
    07F3: 6D       RRC   A
(1302) 		and		a,#3			;Port 0?
    07F4: 21 03    AND   A,3
(1303) 		jnz		SkipDACOFF		;No, skip
    07F6: B0 0F    JNZ   0x0806
(1304) 		mov		a,[PORT]
    07F8: 51 0A    MOV   A,[10]
(1305) 		and		a,#7			;P02..P05?
    07FA: 21 07    AND   A,7
(1306) 		cmp		a,#2
    07FC: 39 02    CMP   A,2
(1307) 		jc		SkipDACOFF
    07FE: C0 07    JC    0x0806
(1308) 		cmp		a,#6
    0800: 39 06    CMP   A,6
(1309) 		jnc		SkipDACOFF
    0802: D0 03    JNC   0x0806
(1310) 		call	DisableDAC
    0804: 9C AB    CALL  0x04B1
(1311) 		
(1312) SkipDACOFF:
(1313) 		
(1314) 		call	GetHexDigit		;Mode
    0806: 90 A0    CALL  0x08A8
(1315) 		jc		CmdError
    0808: C0 38    JC    0x0841
(1316) 		
(1317) 		and		a,#3
    080A: 21 03    AND   A,3
    080C: 70 FB    AND   F,251
(1318) 		clc
(1319) 		rlc		a		
    080E: 6A       RLC   A
(1320) 		jacc	ModeLUT
    080F: E0 01    JACC  0x0811
(1321) 		
(1322) ModeLUT:
(1323) 		jmp		SetPulldownMode
    0811: 80 0D    JMP   0x081F
(1324) 		jmp		SetStrongMode
    0813: 80 17    JMP   0x082B
(1325) 		jmp		SetHighZMode
    0815: 80 03    JMP   0x0819
(1326) 		jmp		SetPullupMode
    0817: 80 0D    JMP   0x0825
(1327) 		
(1328) SetHighZMode:
(1329) 		mov		a,[PORT]
    0819: 51 0A    MOV   A,[10]
(1330) 		call	SetDDRIn
    081B: 9C 22    CALL  0x043F
(1331) 		jmp		DoneMode
    081D: 80 11    JMP   0x082F
(1332) 		
(1333) SetPulldownMode:
(1334) 		mov		a,[PORT]
    081F: 51 0A    MOV   A,[10]
(1335) 		call	SetDDRPulldown
    0821: 9B CA    CALL  0x03ED
(1336) 		jmp		DoneMode
    0823: 80 0B    JMP   0x082F
(1337) 
(1338) SetPullupMode:
(1339) 		mov		a,[PORT]
    0825: 51 0A    MOV   A,[10]
(1340) 		call	SetDDRPullup
    0827: 9B ED    CALL  0x0416
(1341) 		jmp		DoneMode
    0829: 80 05    JMP   0x082F
(1342) 		
(1343) SetStrongMode:
(1344) 		mov		a,[PORT]
    082B: 51 0A    MOV   A,[10]
(1345) 		call	SetDDROut
    082D: 9B 8F    CALL  0x03BE
(1346) 		
(1347) 		;fall thru
(1348) 								
(1349) DoneMode:
(1350) 		call	GetHexDigit		;State (Clear/Set)
    082F: 90 77    CALL  0x08A8
(1351) 		jc		CmdError		
    0831: C0 0F    JC    0x0841
(1352) 		cmp		a,#0
    0833: 39 00    CMP   A,0
(1353) 		jz		ClrDig
    0835: A0 06    JZ    0x083C
(1354) SetDig:
(1355) 		mov		a,[PORT]
    0837: 51 0A    MOV   A,[10]
(1356) 		call	SetDigitalOutput
    0839: 9C 35    CALL  0x0470
(1357) 		ret
    083B: 7F       RET   
(1358) ClrDig:
(1359) 		mov		a,[PORT]
    083C: 51 0A    MOV   A,[10]
(1360) 		call	ClrDigitalOutput
    083E: 9C 3F    CALL  0x047F
(1361) 		ret
    0840: 7F       RET   
(1362) 		
(1363) CmdError:
(1364) 		mov		a,#'?'
    0841: 50 3F    MOV   A,63
(1365) 		call	TxIN
    0843: 9D FC    CALL  0x0641
(1366) 		ret
    0845: 7F       RET   
(1367) 		
(1368) ;
(1369) ;Command syntax !0WPGG		P=Port 2,3,4 or 5	GG=Gain 00..3D
(1370) ;
(1371) ProcessAnaOut:
(1372) 		call	GetHexDigit			;port
    0846: 90 60    CALL  0x08A8
(1373) 		jc		CmdError
    0848: CF F8    JC    0x0841
(1374) 		mov		[PORT],a
    084A: 53 0A    MOV   [10],A
(1375) 		sub		a,#2
    084C: 11 02    SUB   A,2
(1376) 		jc		CmdError
    084E: CF F2    JC    0x0841
(1377) 		cmp		a,#4				;make sure it lies within 2..5
    0850: 39 04    CMP   A,4
(1378) 		jnc		CmdError
    0852: DF EE    JNC   0x0841
    0854: 70 FB    AND   F,251
(1379) 		clc
(1380) 		rlc		a		
    0856: 6A       RLC   A
(1381) 		jacc	DACLUT
    0857: E0 01    JACC  0x0859
(1382) 		
(1383) DACLUT:
(1384) 		jmp		Ctrl_DAC_P02
    0859: 80 07    JMP   0x0861
(1385) 		jmp		Ctrl_DAC_P03
    085B: 80 12    JMP   0x086E
(1386) 		jmp		Ctrl_DAC_P04
    085D: 80 1D    JMP   0x087B
(1387) 		jmp		Ctrl_DAC_P05
    085F: 80 28    JMP   0x0888
(1388) 
(1389) Ctrl_DAC_P02:
(1390) 		call	GetHexByte
    0861: 90 32    CALL  0x0895
(1391) 		jc		CmdError
    0863: CF DD    JC    0x0841
(1392) 		cmp		a,#$3e
    0865: 39 3E    CMP   A,62
(1393) 		jnc		CmdError
    0867: DF D9    JNC   0x0841
(1394) 		call	DAC_P02_WriteStall
    0869: 93 C8    CALL  DAC_P02_WriteStall
(1395) 		call	DAC_P02_On
    086B: 9D 31    CALL  0x059E
(1396) 		ret
    086D: 7F       RET   
(1397) 
(1398) Ctrl_DAC_P03:
(1399) 		call	GetHexByte
    086E: 90 25    CALL  0x0895
(1400) 		jc		CmdError
    0870: CF D0    JC    0x0841
(1401) 		cmp		a,#$3e
    0872: 39 3E    CMP   A,62
(1402) 		jnc		CmdError
    0874: DF CC    JNC   0x0841
(1403) 		call	DAC_P03_WriteStall
    0876: 93 7E    CALL  _DAC_P03_WriteStall
(1404) 		call	DAC_P03_On
    0878: 9C 46    CALL  0x04C0
(1405) 		ret
    087A: 7F       RET   
(1406) 
(1407) Ctrl_DAC_P04:
(1408) 		call	GetHexByte
    087B: 90 18    CALL  0x0895
(1409) 		jc		CmdError
    087D: CF C3    JC    0x0841
(1410) 		cmp		a,#$3e
    087F: 39 3E    CMP   A,62
(1411) 		jnc		CmdError
    0881: DF BF    JNC   0x0841
(1412) 		call	DAC_P04_WriteStall
    0883: 93 34    CALL  DAC_P04_WriteStall
(1413) 		call	DAC_P04_On
    0885: 9C CD    CALL  0x0554
(1414) 		ret
    0887: 7F       RET   
(1415) 
(1416) Ctrl_DAC_P05:
(1417) 		call	GetHexByte
    0888: 90 0B    CALL  0x0895
(1418) 		jc		CmdError
    088A: CF B6    JC    0x0841
(1419) 		cmp		a,#$3e
    088C: 39 3E    CMP   A,62
(1420) 		jnc		CmdError
    088E: DF B2    JNC   0x0841
(1421) 		call	DAC_P05_WriteStall
    0890: 92 EA    CALL  _DAC_P05_WriteStall
(1422) 		call	DAC_P05_On
    0892: 9C 76    CALL  0x050A
(1423) 		ret
    0894: 7F       RET   
(1424) 
(1425) ;
(1426) ;Interpret next two character as a hex byte and return in A
(1427) ;
(1428) GetHexByte:
(1429) 		call	GetHexDigit
    0895: 90 11    CALL  0x08A8
(1430) 		jc		GetHexDone
    0897: C0 0F    JC    0x08A7
(1431) 		rlc		a
    0899: 6A       RLC   A
(1432) 		rlc		a
    089A: 6A       RLC   A
(1433) 		rlc		a
    089B: 6A       RLC   A
(1434) 		rlc		a
    089C: 6A       RLC   A
(1435) 		and		a,#240		
    089D: 21 F0    AND   A,240
(1436) 		mov		[TMP],a
    089F: 53 00    MOV   [0],A
(1437) 		call	GetHexDigit
    08A1: 90 05    CALL  0x08A8
(1438) 		jc		GetHexDone
    08A3: C0 03    JC    0x08A7
(1439) 		or		a,[TMP]
    08A5: 2A 00    OR    A,[0]
(1440) GetHexDone:
(1441) 		ret
    08A7: 7F       RET   
(1442) 		
(1443) ;
(1444) ;Interpret next character as a hex digit and return in A
(1445) ;
(1446) ;Carry is set if digit was invalid
(1447) ;
(1448) GetHexDigit:
(1449) 		mvi		a,[TMP3]
    08A8: 3E 02    MVI   A,[2]
(1450) 		jz		InvalidDigit
    08AA: A0 14    JZ    0x08BF
(1451) 		cmp		a,#'0'
    08AC: 39 30    CMP   A,48
(1452) 		jc		InvalidDigit
    08AE: C0 10    JC    0x08BF
(1453) 		sub		a,#'0'
    08B0: 11 30    SUB   A,48
(1454) 		cmp		a,#10
    08B2: 39 0A    CMP   A,10
(1455) 		jc		ValidDigit
    08B4: C0 07    JC    0x08BC
(1456) 		sub		a,#7
    08B6: 11 07    SUB   A,7
(1457) 		cmp		a,#16
    08B8: 39 10    CMP   A,16
(1458) 		jnc		InvalidDigit
    08BA: D0 04    JNC   0x08BF
    08BC: 70 FB    AND   F,251
(1459) ValidDigit:
(1460) 		clc
(1461) 		ret
    08BE: 7F       RET   
    08BF: 71 04    OR    F,4
(1462) InvalidDigit:
(1463) 		sec
(1464) 		ret		
    08C1: 7F       RET   
(1465) 
(1466) ;
(1467) ;Wait for pin to settle before sampling
(1468) ;		
(1469) SettleDelay:
(1470) 		mov		x,#104			;10 ms
    08C2: 57 68    MOV   X,104
(1471) 		mov		a,#0
    08C4: 50 00    MOV   A,0
(1472) SettleLp:
(1473) 		inc		a				;96 us per iteration (2313 cyc)
    08C6: 74       INC   A
(1474) 		jnz		SettleLp
    08C7: BF FE    JNZ   0x08C6
(1475) 		dec		x
    08C9: 79       DEC   X
(1476) 		jnz		SettleLp
    08CA: BF FB    JNZ   0x08C6
(1477) 		ret
    08CC: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\UARTOU~1.ASM
(0001) ;------------------------------------------------------------------------------
(0002) ;  FILENAME:   UARTOUTint.asm
(0003) ;   VERSION:    Rev B, 2002 Mar 30
(0004) ;------------------------------------------------------------------------------
(0005) ;  DESCRIPTION:
(0006) ;     Interrupt handler routine for UART user module instance:
(0007) ;        UARTOUT.
(0008) ;------------------------------------------------------------------------------
(0009) ;	Copyright (c) Cypress MicroSystems 2000-2002.  All Rights Reserved.
(0010) ;------------------------------------------------------------------------------
(0011) 
(0012) include  "UARTOUT.inc"
(0013) 
(0014) area text (ROM, REL)
(0015) 
(0016) ;-----------------------------------------------------
(0017) ;  Export interrupt handler
(0018) ;     NOTE that interrupt handler is NOT exported
(0019) ;     for access by C function.  Interrupt handlers
(0020) ;     are not callable by C functions.
(0021) ;-----------------------------------------------------
(0022) export   UARTOUTTX_INT
(0023) export   UARTOUTRX_INT
(0024) 
(0025) ;-----------------------------------------------------------------------------
(0026) ;  FUNCTION NAME: UARTOUTTX_INT
(0027) ;
(0028) ;  DESCRIPTION:
(0029) ;     UART TX interrupt handler for instance UARTOUT.  
(0030) ;
(0031) ;     This is a place holder function.  If the user requires use of an interrupt
(0032) ;     handler for this function, then place code where specified.
(0033) ;
(0034) ;  ARGUMENTS:
(0035) ;     none.
(0036) ;
(0037) ;  RETURNS:
(0038) ;     none.
(0039) ;
(0040) ;  SIDE EFFECTS:
(0041) ;     none.
(0042) ;
(0043) ;  THEORY of OPERATION:  
(0044) ;     none.
(0045) ;
(0046) ;-----------------------------------------------------------------------------
(0047) UARTOUTTX_INT:
(0048)    ;--------------------------
(0049)    ; Place user code here!!!
(0050)    ;--------------------------
(0051)    reti
UARTOUTTX_INT:
    08CD: 7E       RETI  
(0052) 	
(0053) 
(0054) ;-----------------------------------------------------------------------------
(0055) ;  FUNCTION NAME: UARTOUTRX_INT
(0056) ;
(0057) ;  DESCRIPTION:
(0058) ;     UART RX interrupt handler for instance UARTOUT.  
(0059) ;
(0060) ;     This is a place holder function.  If the user requires use of an interrupt
(0061) ;     handler for this function, then place code where specified.
(0062) ;
(0063) ;  ARGUMENTS:
(0064) ;     none.
(0065) ;
(0066) ;  RETURNS:
(0067) ;     none.
(0068) ;
(0069) ;  SIDE EFFECTS:
(0070) ;     none.
(0071) ;
(0072) ;  THEORY of OPERATION:  
(0073) ;     none.
(0074) ;
(0075) ;-----------------------------------------------------------------------------
(0076) UARTOUTRX_INT:
(0077)    ;--------------------------
(0078)    ; Place user code here!!!
(0079)    ;--------------------------
(0080)    reti
UARTOUTRX_INT:
    08CE: 7E       RETI  
FILE: E:\CONTES~1\ENTRY201\LIB\UARTOUT.ASM
(0001) ;------------------------------------------------------------------------------
UARTOUT_EnableInt:
_UARTOUT_EnableInt:
    08CF: 43 E1 10 OR    REG[225],16
    08D2: 43 E1 20 OR    REG[225],32
(0002) ;  FILENAME:   UARTOUT.asm
(0003) ;   VERSION:   Rev B, 2002 Mar 30
(0004) ;------------------------------------------------------------------------------
(0005) ;  DESCRIPTION:
(0006) ;     UARTOUT UART User Module API.
(0007) ;------------------------------------------------------------------------------
(0008) ;	Copyright (c) Cypress MicroSystems 2000-2002. All Rights Reserved.
(0009) ;------------------------------------------------------------------------------
(0010) 
(0011) ;-----------------------------------------------
(0012) ; include instance specific register definitions
(0013) ;-----------------------------------------------
(0014) include "m8c.inc"
(0015) include "UARTOUT.inc"
(0016) 
(0017) area text (ROM, REL)
(0018) 
(0019) ;-------------------------------------------------------------------
(0020) ;  Declare the functions global for both assembler and C compiler.
(0021) ;
(0022) ;  Note that there are two names for each API. First name is 
(0023) ;  assembler reference. Name with underscore is name refence for
(0024) ;  C compiler.  Calling function in C source code does not require 
(0025) ;  the underscore.
(0026) ;-------------------------------------------------------------------
(0027) export   UARTOUT_EnableInt
(0028) export  _UARTOUT_EnableInt
(0029) export   UARTOUT_DisableInt
(0030) export  _UARTOUT_DisableInt
(0031) export   UARTOUT_Start
(0032) export  _UARTOUT_Start
(0033) export   UARTOUT_Stop
(0034) export  _UARTOUT_Stop
(0035) export   UARTOUT_SendData
(0036) export  _UARTOUT_SendData
(0037) export  bUARTOUT_ReadTxStatus
(0038) export _bUARTOUT_ReadTxStatus
(0039) export  bUARTOUT_ReadRxData
(0040) export _bUARTOUT_ReadRxData
(0041) export  bUARTOUT_ReadRxStatus
(0042) export _bUARTOUT_ReadRxStatus
(0043) 
(0044) ;-----------
(0045) ;  EQUATES
(0046) ;-----------
(0047) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit 
(0048) 
(0049) ;-----------------------------------------------------------------------------
(0050) ;  FUNCTION NAME: UARTOUT_EnableInt
(0051) ;
(0052) ;  DESCRIPTION:
(0053) ;     Enables this UART's interrupt by setting the interrupt enable mask 
(0054) ;     bit associated with this User Module. Remember to call the global 
(0055) ;     interrupt enable function by using the macro: M8C_EnableGInt.
(0056) ;
(0057) ;  ARGUMENTS:
(0058) ;     none.
(0059) ;
(0060) ;  RETURNS:
(0061) ;     none.
(0062) ;
(0063) ;  SIDE EFFECTS:
(0064) ;     none.
(0065) ;
(0066) ;  THEORY of OPERATION:  
(0067) ;     Sets the specific user module interrupt enable mask bit in both the
(0068) ;     TX and RX blocks.
(0069) ;
(0070) ;-----------------------------------------------------------------------------
(0071)  UARTOUT_EnableInt:
(0072) _UARTOUT_EnableInt:
(0073)    M8C_EnableIntMask UARTOUT_TX_INT_REG, bUARTOUT_TX_INT_MASK
(0074)    M8C_EnableIntMask UARTOUT_RX_INT_REG, bUARTOUT_RX_INT_MASK
(0075)    ret	
    08D5: 7F       RET   
UARTOUT_DisableInt:
_UARTOUT_DisableInt:
    08D6: 5D FF    MOV   A,REG[255]
    08D8: 70 FE    AND   F,254
    08DA: 41 E1 EF AND   REG[225],239
    08DD: 21 80    AND   A,128
    08DF: A0 03    JZ    0x08E3
    08E1: 71 01    OR    F,1
    08E3: 5D FF    MOV   A,REG[255]
    08E5: 70 FE    AND   F,254
    08E7: 41 E1 DF AND   REG[225],223
    08EA: 21 80    AND   A,128
    08EC: A0 03    JZ    0x08F0
    08EE: 71 01    OR    F,1
(0076) 
(0077) 	
(0078) ;-----------------------------------------------------------------------------
(0079) ;  FUNCTION NAME: UARTOUT_DisableInt
(0080) ;
(0081) ;  DESCRIPTION:
(0082) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
(0083) ;     associated with this User Module. 
(0084) ;
(0085) ;  ARGUMENTS:
(0086) ;     none.
(0087) ;
(0088) ;  RETURNS:
(0089) ;     none.
(0090) ;
(0091) ;  SIDE EFFECTS:
(0092) ;     none.
(0093) ;
(0094) ;  THEORY of OPERATION:  
(0095) ;     Clears the specific user module interrupt enable mask bit in the TX
(0096) ;     and RX blocks.
(0097) ;
(0098) ;-----------------------------------------------------------------------------
(0099)  UARTOUT_DisableInt:
(0100) _UARTOUT_DisableInt:
(0101)    M8C_DisableIntMask UARTOUT_TX_INT_REG, bUARTOUT_TX_INT_MASK
(0102)    M8C_DisableIntMask UARTOUT_RX_INT_REG, bUARTOUT_RX_INT_MASK
(0103)    ret
    08F0: 7F       RET   
(0104) 
(0105) 
(0106) ;-----------------------------------------------------------------------------
(0107) ;  FUNCTION NAME: UARTOUT_Start(BYTE bParity)
(0108) ;
(0109) ;  DESCRIPTION:
(0110) ;     Sets the start bit and parity in the Control register of this user module. 
(0111) ;
(0112) ;  ARGUMENTS:
(0113) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
(0114) ;        Passed in the A register.
(0115) ;
(0116) ;  RETURNS:
(0117) ;     none.
(0118) ;
(0119) ;  SIDE EFFECTS:
(0120) ;     none.
(0121) ;
(0122) ;  THEORY of OPERATION:  
(0123) ;     Set the specified parity and start bits in the Control register of the 
(0124) ;     TX and RX blocks.
(0125) ;
(0126) ;-----------------------------------------------------------------------------
(0127)  UARTOUT_Start:
(0128) _UARTOUT_Start:
(0129)    or    A, bfCONTROL_REG_START_BIT
_UARTOUT_Start:
UARTOUT_Start:
    08F1: 29 01    OR    A,1
(0130)    mov   REG[UARTOUT_TX_CONTROL_REG], A
    08F3: 60 33    MOV   REG[51],A
(0131)    mov   REG[UARTOUT_RX_CONTROL_REG], A
    08F5: 60 37    MOV   REG[55],A
(0132)    ret	
    08F7: 7F       RET   
(0133) 
(0134) 
(0135) ;-----------------------------------------------------------------------------
(0136) ;  FUNCTION NAME: UARTOUT_Stop
(0137) ;
(0138) ;  DESCRIPTION:
(0139) ;     Disables UART operation.
(0140) ;
(0141) ;  ARGUMENTS:
(0142) ;     none.
(0143) ;
(0144) ;  RETURNS:
(0145) ;     none.
(0146) ;
(0147) ;  SIDE EFFECTS:
(0148) ;     none.
(0149) ;
(0150) ;  THEORY of OPERATION:  
(0151) ;     Clear the start bit in the Control registers.
(0152) ;
(0153) ;-----------------------------------------------------------------------------
(0154)  UARTOUT_Stop:
(0155) _UARTOUT_Stop:
(0156)    and   REG[UARTOUT_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
_UARTOUT_Stop:
UARTOUT_Stop:
    08F8: 41 33 FE AND   REG[51],254
(0157)    and   REG[UARTOUT_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
    08FB: 41 37 FE AND   REG[55],254
(0158)    ret	
    08FE: 7F       RET   
(0159) 
(0160) 
(0161) ;-----------------------------------------------------------------------------
(0162) ;  FUNCTION NAME: UARTOUT_SendData
(0163) ;
(0164) ;  DESCRIPTION:
(0165) ;     Initiates a transmission of data.
(0166) ;
(0167) ;  ARGUMENTS:
(0168) ;     BYTE  TxData - data to transmit. PASSED in A register.
(0169) ;
(0170) ;  RETURNS:
(0171) ;     none.
(0172) ;
(0173) ;  SIDE EFFECTS:
(0174) ;     none.
(0175) ;
(0176) ;  THEORY of OPERATION:  
(0177) ;     Writes data to the TX buffer register. 
(0178) ;
(0179) ;-----------------------------------------------------------------------------
(0180)  UARTOUT_SendData:
(0181) _UARTOUT_SendData:
(0182) 	mov REG[UARTOUT_TX_BUFFER_REG], A
_UARTOUT_SendData:
UARTOUT_SendData:
    08FF: 60 31    MOV   REG[49],A
(0183) 	ret
    0901: 7F       RET   
(0184) 
(0185) 
(0186) ;-----------------------------------------------------------------------------
(0187) ;  FUNCTION NAME: bUARTOUT_ReadTxStatus
(0188) ;
(0189) ;  DESCRIPTION:
(0190) ;     Reads the Tx Status bits in the Control/Status register.
(0191) ;
(0192) ;  ARGUMENTS:
(0193) ;     none.
(0194) ;
(0195) ;  RETURNS:
(0196) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
(0197) ;              stutus bits.
(0198) ;        returned in A.
(0199) ;
(0200) ;  SIDE EFFECTS:
(0201) ;     none.
(0202) ;
(0203) ;  THEORY of OPERATION:  
(0204) ;     Read TX status and control register.
(0205) ;
(0206) ;-----------------------------------------------------------------------------
(0207)  bUARTOUT_ReadTxStatus:
(0208) _bUARTOUT_ReadTxStatus:
(0209)  	mov A,  REG[UARTOUT_TX_CONTROL_REG]
_bUARTOUT_ReadTxStatus:
bUARTOUT_ReadTxStatus:
    0902: 5D 33    MOV   A,REG[51]
(0210) 	ret
    0904: 7F       RET   
(0211) 
(0212) 
(0213) ;-----------------------------------------------------------------------------
(0214) ;  FUNCTION NAME: bUARTOUT_ReadRxData
(0215) ;
(0216) ;  DESCRIPTION:
(0217) ;     Reads the RX buffer register.  Should check the status regiser to make
(0218) ;     sure data is valid.
(0219) ;
(0220) ;  ARGUMENTS:
(0221) ;     none.
(0222) ;
(0223) ;  RETURNS:
(0224) ;     bRxData - returned in A.
(0225) ;
(0226) ;  SIDE EFFECTS:
(0227) ;     none.
(0228) ;
(0229) ;  THEORY of OPERATION:  
(0230) ;     none.
(0231) ;
(0232) ;-----------------------------------------------------------------------------
(0233)  bUARTOUT_ReadRxData:
(0234) _bUARTOUT_ReadRxData:
(0235) 	mov A, REG[UARTOUT_RX_BUFFER_REG]
_bUARTOUT_ReadRxData:
bUARTOUT_ReadRxData:
    0905: 5D 36    MOV   A,REG[54]
(0236) 	ret
    0907: 7F       RET   
(0237) 
(0238) 
(0239) ;-----------------------------------------------------------------------------
(0240) ;  FUNCTION NAME: bUARTOUT_ReadRxStatus
(0241) ;
(0242) ;  DESCRIPTION:
(0243) ;     Reads the RX Status bits in the Control/Status register.
(0244) ;
(0245) ;  ARGUMENTS:
(0246) ;     none.
(0247) ;
(0248) ;  RETURNS:
(0249) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits 
(0250) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
(0251) ;     returned in A.
(0252) ;
(0253) ;  SIDE EFFECTS:
(0254) ;     none.
(0255) ;
(0256) ;  THEORY of OPERATION:  
(0257) ;     Read the status and control register.
(0258) ;
(0259) ;-----------------------------------------------------------------------------
(0260)  bUARTOUT_ReadRxStatus:
(0261) _bUARTOUT_ReadRxStatus:
(0262) 	mov A,  REG[UARTOUT_RX_CONTROL_REG]
_bUARTOUT_ReadRxStatus:
bUARTOUT_ReadRxStatus:
    0908: 5D 37    MOV   A,REG[55]
(0263) 	ret
    090A: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\UARTIN~1.ASM
(0001) ;------------------------------------------------------------------------------
(0002) ;  FILENAME:   UARTINint.asm
(0003) ;   VERSION:    Rev B, 2002 Mar 30
(0004) ;------------------------------------------------------------------------------
(0005) ;  DESCRIPTION:
(0006) ;     Interrupt handler routine for UART user module instance:
(0007) ;        UARTIN.
(0008) ;------------------------------------------------------------------------------
(0009) ;	Copyright (c) Cypress MicroSystems 2000-2002.  All Rights Reserved.
(0010) ;------------------------------------------------------------------------------
(0011) 
(0012) include  "UARTIN.inc"
(0013) 
(0014) area text (ROM, REL)
(0015) 
(0016) ;-----------------------------------------------------
(0017) ;  Export interrupt handler
(0018) ;     NOTE that interrupt handler is NOT exported
(0019) ;     for access by C function.  Interrupt handlers
(0020) ;     are not callable by C functions.
(0021) ;-----------------------------------------------------
(0022) export   UARTINTX_INT
(0023) export   UARTINRX_INT
(0024) 
(0025) ;-----------------------------------------------------------------------------
(0026) ;  FUNCTION NAME: UARTINTX_INT
(0027) ;
(0028) ;  DESCRIPTION:
(0029) ;     UART TX interrupt handler for instance UARTIN.  
(0030) ;
(0031) ;     This is a place holder function.  If the user requires use of an interrupt
(0032) ;     handler for this function, then place code where specified.
(0033) ;
(0034) ;  ARGUMENTS:
(0035) ;     none.
(0036) ;
(0037) ;  RETURNS:
(0038) ;     none.
(0039) ;
(0040) ;  SIDE EFFECTS:
(0041) ;     none.
(0042) ;
(0043) ;  THEORY of OPERATION:  
(0044) ;     none.
(0045) ;
(0046) ;-----------------------------------------------------------------------------
(0047) UARTINTX_INT:
(0048)    ;--------------------------
(0049)    ; Place user code here!!!
(0050)    ;--------------------------
(0051)    reti
UARTINTX_INT:
    090B: 7E       RETI  
(0052) 	
(0053) 
(0054) ;-----------------------------------------------------------------------------
(0055) ;  FUNCTION NAME: UARTINRX_INT
(0056) ;
(0057) ;  DESCRIPTION:
(0058) ;     UART RX interrupt handler for instance UARTIN.  
(0059) ;
(0060) ;     This is a place holder function.  If the user requires use of an interrupt
(0061) ;     handler for this function, then place code where specified.
(0062) ;
(0063) ;  ARGUMENTS:
(0064) ;     none.
(0065) ;
(0066) ;  RETURNS:
(0067) ;     none.
(0068) ;
(0069) ;  SIDE EFFECTS:
(0070) ;     none.
(0071) ;
(0072) ;  THEORY of OPERATION:  
(0073) ;     none.
(0074) ;
(0075) ;-----------------------------------------------------------------------------
(0076) UARTINRX_INT:
(0077)    ;--------------------------
(0078)    ; Place user code here!!!
(0079)    ;--------------------------
(0080)    reti
UARTINRX_INT:
    090C: 7E       RETI  
FILE: E:\CONTES~1\ENTRY201\LIB\UARTIN.ASM
(0001) ;------------------------------------------------------------------------------
UARTIN_EnableInt:
_UARTIN_EnableInt:
    090D: 43 E1 80 OR    REG[225],128
    0910: 43 E1 40 OR    REG[225],64
(0002) ;  FILENAME:   UARTIN.asm
(0003) ;   VERSION:   Rev B, 2002 Mar 30
(0004) ;------------------------------------------------------------------------------
(0005) ;  DESCRIPTION:
(0006) ;     UARTIN UART User Module API.
(0007) ;------------------------------------------------------------------------------
(0008) ;	Copyright (c) Cypress MicroSystems 2000-2002. All Rights Reserved.
(0009) ;------------------------------------------------------------------------------
(0010) 
(0011) ;-----------------------------------------------
(0012) ; include instance specific register definitions
(0013) ;-----------------------------------------------
(0014) include "m8c.inc"
(0015) include "UARTIN.inc"
(0016) 
(0017) area text (ROM, REL)
(0018) 
(0019) ;-------------------------------------------------------------------
(0020) ;  Declare the functions global for both assembler and C compiler.
(0021) ;
(0022) ;  Note that there are two names for each API. First name is 
(0023) ;  assembler reference. Name with underscore is name refence for
(0024) ;  C compiler.  Calling function in C source code does not require 
(0025) ;  the underscore.
(0026) ;-------------------------------------------------------------------
(0027) export   UARTIN_EnableInt
(0028) export  _UARTIN_EnableInt
(0029) export   UARTIN_DisableInt
(0030) export  _UARTIN_DisableInt
(0031) export   UARTIN_Start
(0032) export  _UARTIN_Start
(0033) export   UARTIN_Stop
(0034) export  _UARTIN_Stop
(0035) export   UARTIN_SendData
(0036) export  _UARTIN_SendData
(0037) export  bUARTIN_ReadTxStatus
(0038) export _bUARTIN_ReadTxStatus
(0039) export  bUARTIN_ReadRxData
(0040) export _bUARTIN_ReadRxData
(0041) export  bUARTIN_ReadRxStatus
(0042) export _bUARTIN_ReadRxStatus
(0043) 
(0044) ;-----------
(0045) ;  EQUATES
(0046) ;-----------
(0047) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit 
(0048) 
(0049) ;-----------------------------------------------------------------------------
(0050) ;  FUNCTION NAME: UARTIN_EnableInt
(0051) ;
(0052) ;  DESCRIPTION:
(0053) ;     Enables this UART's interrupt by setting the interrupt enable mask 
(0054) ;     bit associated with this User Module. Remember to call the global 
(0055) ;     interrupt enable function by using the macro: M8C_EnableGInt.
(0056) ;
(0057) ;  ARGUMENTS:
(0058) ;     none.
(0059) ;
(0060) ;  RETURNS:
(0061) ;     none.
(0062) ;
(0063) ;  SIDE EFFECTS:
(0064) ;     none.
(0065) ;
(0066) ;  THEORY of OPERATION:  
(0067) ;     Sets the specific user module interrupt enable mask bit in both the
(0068) ;     TX and RX blocks.
(0069) ;
(0070) ;-----------------------------------------------------------------------------
(0071)  UARTIN_EnableInt:
(0072) _UARTIN_EnableInt:
(0073)    M8C_EnableIntMask UARTIN_TX_INT_REG, bUARTIN_TX_INT_MASK
(0074)    M8C_EnableIntMask UARTIN_RX_INT_REG, bUARTIN_RX_INT_MASK
(0075)    ret	
    0913: 7F       RET   
_UARTIN_DisableInt:
UARTIN_DisableInt:
    0914: 5D FF    MOV   A,REG[255]
    0916: 70 FE    AND   F,254
    0918: 41 E1 7F AND   REG[225],127
    091B: 21 80    AND   A,128
    091D: A0 03    JZ    0x0921
    091F: 71 01    OR    F,1
    0921: 5D FF    MOV   A,REG[255]
    0923: 70 FE    AND   F,254
    0925: 41 E1 BF AND   REG[225],191
    0928: 21 80    AND   A,128
    092A: A0 03    JZ    0x092E
    092C: 71 01    OR    F,1
(0076) 
(0077) 	
(0078) ;-----------------------------------------------------------------------------
(0079) ;  FUNCTION NAME: UARTIN_DisableInt
(0080) ;
(0081) ;  DESCRIPTION:
(0082) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
(0083) ;     associated with this User Module. 
(0084) ;
(0085) ;  ARGUMENTS:
(0086) ;     none.
(0087) ;
(0088) ;  RETURNS:
(0089) ;     none.
(0090) ;
(0091) ;  SIDE EFFECTS:
(0092) ;     none.
(0093) ;
(0094) ;  THEORY of OPERATION:  
(0095) ;     Clears the specific user module interrupt enable mask bit in the TX
(0096) ;     and RX blocks.
(0097) ;
(0098) ;-----------------------------------------------------------------------------
(0099)  UARTIN_DisableInt:
(0100) _UARTIN_DisableInt:
(0101)    M8C_DisableIntMask UARTIN_TX_INT_REG, bUARTIN_TX_INT_MASK
(0102)    M8C_DisableIntMask UARTIN_RX_INT_REG, bUARTIN_RX_INT_MASK
(0103)    ret
    092E: 7F       RET   
(0104) 
(0105) 
(0106) ;-----------------------------------------------------------------------------
(0107) ;  FUNCTION NAME: UARTIN_Start(BYTE bParity)
(0108) ;
(0109) ;  DESCRIPTION:
(0110) ;     Sets the start bit and parity in the Control register of this user module. 
(0111) ;
(0112) ;  ARGUMENTS:
(0113) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
(0114) ;        Passed in the A register.
(0115) ;
(0116) ;  RETURNS:
(0117) ;     none.
(0118) ;
(0119) ;  SIDE EFFECTS:
(0120) ;     none.
(0121) ;
(0122) ;  THEORY of OPERATION:  
(0123) ;     Set the specified parity and start bits in the Control register of the 
(0124) ;     TX and RX blocks.
(0125) ;
(0126) ;-----------------------------------------------------------------------------
(0127)  UARTIN_Start:
(0128) _UARTIN_Start:
(0129)    or    A, bfCONTROL_REG_START_BIT
_UARTIN_Start:
UARTIN_Start:
    092F: 29 01    OR    A,1
(0130)    mov   REG[UARTIN_TX_CONTROL_REG], A
    0931: 60 3F    MOV   REG[63],A
(0131)    mov   REG[UARTIN_RX_CONTROL_REG], A
    0933: 60 3B    MOV   REG[59],A
(0132)    ret	
    0935: 7F       RET   
(0133) 
(0134) 
(0135) ;-----------------------------------------------------------------------------
(0136) ;  FUNCTION NAME: UARTIN_Stop
(0137) ;
(0138) ;  DESCRIPTION:
(0139) ;     Disables UART operation.
(0140) ;
(0141) ;  ARGUMENTS:
(0142) ;     none.
(0143) ;
(0144) ;  RETURNS:
(0145) ;     none.
(0146) ;
(0147) ;  SIDE EFFECTS:
(0148) ;     none.
(0149) ;
(0150) ;  THEORY of OPERATION:  
(0151) ;     Clear the start bit in the Control registers.
(0152) ;
(0153) ;-----------------------------------------------------------------------------
(0154)  UARTIN_Stop:
(0155) _UARTIN_Stop:
(0156)    and   REG[UARTIN_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
_UARTIN_Stop:
UARTIN_Stop:
    0936: 41 3F FE AND   REG[63],254
(0157)    and   REG[UARTIN_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
    0939: 41 3B FE AND   REG[59],254
(0158)    ret	
    093C: 7F       RET   
(0159) 
(0160) 
(0161) ;-----------------------------------------------------------------------------
(0162) ;  FUNCTION NAME: UARTIN_SendData
(0163) ;
(0164) ;  DESCRIPTION:
(0165) ;     Initiates a transmission of data.
(0166) ;
(0167) ;  ARGUMENTS:
(0168) ;     BYTE  TxData - data to transmit. PASSED in A register.
(0169) ;
(0170) ;  RETURNS:
(0171) ;     none.
(0172) ;
(0173) ;  SIDE EFFECTS:
(0174) ;     none.
(0175) ;
(0176) ;  THEORY of OPERATION:  
(0177) ;     Writes data to the TX buffer register. 
(0178) ;
(0179) ;-----------------------------------------------------------------------------
(0180)  UARTIN_SendData:
(0181) _UARTIN_SendData:
(0182) 	mov REG[UARTIN_TX_BUFFER_REG], A
UARTIN_SendData:
_UARTIN_SendData:
    093D: 60 3D    MOV   REG[61],A
(0183) 	ret
    093F: 7F       RET   
(0184) 
(0185) 
(0186) ;-----------------------------------------------------------------------------
(0187) ;  FUNCTION NAME: bUARTIN_ReadTxStatus
(0188) ;
(0189) ;  DESCRIPTION:
(0190) ;     Reads the Tx Status bits in the Control/Status register.
(0191) ;
(0192) ;  ARGUMENTS:
(0193) ;     none.
(0194) ;
(0195) ;  RETURNS:
(0196) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
(0197) ;              stutus bits.
(0198) ;        returned in A.
(0199) ;
(0200) ;  SIDE EFFECTS:
(0201) ;     none.
(0202) ;
(0203) ;  THEORY of OPERATION:  
(0204) ;     Read TX status and control register.
(0205) ;
(0206) ;-----------------------------------------------------------------------------
(0207)  bUARTIN_ReadTxStatus:
(0208) _bUARTIN_ReadTxStatus:
(0209)  	mov A,  REG[UARTIN_TX_CONTROL_REG]
_bUARTIN_ReadTxStatus:
bUARTIN_ReadTxStatus:
    0940: 5D 3F    MOV   A,REG[63]
(0210) 	ret
    0942: 7F       RET   
(0211) 
(0212) 
(0213) ;-----------------------------------------------------------------------------
(0214) ;  FUNCTION NAME: bUARTIN_ReadRxData
(0215) ;
(0216) ;  DESCRIPTION:
(0217) ;     Reads the RX buffer register.  Should check the status regiser to make
(0218) ;     sure data is valid.
(0219) ;
(0220) ;  ARGUMENTS:
(0221) ;     none.
(0222) ;
(0223) ;  RETURNS:
(0224) ;     bRxData - returned in A.
(0225) ;
(0226) ;  SIDE EFFECTS:
(0227) ;     none.
(0228) ;
(0229) ;  THEORY of OPERATION:  
(0230) ;     none.
(0231) ;
(0232) ;-----------------------------------------------------------------------------
(0233)  bUARTIN_ReadRxData:
(0234) _bUARTIN_ReadRxData:
(0235) 	mov A, REG[UARTIN_RX_BUFFER_REG]
_bUARTIN_ReadRxData:
bUARTIN_ReadRxData:
    0943: 5D 3A    MOV   A,REG[58]
(0236) 	ret
    0945: 7F       RET   
(0237) 
(0238) 
(0239) ;-----------------------------------------------------------------------------
(0240) ;  FUNCTION NAME: bUARTIN_ReadRxStatus
(0241) ;
(0242) ;  DESCRIPTION:
(0243) ;     Reads the RX Status bits in the Control/Status register.
(0244) ;
(0245) ;  ARGUMENTS:
(0246) ;     none.
(0247) ;
(0248) ;  RETURNS:
(0249) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits 
(0250) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
(0251) ;     returned in A.
(0252) ;
(0253) ;  SIDE EFFECTS:
(0254) ;     none.
(0255) ;
(0256) ;  THEORY of OPERATION:  
(0257) ;     Read the status and control register.
(0258) ;
(0259) ;-----------------------------------------------------------------------------
(0260)  bUARTIN_ReadRxStatus:
(0261) _bUARTIN_ReadRxStatus:
(0262) 	mov A,  REG[UARTIN_RX_CONTROL_REG]
_bUARTIN_ReadRxStatus:
bUARTIN_ReadRxStatus:
    0946: 5D 3B    MOV   A,REG[59]
(0263) 	ret
    0948: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\SINGLE~1.ASM
(0001) ;;**********************************************************************
(0002) ;;**********************************************************************
(0003) ;;
(0004) ;; PGA_A.ASM
(0005) ;;
(0006) ;; Assembler source for Programmable Gain Amplifier PGA_A
(0007) ;;
(0008) ;; Rev B, 2002 Mar 30
(0009) ;;
(0010) ;; Copyright (c) 2001-2002 Cypress Microsystems, Inc. All rights reserved.
(0011) ;;
(0012) ;;**********************************************************************
(0013) ;;**********************************************************************
(0014) ;;
(0015) 
(0016) 
(0017) export  SingleEnded_Start
(0018) export _SingleEnded_Start
(0019) export  SingleEnded_SetPower
(0020) export _SingleEnded_SetPower
(0021) 
(0022) export  SingleEnded_SetGain
(0023) export _SingleEnded_SetGain
(0024) 
(0025) export  SingleEnded_Stop
(0026) export _SingleEnded_Stop
(0027) 
(0028) ;; -----------------------------------------------------------------
(0029) ;;                         Register Definitions
(0030) ;;
(0031) ;; Uses 1 Continuous Time Block configured as shown. 
(0032) ;;
(0033) ;; * For a Mask/Val pair, this indicates that the value is
(0034) ;;   determined by the user either through config-time parameteriza-
(0035) ;;   tion or run-time manipulation.
(0036) ;;
(0037) ;; BIT FIELD	         Mask/Val Function
(0038) ;; -----------------    	----- 	--------------------
(0039) ;; GAIN_CR0.RES_RATIO_T2B	F0/*	User Parameter (by table)
(0040) ;; GAIN_CR0.GAIN_ATTEN		08/*	Gain (by table)
(0041) ;; GAIN_CR0.RES_SOURCE		04/1	Res source to output
(0042) ;; GAIN_CR0.RES_REF		03/*	Res ref 
(0043) ;;
(0044) ;; GAIN_CR1.A_OUT		80/*	User Parameter (Output bus)
(0045) ;; GAIN_CR1.COMP_EN		40/0	Comparator bus disabled
(0046) ;; GAIN_CR1.CT_NEG_INPUT_MUX	38/4	Neg mux to analog f.b. tap
(0047) ;; GAIN_CR1.CT_POS_INPUT_MUX	07/*	Pos mux, typically to col. input mux
(0048) ;;
(0049) ;; GAIN_CR2.CP_COMP		80/0	Latch transparent on PH1
(0050) ;; GAIN_CR2.CK_COMP		40/0	Latch transparent
(0051) ;; GAIN_CR2.CC_COMP		20/1	Mode OP-AMP (not comparator)
(0052) ;; GAIN_CR2.BYPASS_OBUS		1C/0	Bypass OFF
(0053) ;; GAIN_CR2.PWR_SELECT		03/*	Power OFF (0h) at start-up
(0054) ;;
(0055) ;; --------------------------------------------------------------------
(0056) 
(0057) include "SingleEnded.inc"
(0058) include "m8c.inc"
(0059) POWERMASK: equ 03h
(0060) GAINMASK: equ f8h
(0061) ;;---------------------------------------------------------------------
(0062) ;; StartSetPower:  Applies power setting to the module's PSoC block
(0063) ;; SetPower: Applies power setting to the module's PSoC block
(0064) ;; INPUTS: A contains the power setting 0=Off, 1=Low, 2=Med, 3=High
(0065) ;;         Value is loaded from .inc file
(0066) ;; OUTPUTS: None
(0067) ;;---------------------------------------------------------------------
(0068)  SingleEnded_Start:
(0069) _SingleEnded_Start:
(0070)  SingleEnded_SetPower:
(0071) _SingleEnded_SetPower:
(0072) 
(0073)     and A, POWERMASK                         ; mask A to protect unchanged bits
_SingleEnded_SetPower:
SingleEnded_SetPower:
_SingleEnded_Start:
SingleEnded_Start:
    0949: 21 03    AND   A,3
(0074)     mov X, SP                                ; define temp store location
    094B: 4F       MOV   X,SP
(0075) ;
(0076)     push A                                   ; put power value in temp store
    094C: 08       PUSH  A
(0077)     mov A, reg[SingleEnded_GAIN_CR2]    ; read power value
    094D: 5D 7B    MOV   A,REG[123]
(0078)     and A, ~POWERMASK                        ; clear power bits in A
    094F: 21 FC    AND   A,252
(0079)     or  A, [X]                               ; combine power value with balance of reg.
    0951: 2B 00    OR    A,[X+0]
(0080)     mov reg[SingleEnded_GAIN_CR2], A    ; move complete value back to register
    0953: 60 7B    MOV   REG[123],A
(0081)     pop A
    0955: 18       POP   A
(0082)     ret
    0956: 7F       RET   
(0083) 
(0084) ;;---------------------------------------------------------------------------------
(0085) ;;	SetGain:
(0086) ;;	INPUTS: Gain value and GAIN/ATTEN setting
(0087) ;;		  Use gain set values from .inc file
(0088) ;;	OUTPUTS: None
(0089) ;;	Side Effects: Momentary gain glitch while gain set to 1.0, then to new value
(0090) ;;
(0091) ;;	Gain values shown are for example
(0092) ;;	16.0	1	0 0 0 0			
(0093) ;;	8.00	1	0 0 0 1
(0094) ;;	....
(0095) ;;	1.00	1	1 1 1 1
(0096) ;;	0.93	0	1 1 1 0
(0097) ;;	....
(0098) ;;	0.12	0	0 0 0 1
(0099) ;;	0.06	0	0 0 0 0
(0100) ;;--------------------------------------------------------------------------------
(0101)  SingleEnded_SetGain:
(0102) _SingleEnded_SetGain:
(0103) 
(0104)     and A, GAINMASK                          ; mask A to protect unchanged bits
_SingleEnded_SetGain:
SingleEnded_SetGain:
    0957: 21 F8    AND   A,248
(0105)     mov X, SP                                ; define temp store location
    0959: 4F       MOV   X,SP
(0106) ;
(0107)     push A                                   ; put gain value in temp store
    095A: 08       PUSH  A
(0108)     mov A, reg[SingleEnded_GAIN_CR0]    ; read power value
    095B: 5D 79    MOV   A,REG[121]
(0109)     and A, ~GAINMASK                         ; clear gain bits in A
    095D: 21 07    AND   A,7
(0110)     or  A, [X]                               ; combine gain value with balance of reg.
    095F: 2B 00    OR    A,[X+0]
(0111)     mov reg[SingleEnded_GAIN_CR0], A    ; move complete value back to register
    0961: 60 79    MOV   REG[121],A
(0112)     pop A
    0963: 18       POP   A
(0113)     ret
    0964: 7F       RET   
(0114) 
(0115) ;;---------------------------------------------------------------------
(0116) ;; Stop:  Cuts power to the user module
(0117) ;;
(0118) ;; INPUTS: None
(0119) ;; OUPTUTS: None
(0120) ;;---------------------------------------------------------------------
(0121)  SingleEnded_Stop:
(0122) _SingleEnded_Stop:
(0123) 
(0124)     and REG[SingleEnded_GAIN_CR2], ~POWERMASK
SingleEnded_Stop:
_SingleEnded_Stop:
    0965: 41 7B FC AND   REG[123],252
(0125)     ret
    0968: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\SAMPLE~2.ASM
(0001) ;------------------------------------------------------------------------------
(0002) ;  FILENAME:   SampleCLKint.asm
(0003) ;   VERSION:   REV B, 2002 Mar 30
(0004) ;------------------------------------------------------------------------------
(0005) ;  DESCRIPTION:
(0006) ;     Interrupt handler routine for Counter8 user module instance:
(0007) ;        SampleCLK.
(0008) ;------------------------------------------------------------------------------
(0009) ;	Copyright (c) Cypress MicroSystems 2000-2002.  All Rights Reserved.
(0010) ;------------------------------------------------------------------------------
(0011) 
(0012) include  "SampleCLK.inc"
(0013) 
(0014) ;-----------------------------------------------------
(0015) ;  Export interrupt handler
(0016) ;     NOTE that interrupt handler is NOT exported
(0017) ;     for access by C function.  Interrupt handlers
(0018) ;     are not callable by C functions.
(0019) ;-----------------------------------------------------
(0020) export   SampleCLKINT
(0021) 
(0022) ;-----------------------------------------------------------------------------
(0023) ;  FUNCTION NAME: SampleCLKInt
(0024) ;
(0025) ;  DESCRIPTION:
(0026) ;     Counter8 interrupt handler for instance SampleCLK.  
(0027) ;
(0028) ;     This is a place holder function.  If the user requires use of an interrupt
(0029) ;     handler for this function, then place code where specified.
(0030) ;
(0031) ;  ARGUMENTS:
(0032) ;     none.
(0033) ;
(0034) ;  RETURNS:
(0035) ;     none.
(0036) ;
(0037) ;  SIDE EFFECTS:
(0038) ;     none.
(0039) ;
(0040) ;  THEORY of OPERATION:  
(0041) ;     none.
(0042) ;
(0043) ;-----------------------------------------------------------------------------
(0044) SampleCLKINT:
(0045)    ;--------------------------
(0046)    ; Place user code here!!!
(0047)    ;--------------------------
(0048)    reti
SampleCLKINT:
    0969: 7E       RETI  
FILE: E:\CONTES~1\ENTRY201\LIB\SAMPLE~1.ASM
(0001) ;------------------------------------------------------------------------------
_SampleCLK_EnableInt:
SampleCLK_EnableInt:
    096A: 43 E1 08 OR    REG[225],8
(0002) ;  FILENAME:   SampleCLK.asm
(0003) ;   VERSION:   Rev B, 2002 Mar 30
(0004) ;------------------------------------------------------------------------------
(0005) ;  DESCRIPTION:
(0006) ;     SampleCLK Counter8 User Module API.
(0007) ;------------------------------------------------------------------------------
(0008) ;	Copyright (c) Cypress MicroSystems 2000-2002. All Rights Reserved.
(0009) ;------------------------------------------------------------------------------
(0010) 
(0011) ;-----------------------------------------------
(0012) ; include instance specific register definitions
(0013) ;-----------------------------------------------
(0014) include "m8c.inc"
(0015) include "SampleCLK.inc"
(0016) 
(0017) area text (ROM, REL)
(0018) 
(0019) ;-------------------------------------------------------------------
(0020) ;  Declare the functions global for both assembler and C compiler.
(0021) ;
(0022) ;  Note that there are two names for each API. First name is 
(0023) ;  assembler reference. Name with underscore is name refence for
(0024) ;  C compiler.  Calling function in C source code does not require 
(0025) ;  the underscore.
(0026) ;-------------------------------------------------------------------
(0027) export   SampleCLK_EnableInt
(0028) export  _SampleCLK_EnableInt
(0029) export   SampleCLK_DisableInt
(0030) export  _SampleCLK_DisableInt
(0031) export   SampleCLK_Start
(0032) export  _SampleCLK_Start
(0033) export   SampleCLK_Stop
(0034) export  _SampleCLK_Stop
(0035) export   SampleCLK_WritePeriod
(0036) export  _SampleCLK_WritePeriod
(0037) export   SampleCLK_WriteCompareValue
(0038) export  _SampleCLK_WriteCompareValue
(0039) export   bSampleCLK_ReadCompareValue
(0040) export  _bSampleCLK_ReadCompareValue
(0041) export   bSampleCLK_ReadCounter
(0042) export  _bSampleCLK_ReadCounter
(0043) 
(0044) ;-----------
(0045) ;  EQUATES
(0046) ;-----------
(0047) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit 
(0048) bfINPUT_REG_CLOCK_MASK:    equ   0Fh   ; input register clock mask
(0049) 
(0050) ;-----------------------------------------------------------------------------
(0051) ;  FUNCTION NAME: SampleCLK_EnableInt
(0052) ;
(0053) ;  DESCRIPTION:
(0054) ;     Enables this counter's interrupt by setting the interrupt enable mask bit
(0055) ;     associated with this User Module. Remember to call the global interrupt
(0056) ;     enable function by using the macro: M8C_EnableGInt.
(0057) ;
(0058) ;  ARGUMENTS:
(0059) ;     none.
(0060) ;
(0061) ;  RETURNS:
(0062) ;     none.
(0063) ;
(0064) ;  SIDE EFFECTS:
(0065) ;     none.
(0066) ;
(0067) ;  THEORY of OPERATION:  
(0068) ;     Sets the specific user module interrupt enable mask bit.
(0069) ;
(0070) ;-----------------------------------------------------------------------------
(0071)  SampleCLK_EnableInt:
(0072) _SampleCLK_EnableInt:
(0073)    M8C_EnableIntMask SampleCLK_INT_REG, bSampleCLK_INT_MASK
(0074)    ret	
    096D: 7F       RET   
_SampleCLK_DisableInt:
SampleCLK_DisableInt:
    096E: 5D FF    MOV   A,REG[255]
    0970: 70 FE    AND   F,254
    0972: 41 E1 F7 AND   REG[225],247
    0975: 21 80    AND   A,128
    0977: A0 03    JZ    0x097B
    0979: 71 01    OR    F,1
(0075) 
(0076) 	
(0077) ;-----------------------------------------------------------------------------
(0078) ;  FUNCTION NAME: SampleCLK_DisableInt
(0079) ;
(0080) ;  DESCRIPTION:
(0081) ;     Disables this counter's interrupt by clearing the interrupt enable mask bit
(0082) ;     associated with this User Module. 
(0083) ;
(0084) ;  ARGUMENTS:
(0085) ;     none.
(0086) ;
(0087) ;  RETURNS:
(0088) ;     none.
(0089) ;
(0090) ;  SIDE EFFECTS:
(0091) ;     none.
(0092) ;
(0093) ;  THEORY of OPERATION:  
(0094) ;     Clears the specific user module interrupt enable mask bit.
(0095) ;
(0096) ;-----------------------------------------------------------------------------
(0097)  SampleCLK_DisableInt:
(0098) _SampleCLK_DisableInt:
(0099)    
(0100)    M8C_DisableIntMask SampleCLK_INT_REG, bSampleCLK_INT_MASK
(0101)    ret
    097B: 7F       RET   
(0102) 
(0103) 
(0104) ;-----------------------------------------------------------------------------
(0105) ;  FUNCTION NAME: SampleCLK_Start
(0106) ;
(0107) ;  DESCRIPTION:
(0108) ;     Sets the start bit in the Control register of this user module.  The
(0109) ;     counter will begin counting on the next input clock as soon as the 
(0110) ;     enable input is asserted high.
(0111) ;
(0112) ;  ARGUMENTS:
(0113) ;     none.
(0114) ;
(0115) ;  RETURNS:
(0116) ;     none.
(0117) ;
(0118) ;  SIDE EFFECTS:
(0119) ;     none.
(0120) ;
(0121) ;  THEORY of OPERATION:  
(0122) ;     Set the start bit in the Control register.
(0123) ;
(0124) ;-----------------------------------------------------------------------------
(0125)  SampleCLK_Start:
(0126) _SampleCLK_Start:
(0127)    or    REG[SampleCLK_CONTROL_REG], bfCONTROL_REG_START_BIT
_SampleCLK_Start:
SampleCLK_Start:
    097C: 43 2F 01 OR    REG[47],1
(0128)    ret	
    097F: 7F       RET   
(0129) 
(0130) 
(0131) ;-----------------------------------------------------------------------------
(0132) ;  FUNCTION NAME: SampleCLK_Stop
(0133) ;
(0134) ;  DESCRIPTION:
(0135) ;     Disables counter operation.
(0136) ;
(0137) ;  ARGUMENTS:
(0138) ;     none.
(0139) ;
(0140) ;  RETURNS:
(0141) ;     none.
(0142) ;
(0143) ;  SIDE EFFECTS:
(0144) ;     After this function completes, the Count register will latch any data
(0145) ;     written to the Period register.  Writing to the Period register is 
(0146) ;     performed using the SampleCLK_WritePeriod function.
(0147) ;
(0148) ;  THEORY of OPERATION:  
(0149) ;     Clear the start bit in the Control register.
(0150) ;
(0151) ;-----------------------------------------------------------------------------
(0152)  SampleCLK_Stop:
(0153) _SampleCLK_Stop:
(0154)    and   REG[SampleCLK_CONTROL_REG], ~bfCONTROL_REG_START_BIT
_SampleCLK_Stop:
SampleCLK_Stop:
    0980: 41 2F FE AND   REG[47],254
(0155)    ret	
    0983: 7F       RET   
(0156) 
(0157) 
(0158) ;-----------------------------------------------------------------------------
(0159) ;  FUNCTION NAME: SampleCLK_WritePeriod
(0160) ;
(0161) ;  DESCRIPTION:
(0162) ;     Write the period value into the Period register.
(0163) ;
(0164) ;  ARGUMENTS:
(0165) ;     BYTE  bPeriodValue - period count - passed in the Accumulator.
(0166) ;
(0167) ;  RETURNS:
(0168) ;     none.
(0169) ;
(0170) ;  SIDE EFFECTS:
(0171) ;     If the counter user module is stopped, then this value will also be
(0172) ;     latched into the Count register.
(0173) ;
(0174) ;  THEORY of OPERATION:  
(0175) ;     Write data into the Period register.
(0176) ;
(0177) ;-----------------------------------------------------------------------------
(0178)  SampleCLK_WritePeriod:
(0179) _SampleCLK_WritePeriod:
(0180)    tst   REG[SampleCLK_CONTROL_REG], bfCONTROL_REG_START_BIT
_SampleCLK_WritePeriod:
SampleCLK_WritePeriod:
    0984: 49 2F 01 TST   REG[47],1
(0181)    jnz   .CounterRunning
    0987: B0 19    JNZ   0x09A1
(0182) 
(0183) ; Counter is stopped.  Due to chip errata, we have to set the clock low for
(0184) ; the write to the period register to cause the data to be immediately transferred
(0185) ; into the Counter.
(0186) .CounterStopped:
(0187)    push  X
    0989: 10       PUSH  X
(0188)    mov   X, A                                   ; save the period argument
    098A: 5C       MOV   X,A
    098B: 71 10    OR    F,16
(0189)    M8C_SetBank1
(0190)    mov   A, REG[SampleCLK_INPUT_REG]             ; save the context of the clock - input register
    098D: 5D 2D    MOV   A,REG[45]
(0191)    push  A
    098F: 08       PUSH  A
(0192)    and   REG[SampleCLK_INPUT_REG], F0h           ; set the clock signal low
    0990: 41 2D F0 AND   REG[45],240
    0993: 70 EF    AND   F,239
(0193)    M8C_SetBank0
(0194)    mov   A, X                                      
    0995: 5B       MOV   A,X
(0195)    mov   REG[SampleCLK_PERIOD_REG], A                ; set the period register with the new period
    0996: 60 2D    MOV   REG[45],A
(0196)    pop   A
    0998: 18       POP   A
    0999: 71 10    OR    F,16
(0197)    M8C_SetBank1
(0198)    mov   REG[SampleCLK_INPUT_REG], A             ; restore the clock
    099B: 60 2D    MOV   REG[45],A
    099D: 70 EF    AND   F,239
(0199)    M8C_SetBank0
(0200)    pop   X
    099F: 20       POP   X
(0201)    ret
    09A0: 7F       RET   
(0202) 
(0203) ; Counter is running - write the period into the period register.
(0204) ; Upon Terminal Count this value will get loaded into the counter.
(0205) .CounterRunning:
(0206)    mov   REG[SampleCLK_PERIOD_REG], A
    09A1: 60 2D    MOV   REG[45],A
(0207)    ret
    09A3: 7F       RET   
(0208) 
(0209) 
(0210) ;-----------------------------------------------------------------------------
(0211) ;  FUNCTION NAME: SampleCLK_WriteCompareValue
(0212) ;
(0213) ;  DESCRIPTION:
(0214) ;     Writes compare value into the CompareValue register.
(0215) ;
(0216) ;  ARGUMENTS:
(0217) ;     BYTE  bCompareValue - compare value count - passed in Accumulator.
(0218) ;
(0219) ;  RETURNS:
(0220) ;     none.
(0221) ;
(0222) ;  SIDE EFFECTS:
(0223) ;     none.
(0224) ;
(0225) ;  THEORY of OPERATION:  
(0226) ;     Write data into the CompareValue register.
(0227) ;
(0228) ;-----------------------------------------------------------------------------
(0229)  SampleCLK_WriteCompareValue:
(0230) _SampleCLK_WriteCompareValue:
(0231)    mov   REG[SampleCLK_COMPARE_REG], A
_SampleCLK_WriteCompareValue:
SampleCLK_WriteCompareValue:
    09A4: 60 2E    MOV   REG[46],A
(0232)    ret
    09A6: 7F       RET   
(0233) 
(0234) 
(0235) ;-----------------------------------------------------------------------------
(0236) ;  FUNCTION NAME: bSampleCLK_ReadCompareValue
(0237) ;
(0238) ;  DESCRIPTION:
(0239) ;     Reads the CompareValue register.
(0240) ;
(0241) ;  ARGUMENTS:
(0242) ;     none.
(0243) ;
(0244) ;  RETURNS:
(0245) ;     BYTE  bCompareValue - value read from CompareValue register - returned
(0246) ;                           in the Accumulator.
(0247) ;
(0248) ;  SIDE EFFECTS:
(0249) ;     none.
(0250) ;
(0251) ;  THEORY of OPERATION:  
(0252) ;     Read the CompareValue register and return value in A.
(0253) ;
(0254) ;-----------------------------------------------------------------------------
(0255)  bSampleCLK_ReadCompareValue:
(0256) _bSampleCLK_ReadCompareValue:
(0257)    mov   A, REG[SampleCLK_COMPARE_REG]
_bSampleCLK_ReadCompareValue:
bSampleCLK_ReadCompareValue:
    09A7: 5D 2E    MOV   A,REG[46]
(0258)    ret
    09A9: 7F       RET   
bSampleCLK_ReadCounter:
_bSampleCLK_ReadCounter:
    09AA: 71 10    OR    F,16
(0259) 
(0260) 
(0261) ;-----------------------------------------------------------------------------
(0262) ;  FUNCTION NAME: bSampleCLK_ReadCounter
(0263) ;
(0264) ;  DESCRIPTION:
(0265) ;     Reads the count in the Count register.
(0266) ;
(0267) ;  ARGUMENTS:
(0268) ;     none.
(0269) ;
(0270) ;  RETURNS:
(0271) ;     BYTE  bCount - current count value in Count register.
(0272) ;
(0273) ;  SIDE EFFECTS:
(0274) ;     Reading the Count register may cause the Count register to miss
(0275) ;     one or more counts due to the fact that the clock is stopped while
(0276) ;     the Count register is read.  The preferred method is to use the 
(0277) ;     interrupt feature to determine when the Count has arrived at a 
(0278) ;     specified value.
(0279) ;
(0280) ;  THEORY of OPERATION:  
(0281) ;     Reading the Count register causes its value to be latched into the 
(0282) ;     CompareValue register.  Care must be taken to stop the clock and save 
(0283) ;     the CompareValue register's contents before reading the Count.
(0284) ;
(0285) ;-----------------------------------------------------------------------------
(0286)  bSampleCLK_ReadCounter:
(0287) _bSampleCLK_ReadCounter:
(0288) 
(0289)    ; save the input register clock setting
(0290)    M8C_SetBank1
(0291)    mov   A, REG[SampleCLK_INPUT_REG]
    09AC: 5D 2D    MOV   A,REG[45]
(0292)    push  A
    09AE: 08       PUSH  A
(0293)    ; disable the clock
(0294)    and   REG[SampleCLK_INPUT_REG], ~bfINPUT_REG_CLOCK_MASK
    09AF: 41 2D F0 AND   REG[45],240
    09B2: 70 EF    AND   F,239
(0295)    M8C_SetBank0
(0296) 
(0297)    ; save the CompareValue register value
(0298)    mov   A, REG[SampleCLK_COMPARE_REG]    
    09B4: 5D 2E    MOV   A,REG[46]
(0299)    push  A
    09B6: 08       PUSH  A
(0300)    ; Read the counter. This latches the counter data into
(0301)    ; the CompareValue register.  This may cause an interrupt.
(0302)    mov   A, REG[SampleCLK_COUNTER_REG]    
    09B7: 5D 2C    MOV   A,REG[44]
(0303)    ; Read the CompareValue register, which contains the counter value
(0304)    mov   A, REG[SampleCLK_COMPARE_REG]    
    09B9: 5D 2E    MOV   A,REG[46]
(0305)    ; Save the Count value in X
(0306)    mov   X, A
    09BB: 5C       MOV   X,A
(0307)    ; Restore the CompareValue register
(0308)    pop   A
    09BC: 18       POP   A
(0309)    mov   REG[SampleCLK_COMPARE_REG], A
    09BD: 60 2E    MOV   REG[46],A
    09BF: 71 10    OR    F,16
(0310) 
(0311)    ; restore the input register clock setting
(0312)    M8C_SetBank1
(0313)    pop   A
    09C1: 18       POP   A
(0314)    mov   REG[SampleCLK_INPUT_REG], A
    09C2: 60 2D    MOV   REG[45],A
    09C4: 70 EF    AND   F,239
(0315)    M8C_SetBank0
(0316) 
(0317)    ; Get the saved read counter value
(0318)    mov   A, X
    09C6: 5B       MOV   A,X
(0319) 
(0320)    ret
    09C7: 7F       RET   
LoadConfigTBL_entry201_Bank1:
    09C8: 61 13    MOV   REG[X+19],A
    09CA: 60 EF    MOV   REG[239],A
    09CC: 62 00 63 MOV   REG[0],99
    09CF: 00       SSC   
    09D0: E1 00    JACC  0x0AD1
    09D2: 00       SSC   
    09D3: 00       SSC   
    09D4: 01 FF    ADD   A,255
    09D6: 02 00    ADD   A,[0]
    09D8: 03 00    ADD   A,[X+0]
    09DA: 04 A0    ADD   [160],A
    09DC: 05 5F    ADD   [X+95],A
    09DE: 06 00 07 ADD   [0],7
    09E1: 00       SSC   
    09E2: 08       PUSH  A
    09E3: 00       SSC   
    09E4: 09 00    ADC   A,0
    09E6: 0A 00    ADC   A,[0]
    09E8: 0B 00    ADC   A,[X+0]
    09EA: 0C 00    ADC   [0],A
    09EC: 0D 00    ADC   [X+0],A
    09EE: 0E 00 0F ADC   [0],15
    09F1: 00       SSC   
    09F2: 10       PUSH  X
    09F3: 00       SSC   
    09F4: 11 00    SUB   A,0
    09F6: 12 00    SUB   A,[0]
    09F8: 13 00    SUB   A,[X+0]
    09FA: 14 00    SUB   [0],A
    09FC: 15 00    SUB   [X+0],A
    09FE: 16 00 17 SUB   [0],23
    0A01: 00       SSC   
    0A02: E3 84    JACC  0x0D87
    0A04: 24 21    AND   [33],A
    0A06: 25 62    AND   [X+98],A
    0A08: 26 00 20 AND   [0],32
    0A0B: 20       POP   X
    0A0C: 21 12    AND   A,18
    0A0E: 22 00    AND   A,[0]
    0A10: 28       ROMX  
    0A11: 31 29    XOR   A,41
    0A13: 15 2A    SUB   [X+42],A
    0A15: 04 2C    ADD   [44],A
    0A17: 31 2D    XOR   A,45
    0A19: 15 2E    SUB   [X+46],A
    0A1B: 00       SSC   
    0A1C: 38 05    ADD   SP,5
    0A1E: 39 C1    CMP   A,193
    0A20: 3A 00    CMP   A,[0]
    0A22: 3C 0D 3D CMP   [13],61
    0A25: 01 3E    ADD   A,62
    0A27: 05 34    ADD   [X+52],A
    0A29: 05 35    ADD   [X+53],A
    0A2B: E1 36    JACC  0x0B62
    0A2D: 00       SSC   
    0A2E: 30       HALT  
    0A2F: 0D 31    ADC   [X+49],A
    0A31: 01 32    ADD   A,50
    0A33: 07 FF 60 ADD   [X-1],96
    0A36: 28       ROMX  
    0A37: 63 05 65 MOV   REG[X+5],101
    0A3A: 00       SSC   
    0A3B: E6 00    JACC  0x103C
    0A3D: 02 00    ADD   A,[0]
    0A3F: 01 00    ADD   A,0
    0A41: 06 F0 05 ADD   [240],5
    0A44: 00       SSC   
    0A45: 0A 00    ADC   A,[0]
    0A47: 09 00    ADC   A,0
    0A49: 0E 00 0D ADC   [0],13
    0A4C: 00       SSC   
    0A4D: 12 00    SUB   A,[0]
    0A4F: 11 00    SUB   A,0
    0A51: 16 00 15 SUB   [0],21
    0A54: 00       SSC   
    0A55: 88 90    JMP   0x02E6
    0A57: 89 00    JMP   0x0358
    0A59: 8A 60    JMP   0x04BA
    0A5B: 8B F0    JMP   0x064C
    0A5D: 27 00 25 AND   [X+0],37
    0A60: 00       SSC   
    0A61: 26 00 23 AND   [0],35
    0A64: 00       SSC   
    0A65: 21 00    AND   A,0
    0A67: 22 00    AND   A,[0]
    0A69: 2B 00    OR    A,[X+0]
    0A6B: 29 9C    OR    A,156
    0A6D: 2A 4E    OR    A,[78]
    0A6F: 9C 80    CALL  0x06F1
    0A71: 9D 40    CALL  0x07B3
    0A73: 9E A0    CALL  0x0915
    0A75: 9F 30    CALL  _bSampleCLK_ReadCompareValue
    0A77: 90 80    CALL  0x0AF9
    0A79: 91 80    CALL  0x0BFB
    0A7B: 92 A0    CALL  0x0D1D
    0A7D: 93 30    CALL  0x0DAF
    0A7F: 98 80    CALL  0x0301
    0A81: 99 80    CALL  0x0403
    0A83: 9A A0    CALL  0x0525
    0A85: 9B 30    CALL  0x05B7
    0A87: 94 80    CALL  0x0F09
    0A89: 95 40    CALL  0x0FCB
    0A8B: 96 A0    CALL  0x112D
    0A8D: 97 30    CALL  0x11BF
    0A8F: 71 7D    OR    F,125
    0A91: 72 21    XOR   F,33
    0A93: 73       CPL   A
    0A94: 20       POP   X
    0A95: 75       INC   X
    0A96: 7C 76 21 LCALL 0x7621
    0A99: 77 20    INC   [X+32]
    0A9B: 7D 7C 7E LJMP  0x7C7E
    0A9E: 23 7F    AND   A,[X+127]
    0AA0: 20       POP   X
    0AA1: 2F 00 2D OR    [X+0],45
    0AA4: 9C 2E    CALL  0x06D4
    0AA6: 4E       SWAP  SP,A
    0AA7: 79       DEC   X
    0AA8: FD 7A    INDEX 0x0824
    0AAA: 21 7B    AND   A,123
    0AAC: 20       POP   X
    0AAD: 3B 00    CMP   A,[X+0]
    0AAF: 39 00    CMP   A,0
    0AB1: 3A 00    CMP   A,[0]
    0AB3: 3F 00    MVI   [0],A
    0AB5: 3D 00 3E CMP   [X+0],62
    0AB8: 00       SSC   
    0AB9: 37 00 35 XOR   [X+0],53
    0ABC: 00       SSC   
    0ABD: 36 00 33 XOR   [0],51
    0AC0: 00       SSC   
    0AC1: 31 00    XOR   A,0
    0AC3: 32 00    XOR   A,[0]
    0AC5: FF 7C    INDEX 0x0A43
FILE: E:\CONTES~1\ENTRY201\LIB\PSOCCO~1.ASM
(0001) ;
(0002) ;  PSoCConfig.asm
(0003) ;
(0004) ;  Version 0.84
(0005) ;  Data: 19 December, 2000
(0006) ;  Copyright Cypress MicroSystems 2000
(0007) ;
(0008) ;  This file is generated by the Device Editor on Application Generation.
(0009) ;  It contains code which loads the configuration data table generated in
(0010) ;  the file PSoCConfigTBL.asm
(0011) ;  
(0012) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
(0013) ;  Edits to this file will not be preserved.
(0014) ;
(0015) 
(0016) export LoadConfigInit
(0017) export _LoadConfigInit
(0018) export LoadConfig_entry201
(0019) export _LoadConfig_entry201
(0020) 
(0021) export NO_SHADOW
(0022) export _NO_SHADOW
(0023) 
(0024) FLAG_CFG_MASK:		equ	10h			;M8C flag register REG address bit mask
(0025) END_CONFIG_TABLE:	equ	ffh			;end of config table indicator	
(0026) 
(0027) AREA text(rom, rel)
(0028) 
(0029) _LoadConfigInit:
(0030)  LoadConfigInit:
(0031) 	
(0032) 	lcall	LoadConfig_entry201
    0AC7: 0A CA    ADC   A,[202]
(0033) 
(0034) 	ret
    0AC9: 7F       RET   
(0035) 
(0036) ;
(0037) ; Load Configuration entry201
(0038) ;
(0039) _LoadConfig_entry201:
(0040)  LoadConfig_entry201:
(0041)     push    a
_LoadConfig_entry201:
LoadConfig_entry201:
    0ACA: 08       PUSH  A
(0042)     push    x
    0ACB: 10       PUSH  X
(0043) 	or		F, FLAG_CFG_MASK						;set for bank 1
    0ACC: 71 10    OR    F,16
(0044) 	mov		A, >LoadConfigTBL_entry201_Bank1	;load bank 1 table
    0ACE: 50 09    MOV   A,9
(0045) 	mov		X, <LoadConfigTBL_entry201_Bank1
    0AD0: 57 C8    MOV   X,200
(0046) 	call	LoadConfig								;load the bank 1 values
    0AD2: 90 0B    CALL  0x0ADF
(0047) 	and		F,~FLAG_CFG_MASK						;switch to bank 0
    0AD4: 70 EF    AND   F,239
(0048) 	mov		A, >LoadConfigTBL_entry201_Bank0	;load bank 0 table
    0AD6: 50 0A    MOV   A,10
(0049) 	mov		X, <LoadConfigTBL_entry201_Bank0
    0AD8: 57 35    MOV   X,53
(0050) 	call	LoadConfig								;load the bank 0 values
    0ADA: 90 03    CALL  0x0ADF
(0051)     pop     x
    0ADC: 20       POP   X
(0052)     pop     a
    0ADD: 18       POP   A
(0053) 	ret
    0ADE: 7F       RET   
(0054) 
(0055) 
(0056) ;
(0057) ; LoadConfig
(0058) ;
(0059) ;  This function is not exported.  It assumes that the address of the table
(0060) ;  to be loaded is contained in the X and A registers as if a romx instruction
(0061) ;  is the next instruction to be executed, i.e. lower address in X and uppper
(0062) ;  address in A.  There is no return value.
(0063) ;
(0064) LoadConfig:
(0065) 	add		SP, 1
    0ADF: 38 01    ADD   SP,1
(0066) LoadConfigLp:
(0067) 	push	X						;save config table address on stack
    0AE1: 10       PUSH  X
(0068) 	push	A
    0AE2: 08       PUSH  A
(0069) 	romx							;load config address
    0AE3: 28       ROMX  
(0070) 	cmp		A, END_CONFIG_TABLE		;check for end of table
    0AE4: 39 FF    CMP   A,255
(0071) 	jz		EndLoadConfig			;if so, end of load
    0AE6: A0 1A    JZ    0x0B01
(0072) 	mov		X, SP					;save the address away
    0AE8: 4F       MOV   X,SP
(0073) 	mov		[X-3], A
    0AE9: 54 FD    MOV   [X-3],A
(0074) 	pop		A						;retrieve the table address
    0AEB: 18       POP   A
(0075) 	pop		X
    0AEC: 20       POP   X
(0076) 	inc		X						;advance to the data byte
    0AED: 75       INC   X
(0077) 	jnc		NoOverFlow1				;check for overflow
    0AEE: D0 02    JNC   0x0AF1
(0078) 	inc		A						;if so, increment MSB
    0AF0: 74       INC   A
(0079) NoOverFlow1:	
(0080) 	push	X						;save the config table address again
    0AF1: 10       PUSH  X
(0081) 	push	A
    0AF2: 08       PUSH  A
(0082) 	romx							;load the config data
    0AF3: 28       ROMX  
(0083) 	mov		X, SP					;retrieve the config address
    0AF4: 4F       MOV   X,SP
(0084) 	mov		X, [X-3]
    0AF5: 59 FD    MOV   X,[X-3]
(0085) 	mov		reg[X], A				;write the config data
    0AF7: 61 00    MOV   REG[X+0],A
(0086) 	pop		A						;retrieve the table address
    0AF9: 18       POP   A
(0087) 	pop		X
    0AFA: 20       POP   X
(0088) 	inc		X						;advance to the next address
    0AFB: 75       INC   X
(0089) 	jnc		NoOverFlow2				;check for overflow
    0AFC: D0 02    JNC   0x0AFF
(0090) 	inc		A						;if so, increment MSB
    0AFE: 74       INC   A
(0091) NoOverFlow2:	
(0092) 	jmp		LoadConfigLp			;loop back
    0AFF: 8F E1    JMP   0x0AE1
(0093) EndLoadConfig:
(0094) 	pop		A						;clean up the stack
    0B01: 18       POP   A
(0095) 	pop		A
    0B02: 18       POP   A
(0096) 	add		SP, -1
    0B03: 38 FF    ADD   SP,255
(0097) 	ret
    0B05: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\INVERT.ASM
(0001) ;;************************************************************************
(0002) ;;************************************************************************
(0003) ;;
(0004) ;;  AMPINV_A.ASM
(0005) ;;
(0006) ;;  Assembler source for the Continuous Time Inverting Amplifier
(0007) ;;
(0008) ;;  REV C, 2002 Mar 30
(0009) ;;
(0010) ;;  Copyright: Cypress MicroSystems 2001. All Rights Reserved.
(0011) ;;
(0012) ;;************************************************************************
(0013) ;;************************************************************************
(0014) ;;
(0015) 
(0016) export  Invert_Start
(0017) export _Invert_Start
(0018) export  Invert_SetPower
(0019) export _Invert_SetPower
(0020) export  Invert_SetGain
(0021) export _Invert_SetGain
(0022) export  Invert_Stop
(0023) export _Invert_Stop
(0024) 
(0025)     ;; -----------------------------------------------------------------
(0026)     ;;                         Register Definitions
(0027)     ;; -----------------------------------------------------------------
(0028)     ;;
(0029)     ;; Uses 2 Continuous Time Blocks configured as shown. This API depends
(0030)     ;; on knowing the exact personalization of CR0 and CR3 bitfields
(0031)     ;; for time efficiency.
(0032)     ;;
(0033)     ;; * For a Mask/Val pair, this indicates that the value is
(0034)     ;;   determined by the user either through config-time parameteriza-
(0035)     ;;   tion or run-time manipulation.
(0036)     ;;
(0037)     ;; BIT FIELD             Mask/Val   Function
(0038)     ;; -----------------        -----   --------------------
(0039)     ;;
(0040)     ;; INVAMP_CR0.RMux           F0/*   User Parameter (by table)
(0041)     ;; INVAMP_CR0.GAIN           08/1   Gain
(0042)     ;; INVAMP_CR0.RTMux          04/1   Res source to output
(0043)     ;; INVAMP_CR0.RBMux          03/*   User Parameter
(0044)     ;;
(0045)     ;; INVAMP_CR1.AnalogBus      80/*   User Parameter (init: DISABLE)
(0046)     ;; INVAMP_CR1.CmpBus         40/0   Comparator bus disabled
(0047)     ;; INVAMP_CR1.NMux           38/4    Neg mux to analog f.b. tap
(0048)     ;; INVAMP_CR1.PMux           07/3    Pos mux to AGND
(0049)     ;;
(0050)     ;; INVAMP_CR2.CPhase         80/0    Latch transparent on PH1
(0051)     ;; INVAMP_CR2.CLatch         40/0    Latch transparent
(0052)     ;; INVAMP_CR2.Comp           20/1    Mode OP-AMP (not comparator)
(0053)     ;; INVAMP_CR2.OMux           1C/0    Bypass OFF
(0054)     ;; INVAMP_CR2.Power          03/0    Power OFF at start-up
(0055) 
(0056) 
(0057) include "Invert.inc"
(0058) include "m8c.inc"
(0059) POWERMASK: equ 03h
(0060) GAINMASK: equ f0h
(0061) 
(0062) ;;---------------------------------------------------------------------------
(0063) ;; Start / SetPower - Applies power setting to the module's SoCblocs
(0064) ;;
(0065) ;; INPUTS: A contains the power setting 0=Off, 1=Low, 2=Med, 3=High
(0066) ;; OUTUTS: None
(0067) ;;---------------------------------------------------------------------------
(0068)  Invert_Start:
(0069) _Invert_Start:
(0070)  Invert_SetPower:
(0071) _Invert_SetPower:
(0072) 
(0073)         and  A, POWERMASK       ; isolate bits of interest
Invert_Start:
_NO_SHADOW:
_Invert_SetPower:
_Invert_Start:
Invert_SetPower:
NO_SHADOW:
    0B06: 21 03    AND   A,3
(0074)         mov  X, SP              ; establish pointer to temp memory
    0B08: 4F       MOV   X,SP
(0075)         push A                  ; stash new setting
    0B09: 08       PUSH  A
(0076)         mov  A, REG[Invert_INVAMP_CR2]
    0B0A: 5D 7F    MOV   A,REG[127]
(0077)         and  A, ~POWERMASK      ; clear previous power setting
    0B0C: 21 FC    AND   A,252
(0078)         or   A, [X]             ; set power to new value
    0B0E: 2B 00    OR    A,[X+0]
(0079)         mov  REG[Invert_INVAMP_CR2], A
    0B10: 60 7F    MOV   REG[127],A
(0080)         pop  A                  ; clean up stack
    0B12: 18       POP   A
(0081)         ret
    0B13: 7F       RET   
(0082) 
(0083) ;;---------------------------------------------------------------------------------
(0084) ;;	SetGain:
(0085) ;;	INPUTS: Gain value 
(0086) ;;		  Use gain set values from .inc file
(0087) ;;	OUTPUTS: None
(0088) ;;	Side Effects: Momentary gain glitch while gain set to 1.0, then to new value
(0089) ;;
(0090) ;;	Gain values shown are for example
(0091) ;;	-16.0	1	0 0 0 0			
(0092) ;;	-7.00	1	0 0 0 1
(0093) ;;	....
(0094) ;;	-1.00	1	0 1 1 1
(0095) ;;	-0.77	0	1 0 0 0
(0096) ;;	....
(0097) ;;	0.12	0	1 1 0 1
(0098) ;;	0.06	0	1 1 1 0
(0099) ;;--------------------------------------------------------------------------------
(0100)  Invert_SetGain:
(0101) _Invert_SetGain:
(0102) 
(0103)     and A, GAINMASK                          ; mask A to protect unchanged bits
_Invert_SetGain:
Invert_SetGain:
    0B14: 21 F0    AND   A,240
(0104)     mov X, SP                                ; define temp store location
    0B16: 4F       MOV   X,SP
(0105)     push A                                   ; put gain value in temp store
    0B17: 08       PUSH  A
(0106)     mov A, reg[Invert_INVAMP_CR0]  ; read current gain value
    0B18: 5D 7D    MOV   A,REG[125]
(0107)     and A, ~GAINMASK                         ; clear gain bits in A
    0B1A: 21 0F    AND   A,15
(0108)     or  A, [X]                               ; combine gain value with balance of reg.
    0B1C: 2B 00    OR    A,[X+0]
(0109)     mov reg[Invert_INVAMP_CR0], A  ; move complete value back to register
    0B1E: 60 7D    MOV   REG[125],A
(0110)     pop A
    0B20: 18       POP   A
(0111)     ret
    0B21: 7F       RET   
(0112) 
(0113) ;;---------------------------------------------------------------------------
(0114) ;; Stop - Cuts power to the user module.
(0115) ;;
(0116) ;; INPUTS:  None
(0117) ;; OUTPUTS: None
(0118) ;;---------------------------------------------------------------------------
(0119)  Invert_Stop:
(0120) _Invert_Stop:
(0121) 
(0122)         and REG[Invert_INVAMP_CR2], FCh
Invert_Stop:
_Invert_Stop:
    0B22: 41 7F FC AND   REG[127],252
(0123)         ret
    0B25: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\DOUBLE~1.ASM
(0001) ;;************************************************************************
(0002) ;;************************************************************************
(0003) ;;
(0004) ;; INSAMP.asm
(0005) ;;
(0006) ;; Assembler source for Instrumentation Amplifier
(0007) ;;
(0008) ;; Rev A, 2002 Mar 30
(0009) ;;
(0010) ;; Copyright (c) 2000-2002 Cypress Microsystems, Inc. All rights reserved.
(0011) ;;
(0012) ;;************************************************************************
(0013) ;;************************************************************************
(0014) ;;
(0015) 
(0016) export  DoubleEnded_Start
(0017) export _DoubleEnded_Start
(0018) export  DoubleEnded_SetPower
(0019) export _DoubleEnded_SetPower
(0020) 
(0021) export  DoubleEnded_SetGain
(0022) export _DoubleEnded_SetGain
(0023) 
(0024) export  DoubleEnded_Stop
(0025) export _DoubleEnded_Stop
(0026) 
(0027) ;; -----------------------------------------------------------------
(0028) ;;                         Register Definitions
(0029) ;; -----------------------------------------------------------------
(0030) ;;
(0031) ;; Uses 2 Continuous Time Blocks configured as shown. This API depends
(0032) ;; on knowing the exact personalization of CR0 and CR3 bitfields
(0033) ;; for time efficiency.
(0034) ;;
(0035) ;; * For a Mask/Val pair, this indicates that the value is
(0036) ;;   determined by the user either through config-time parameteriza-
(0037) ;;   tion or run-time manipulation.
(0038) ;;
(0039) ;; BIT FIELD	         Mask/Val Function
(0040) ;; -----------------    	----- 	--------------------
(0041) ;; NON_INV_CR0.RES_RATIO_T2B	F0/*	User Parameter (by table)
(0042) ;; NON_INV_CR0.GAIN_ATTEN	08/1	Gain
(0043) ;; NON_INV_CR0.RES_SOURCE	04/1	Res source to output
(0044) ;; NON_INV_CR0.RES_REF		03/0	Res ref to INV output
(0045) ;;
(0046) ;; NON_INV_CR1.A_OUT		80/*	User Parameter (Output bus)
(0047) ;; NON_INV_CR1.COMP_EN		40/0	Comparator bus disabled
(0048) ;; NON_INV_CR1.CT_NEG_INPUT_MUX	38/4	Neg mux to analog f.b. tap
(0049) ;; NON_INV_CR1.CT_POS_INPUT_MUX	07/1	Pos mux to col. input mux
(0050) ;;
(0051) ;; NON_INV_CR2.CP_COMP		80/0	Latch transparent on PH1
(0052) ;; NON_INV_CR2.CK_COMP		40/0	Latch transparent
(0053) ;; NON_INV_CR2.CC_COMP		20/1	Mode OP-AMP (not comparator)
(0054) ;; NON_INV_CR2.BYPASS_OBUS	1C/0	Bypass OFF
(0055) ;; NON_INV_CR2.PWR_SELECT	03/0	Power OFF at start-up
(0056) ;;
(0057) ;; INV_CR0.RES_RATIO_T2B	F0/*	User Parameter (by table)
(0058) ;; INV_CR0.GAIN_ATTEN		08/1	Gain
(0059) ;; INV_CR0.RES_SOURCE		04/1	Res source to output	
(0060) ;; INV_CR0.RES_REF		03/*	User Parameter
(0061) ;;
(0062) ;; INV_CR1.A_OUT		80/0	Output bus disabled		
(0063) ;; INV_CR1.COMP_EN		40/0	Comparator bus disabled
(0064) ;; INV_CR1.CT_NEG_INPUT_MUX	38/4	Neg mux to analog f.b. tap
(0065) ;; INV_CR1.CT_POS_INPUT_MUX	07/1	Pos mux to col. input mux
(0066) ;;
(0067) ;; INV_CR2.CP_COMP		80/0	Latch transparent on PH1
(0068) ;; INV_CR2.CK_COMP		40/0	Latch transparent
(0069) ;; INV_CR2.CC_COMP		20/0	Mode OP-AMP (not comparator)
(0070) ;; INV_CR2.BYPASS_OBUS		1C/0	Bypass OFF
(0071) ;; INV_CR2.PWR_SELECT		03/0	Power OFF at start-up
(0072) 
(0073) include "DoubleEnded.inc"
(0074) include "m8c.inc"
(0075) POWERMASK: equ 03h                           ;Power field mask for CR2
(0076) GAINMASK:  equ F0h                           ;Gain field mask for CR0
(0077) 
(0078) 
(0079) ;; -----------------------------------------------------------------
(0080) ;; Start/SetPower - Applies power setting to the module's PSoC blocks
(0081) ;; 
(0082) ;; INPUTS: A contains the power setting 0=Off, 1=Low, 2=Med, 3=High
(0083) ;; OUTUTS: None
(0084) ;; -----------------------------------------------------------------
(0085) 
(0086)  DoubleEnded_Start:
(0087) _DoubleEnded_Start:
(0088)  DoubleEnded_SetPower:
(0089) _DoubleEnded_SetPower:
(0090) 
(0091)     and A, POWERMASK                         ; mask A to protect unchanged bits
_DoubleEnded_Start:
_DoubleEnded_SetPower:
DoubleEnded_Start:
DoubleEnded_SetPower:
    0B26: 21 03    AND   A,3
(0092)     mov X, SP                                ; define temp store location
    0B28: 4F       MOV   X,SP
(0093) 
(0094)     push A                                   ; put power value in temp store
    0B29: 08       PUSH  A
(0095)     mov A, reg[DoubleEnded_INV_CR2]     ; read power value
    0B2A: 5D 73    MOV   A,REG[115]
(0096)     and A, ~POWERMASK                        ; clear power bits in A
    0B2C: 21 FC    AND   A,252
(0097)     or  A, [X]                               ; combine power value with balance of reg.
    0B2E: 2B 00    OR    A,[X+0]
(0098)     mov reg[DoubleEnded_INV_CR2], A
    0B30: 60 73    MOV   REG[115],A
(0099) 
(0100)     mov A, reg[DoubleEnded_NON_INV_CR2] ; read power value
    0B32: 5D 77    MOV   A,REG[119]
(0101)     and A, ~POWERMASK                        ; clear power bits in A
    0B34: 21 FC    AND   A,252
(0102)     or  A, [X]                               ; combine power value with balance of reg.
    0B36: 2B 00    OR    A,[X+0]
(0103)     mov reg[DoubleEnded_NON_INV_CR2], A
    0B38: 60 77    MOV   REG[119],A
(0104)     pop A
    0B3A: 18       POP   A
(0105)     ret
    0B3B: 7F       RET   
(0106) 
(0107) 
(0108) ;; -----------------------------------------------------------------
(0109) ;; SetGain - Applies gain set values to the module's PSoC blocks
(0110) ;; 
(0111) ;; INPUTS: A contains the gain setting per values in .inc
(0112) ;;         Values in range of 00h to 07h, upper 4 bits only
(0113) ;;         Gain value applied to NON_INV block
(0114) ;;         Difference (E0h-gain value) applied to _INV block
(0115) ;; OUTUTS: None
(0116) ;; -----------------------------------------------------------------
(0117) 
(0118)  DoubleEnded_SetGain:
(0119) _DoubleEnded_SetGain:
(0120) 
(0121)     and A, GAINMASK                          ; mask A to protect unchanged bits
_DoubleEnded_SetGain:
DoubleEnded_SetGain:
    0B3C: 21 F0    AND   A,240
(0122)     mov X, SP                                ; set base address for local variable
    0B3E: 4F       MOV   X,SP
(0123) 
(0124)     push A                                   
    0B3F: 08       PUSH  A
(0125)     mov A, reg[DoubleEnded_NON_INV_CR0] ; read gain value
    0B40: 5D 75    MOV   A,REG[117]
(0126)     and A, ~GAINMASK                         ; clear gain bits in A
    0B42: 21 0F    AND   A,15
(0127)     or  A, [X]                               ; combine gain value with balance of reg.
    0B44: 2B 00    OR    A,[X+0]
(0128)     mov reg[DoubleEnded_NON_INV_CR0], A 
    0B46: 60 75    MOV   REG[117],A
(0129) 
(0130)     mov A, E0h                               ; load gain complement value
    0B48: 50 E0    MOV   A,224
(0131)     sub a, [X]                               ; calculate gain value for -INV block
    0B4A: 13 00    SUB   A,[X+0]
(0132)     push A                                   
    0B4C: 08       PUSH  A
(0133)     mov A, reg[DoubleEnded_INV_CR0]     ; read gain complement value
    0B4D: 5D 71    MOV   A,REG[113]
(0134)     and A, ~GAINMASK                         ; clear gain bits in A
    0B4F: 21 0F    AND   A,15
(0135)     or  A, [X+1]                               ; combine gain value with balance of reg.
    0B51: 2B 01    OR    A,[X+1]
(0136)     mov reg[DoubleEnded_INV_CR0], A     
    0B53: 60 71    MOV   REG[113],A
(0137)     pop A
    0B55: 18       POP   A
(0138)     pop A
    0B56: 18       POP   A
(0139)     ret
    0B57: 7F       RET   
(0140) 
(0141) 
(0142) 
(0143) ;; -----------------------------------------------------------------
(0144) ;; Stop - Cuts power to the user module.
(0145) ;;
(0146) ;; INPUTS:  None
(0147) ;; OUTPUTS: None
(0148) ;; -----------------------------------------------------------------
(0149) 
(0150)  DoubleEnded_Stop:
(0151) _DoubleEnded_Stop:
(0152) 
(0153)       
(0154)     and reg[DoubleEnded_NON_INV_CR2], FCh
DoubleEnded_Stop:
_DoubleEnded_Stop:
    0B58: 41 77 FC AND   REG[119],252
(0155)     and reg[DoubleEnded_INV_CR2], FCh
    0B5B: 41 73 FC AND   REG[115],252
(0156)         RET
    0B5E: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\DAC_P05.ASM
(0001) ;;************************************************************************
(0002) ;;************************************************************************
(0003) ;;
(0004) ;;  DAC_P05.ASM (from DAC6.asm user module template)
(0005) ;;  Rev C, 2002 Mar 30
(0006) ;;
(0007) ;;  Assembler source for 6-bit Switched Capacitor DAC API
(0008) ;;
(0009) ;;  Copyright (c) Cypress MicroSystems 2001-2002. All Rights Reserved.
(0010) ;;
(0011) ;;************************************************************************
(0012) ;;************************************************************************
(0013) ;;
(0014) 
(0015) export  DAC_P05_Start
(0016) export _DAC_P05_Start
(0017) export  DAC_P05_SetPower
(0018) export _DAC_P05_SetPower
(0019) 
(0020) export  DAC_P05_WriteBlind
(0021) export _DAC_P05_WriteBlind
(0022) export  DAC_P05_WriteStall
(0023) export _DAC_P05_WriteStall
(0024) 
(0025) export  DAC_P05_Stop
(0026) export _DAC_P05_Stop
(0027) 
(0028) ;; -----------------------------------------------------------------
(0029) ;;                         Register Definitions
(0030) ;; -----------------------------------------------------------------
(0031) ;;
(0032) ;; Uses 1 Switched Cap Block configured as shown. This API depends
(0033) ;; on knowing the exact personalization of CR0 and CR3 bitfields
(0034) ;; for time efficiency.
(0035) ;;
(0036) ;; * For a Mask/Val pair, this simply indicates that the value is
(0037) ;;   determined by the user either through config-time parameteriza-
(0038) ;;   tion or run-time manipulation.
(0039) ;;
(0040) ;; BIT FIELD         Mask/Val Function
(0041) ;; -----------------    ----- --------------------
(0042) ;; CR0.FCap             80/1  Feedback cap size 32
(0043) ;; CR0.ClockPhase       40/0  Normal phase
(0044) ;; CR0.ASign            20/*  User parameter
(0045) ;; CR0.ACap             1F/*  User parameter
(0046) ;;
(0047) ;; CR1.ACMux            E0/2  (SCA) A:VRef High, C:Don't Care
(0048) ;; CR1.AMux             E0/4  (SCB) VRef High
(0049) ;; CR1.BCap             1F/0  Prune B-input branch
(0050) ;;
(0051) ;; CR2.AnalogBus        80/*  User Parameter: Output Bus Enable
(0052) ;; CR2.CmpBus           40/0  Comparator Bus Disable
(0053) ;; CR2.AutoZero         20/1  Auto-Zero enabled on Phi 1
(0054) ;; CR2.CCap             1F/0  Prune C-input branch
(0055) ;;
(0056) ;; CR3.ARefSelect       C0/0  Use AGND (to invert)
(0057) ;; CR3.FSW1             20/1  Feedback Cap Used
(0058) ;; CR3.FSW2             10/1  Feedback Cap Grounded for AZ
(0059) ;; CR3.BMux             0C/0  (SCA) Don't Care - this branch pruned
(0060) ;; CR3.BSW              08/0  (SCB) Don't Care - this branch pruned
(0061) ;; CR3.BMux             04/0  (SCB) Don't Care - this branch pruned
(0062) ;; CR3.PWR              03/*  User Parameter: Power, def=OFF
(0063) ;;
(0064) 
(0065) include "DAC_P05.inc"
(0066) include "m8c.inc"
(0067) 
(0068) cOFFSET:   equ 31               ; Conversion term for offset binary to 2's C
(0069) bPWRMASK:  equ 03h              ; Power bitfield in Switched Cap CR3 reg
(0070) bCR3:      equ 30h              ; Except for power bits, CR3 ALWAYS looks
(0071)                                 ;    like this regardless of SC block type
(0072)                                 ;    or where the DAC gets mapped.
(0073) 
(0074) area text (ROM, REL)
(0075) 
(0076) ;;---------------------------------------------------------------------------
(0077) ;; Start / SetPower - Applies power setting to the module's SoCblocs
(0078) ;;
(0079) ;; INPUTS: A contains the power setting 0=Off, 1=Low, 2=Med, 3=High
(0080) ;; OUTUTS: None
(0081) ;;---------------------------------------------------------------------------
(0082)  DAC_P05_Start:
(0083) _DAC_P05_Start:
(0084)  DAC_P05_SetPower:
(0085) _DAC_P05_SetPower:
(0086)         and A, bPWRMASK
DAC_P05_Start:
DAC_P05_SetPower:
_DAC_P05_Start:
_DAC_P05_SetPower:
    0B5F: 21 03    AND   A,3
(0087)         or  A, bCR3             ; Set all other bits in addition to power
    0B61: 29 30    OR    A,48
(0088)         mov reg[DAC_P05_CR3], A
    0B63: 60 97    MOV   REG[151],A
(0089)         ret
    0B65: 7F       RET   
(0090) 
(0091) ;;---------------------------------------------------------------------------
(0092) ;; WriteBlind
(0093) ;; ----------
(0094) ;;
(0095) ;; Modify the DAC's update value without worrying about the clocks
(0096) ;;   Lowest overhead, but output may not settle to correct value until the
(0097) ;;   phi2 of next full cycle following the write.
(0098) ;;
(0099) ;; INPUTS: The accumulator, A, contains the input in the appropriate format.
(0100) ;;   The data format is determined by the setting of the DataFormat parameter
(0101) ;;   in the Device Editor.
(0102) ;;
(0103) ;; OUTPUTS: Analog output voltage reflects new value
(0104) ;;---------------------------------------------------------------------------
(0105)  DAC_P05_WriteBlind:
(0106) _DAC_P05_WriteBlind:
(0107) 
(0108)   IF DAC_P05_OFFSETBINARY
(0109)     ;; Data is an unsigned byte value in [0..62] (i.e., 63 unique values).
(0110)     ;; Following converts it to 2's complement:
(0111)     sub  A, cOFFSET         ; Apply the offset
_DAC_P05_WriteBlind:
DAC_P05_WriteBlind:
    0B66: 11 1F    SUB   A,31
(0112)   ENDIF
(0113)   IF DAC_P05_OFFSETBINARY | DAC_P05_TWOSCOMPLEMENT
(0114)     ;; Data is a byte in standard 2's complement form with value in [-31..+31]
(0115)     ;; Following converts it to Sign & Magnitude form "00smmmmm"
(0116)     ;;   where sign, "s", is 1 for negative numbers; 0 for positive
(0117)     ;;   and "m" is the magnitude.
(0118)     asl  A                  ; Multiply by 2 and put sign in Carry flag
    0B68: 64       ASL   A
(0119)     jnc  BlindPositive
    0B69: D0 07    JNC   0x0B71
(0120)     ;; Neg to pos by "Invert & Add 1" procedure, but data is shifted!
(0121)     cpl  A                  ; bit 0 is a "1" so, following 1 byte "inc" works
    0B6B: 73       CPL   A
(0122)     inc  A                  ;   (otherwise, we'd have to "add A, 2")
    0B6C: 74       INC   A
(0123)     or   A, 40h             ; Make it negative by forcing sign bit
    0B6D: 29 40    OR    A,64
(0124)     jmp  BlindMagSet
    0B6F: 80 06    JMP   0x0B76
(0125) BlindPositive:
(0126)     nop
    0B71: 40       NOP   
(0127)     nop
    0B72: 40       NOP   
(0128)     nop
    0B73: 40       NOP   
(0129)     jmp  BlindMagSet
    0B74: 80 01    JMP   0x0B76
(0130) BlindMagSet:
(0131)     asr  A                  ; Divide by two to finish up
    0B76: 67       ASR   A
(0132)   ENDIF
(0133) 
(0134)     ;; Data is in Sign & Magnitude form.
(0135)     ;; Set FCap and ClockPhase bits
(0136)     or   A, DAC_P05_CR0_HIBITS
    0B77: 29 80    OR    A,128
(0137)     mov  reg[DAC_P05_CR0], A
    0B79: 60 94    MOV   REG[148],A
(0138)     ret
    0B7B: 7F       RET   
(0139) 
(0140) ;;---------------------------------------------------------------------------
(0141) ;; WriteStall
(0142) ;; ----------
(0143) ;;
(0144) ;; Modify the DAC's update value, stalling the CPU if necessary.
(0145) ;;   This routine should be used with fast analog clocks or when the
(0146) ;;   resulting interrupt latencies, comparable to the update period,
(0147) ;;   can be tolerated comfortably.
(0148) ;;
(0149) ;; INPUTS: The accumulator, A, contains the input in the appropriate format.
(0150) ;;   The data format is determined by the setting of the DataFormat parameter
(0151) ;;   in the Device Editor.
(0152) ;;
(0153) ;; OUTPUTS: Analog output voltage reflects new value
(0154) ;;---------------------------------------------------------------------------
(0155)  DAC_P05_WriteStall:
(0156) _DAC_P05_WriteStall:
(0157) 
(0158)   IF DAC_P05_OFFSETBINARY
(0159)     ;; Data is an unsigned byte value in [0..62] (i.e., 63 unique values).
(0160)     ;; Following converts it to 2's complement:
(0161)     sub  A, cOFFSET         ; Apply the offset
_DAC_P05_WriteStall:
DAC_P05_WriteStall:
    0B7C: 11 1F    SUB   A,31
(0162)   ENDIF
(0163)   IF DAC_P05_OFFSETBINARY | DAC_P05_TWOSCOMPLEMENT
(0164)     ;; Data is a byte in standard 2's complement form with value in [-31..+31]
(0165)     ;; Following converts it to Sign & Magnitude form "00smmmmm"
(0166)     ;;   where sign, "s", is 1 for negative numbers; 0 for positive
(0167)     ;;   and "m" is the magnitude.
(0168)     asl  A                  ; Multiply by 2 and put sign in Carry flag
    0B7E: 64       ASL   A
(0169)     jnc  StallPositive
    0B7F: D0 07    JNC   0x0B87
(0170)     cpl  A                  ; "Invert" step of complement 2's complement
    0B81: 73       CPL   A
(0171)     inc  A                  ; "Add 1"  step of complement 2's complement
    0B82: 74       INC   A
(0172)     or   A, 40h             ; Make it negative
    0B83: 29 40    OR    A,64
(0173)     jmp  StallMagSet
    0B85: 80 06    JMP   0x0B8C
(0174) StallPositive:
(0175)     nop
    0B87: 40       NOP   
(0176)     nop
    0B88: 40       NOP   
(0177)     nop
    0B89: 40       NOP   
(0178)     jmp  StallMagSet
    0B8A: 80 01    JMP   0x0B8C
(0179) StallMagSet:
(0180)     asr  A                  ; Divide by two to finish conversion
    0B8C: 67       ASR   A
(0181)   ENDIF
(0182) 
(0183)     ;; Data is in Sign & Magnitude form.
(0184)     ;; Set FCap and ClockPhase bits
(0185)     or   A, DAC_P05_CR0_HIBITS
    0B8D: 29 80    OR    A,128
    0B8F: 43 65 01 OR    REG[101],1
(0186)     M8C_Stall
(0187)     mov  reg[DAC_P05_CR0], A
    0B92: 60 94    MOV   REG[148],A
    0B94: 41 65 FE AND   REG[101],254
(0188)     M8C_Unstall
(0189)     ret
    0B97: 7F       RET   
(0190) 
(0191) ;;---------------------------------------------------------------------------
(0192) ;; Stop - Cuts power to the user module.
(0193) ;;
(0194) ;; INPUTS:  None
(0195) ;; OUTPUTS: None
(0196) ;;---------------------------------------------------------------------------
(0197)  DAC_P05_Stop:
(0198) _DAC_P05_Stop:
(0199)     and reg[DAC_P05_CR3], ~bPWRMASK
DAC_P05_Stop:
_DAC_P05_Stop:
    0B98: 41 97 FC AND   REG[151],252
(0200)     ret
    0B9B: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\DAC_P04.ASM
(0001) ;;************************************************************************
(0002) ;;************************************************************************
(0003) ;;
(0004) ;;  DAC_P04.ASM (from DAC6.asm user module template)
(0005) ;;  Rev C, 2002 Mar 30
(0006) ;;
(0007) ;;  Assembler source for 6-bit Switched Capacitor DAC API
(0008) ;;
(0009) ;;  Copyright (c) Cypress MicroSystems 2001-2002. All Rights Reserved.
(0010) ;;
(0011) ;;************************************************************************
(0012) ;;************************************************************************
(0013) ;;
(0014) 
(0015) export  DAC_P04_Start
(0016) export _DAC_P04_Start
(0017) export  DAC_P04_SetPower
(0018) export _DAC_P04_SetPower
(0019) 
(0020) export  DAC_P04_WriteBlind
(0021) export _DAC_P04_WriteBlind
(0022) export  DAC_P04_WriteStall
(0023) export _DAC_P04_WriteStall
(0024) 
(0025) export  DAC_P04_Stop
(0026) export _DAC_P04_Stop
(0027) 
(0028) ;; -----------------------------------------------------------------
(0029) ;;                         Register Definitions
(0030) ;; -----------------------------------------------------------------
(0031) ;;
(0032) ;; Uses 1 Switched Cap Block configured as shown. This API depends
(0033) ;; on knowing the exact personalization of CR0 and CR3 bitfields
(0034) ;; for time efficiency.
(0035) ;;
(0036) ;; * For a Mask/Val pair, this simply indicates that the value is
(0037) ;;   determined by the user either through config-time parameteriza-
(0038) ;;   tion or run-time manipulation.
(0039) ;;
(0040) ;; BIT FIELD         Mask/Val Function
(0041) ;; -----------------    ----- --------------------
(0042) ;; CR0.FCap             80/1  Feedback cap size 32
(0043) ;; CR0.ClockPhase       40/0  Normal phase
(0044) ;; CR0.ASign            20/*  User parameter
(0045) ;; CR0.ACap             1F/*  User parameter
(0046) ;;
(0047) ;; CR1.ACMux            E0/2  (SCA) A:VRef High, C:Don't Care
(0048) ;; CR1.AMux             E0/4  (SCB) VRef High
(0049) ;; CR1.BCap             1F/0  Prune B-input branch
(0050) ;;
(0051) ;; CR2.AnalogBus        80/*  User Parameter: Output Bus Enable
(0052) ;; CR2.CmpBus           40/0  Comparator Bus Disable
(0053) ;; CR2.AutoZero         20/1  Auto-Zero enabled on Phi 1
(0054) ;; CR2.CCap             1F/0  Prune C-input branch
(0055) ;;
(0056) ;; CR3.ARefSelect       C0/0  Use AGND (to invert)
(0057) ;; CR3.FSW1             20/1  Feedback Cap Used
(0058) ;; CR3.FSW2             10/1  Feedback Cap Grounded for AZ
(0059) ;; CR3.BMux             0C/0  (SCA) Don't Care - this branch pruned
(0060) ;; CR3.BSW              08/0  (SCB) Don't Care - this branch pruned
(0061) ;; CR3.BMux             04/0  (SCB) Don't Care - this branch pruned
(0062) ;; CR3.PWR              03/*  User Parameter: Power, def=OFF
(0063) ;;
(0064) 
(0065) include "DAC_P04.inc"
(0066) include "m8c.inc"
(0067) 
(0068) cOFFSET:   equ 31               ; Conversion term for offset binary to 2's C
(0069) bPWRMASK:  equ 03h              ; Power bitfield in Switched Cap CR3 reg
(0070) bCR3:      equ 30h              ; Except for power bits, CR3 ALWAYS looks
(0071)                                 ;    like this regardless of SC block type
(0072)                                 ;    or where the DAC gets mapped.
(0073) 
(0074) area text (ROM, REL)
(0075) 
(0076) ;;---------------------------------------------------------------------------
(0077) ;; Start / SetPower - Applies power setting to the module's SoCblocs
(0078) ;;
(0079) ;; INPUTS: A contains the power setting 0=Off, 1=Low, 2=Med, 3=High
(0080) ;; OUTUTS: None
(0081) ;;---------------------------------------------------------------------------
(0082)  DAC_P04_Start:
(0083) _DAC_P04_Start:
(0084)  DAC_P04_SetPower:
(0085) _DAC_P04_SetPower:
(0086)         and A, bPWRMASK
DAC_P04_Start:
_DAC_P04_SetPower:
DAC_P04_SetPower:
_DAC_P04_Start:
    0B9C: 21 03    AND   A,3
(0087)         or  A, bCR3             ; Set all other bits in addition to power
    0B9E: 29 30    OR    A,48
(0088)         mov reg[DAC_P04_CR3], A
    0BA0: 60 9B    MOV   REG[155],A
(0089)         ret
    0BA2: 7F       RET   
(0090) 
(0091) ;;---------------------------------------------------------------------------
(0092) ;; WriteBlind
(0093) ;; ----------
(0094) ;;
(0095) ;; Modify the DAC's update value without worrying about the clocks
(0096) ;;   Lowest overhead, but output may not settle to correct value until the
(0097) ;;   phi2 of next full cycle following the write.
(0098) ;;
(0099) ;; INPUTS: The accumulator, A, contains the input in the appropriate format.
(0100) ;;   The data format is determined by the setting of the DataFormat parameter
(0101) ;;   in the Device Editor.
(0102) ;;
(0103) ;; OUTPUTS: Analog output voltage reflects new value
(0104) ;;---------------------------------------------------------------------------
(0105)  DAC_P04_WriteBlind:
(0106) _DAC_P04_WriteBlind:
(0107) 
(0108)   IF DAC_P04_OFFSETBINARY
(0109)     ;; Data is an unsigned byte value in [0..62] (i.e., 63 unique values).
(0110)     ;; Following converts it to 2's complement:
(0111)     sub  A, cOFFSET         ; Apply the offset
_DAC_P04_WriteBlind:
DAC_P04_WriteBlind:
    0BA3: 11 1F    SUB   A,31
(0112)   ENDIF
(0113)   IF DAC_P04_OFFSETBINARY | DAC_P04_TWOSCOMPLEMENT
(0114)     ;; Data is a byte in standard 2's complement form with value in [-31..+31]
(0115)     ;; Following converts it to Sign & Magnitude form "00smmmmm"
(0116)     ;;   where sign, "s", is 1 for negative numbers; 0 for positive
(0117)     ;;   and "m" is the magnitude.
(0118)     asl  A                  ; Multiply by 2 and put sign in Carry flag
    0BA5: 64       ASL   A
(0119)     jnc  BlindPositive
    0BA6: D0 07    JNC   0x0BAE
(0120)     ;; Neg to pos by "Invert & Add 1" procedure, but data is shifted!
(0121)     cpl  A                  ; bit 0 is a "1" so, following 1 byte "inc" works
    0BA8: 73       CPL   A
(0122)     inc  A                  ;   (otherwise, we'd have to "add A, 2")
    0BA9: 74       INC   A
(0123)     or   A, 40h             ; Make it negative by forcing sign bit
    0BAA: 29 40    OR    A,64
(0124)     jmp  BlindMagSet
    0BAC: 80 06    JMP   0x0BB3
(0125) BlindPositive:
(0126)     nop
    0BAE: 40       NOP   
(0127)     nop
    0BAF: 40       NOP   
(0128)     nop
    0BB0: 40       NOP   
(0129)     jmp  BlindMagSet
    0BB1: 80 01    JMP   0x0BB3
(0130) BlindMagSet:
(0131)     asr  A                  ; Divide by two to finish up
    0BB3: 67       ASR   A
(0132)   ENDIF
(0133) 
(0134)     ;; Data is in Sign & Magnitude form.
(0135)     ;; Set FCap and ClockPhase bits
(0136)     or   A, DAC_P04_CR0_HIBITS
    0BB4: 29 80    OR    A,128
(0137)     mov  reg[DAC_P04_CR0], A
    0BB6: 60 98    MOV   REG[152],A
(0138)     ret
    0BB8: 7F       RET   
(0139) 
(0140) ;;---------------------------------------------------------------------------
(0141) ;; WriteStall
(0142) ;; ----------
(0143) ;;
(0144) ;; Modify the DAC's update value, stalling the CPU if necessary.
(0145) ;;   This routine should be used with fast analog clocks or when the
(0146) ;;   resulting interrupt latencies, comparable to the update period,
(0147) ;;   can be tolerated comfortably.
(0148) ;;
(0149) ;; INPUTS: The accumulator, A, contains the input in the appropriate format.
(0150) ;;   The data format is determined by the setting of the DataFormat parameter
(0151) ;;   in the Device Editor.
(0152) ;;
(0153) ;; OUTPUTS: Analog output voltage reflects new value
(0154) ;;---------------------------------------------------------------------------
(0155)  DAC_P04_WriteStall:
(0156) _DAC_P04_WriteStall:
(0157) 
(0158)   IF DAC_P04_OFFSETBINARY
(0159)     ;; Data is an unsigned byte value in [0..62] (i.e., 63 unique values).
(0160)     ;; Following converts it to 2's complement:
(0161)     sub  A, cOFFSET         ; Apply the offset
DAC_P04_WriteStall:
_DAC_P04_WriteStall:
    0BB9: 11 1F    SUB   A,31
(0162)   ENDIF
(0163)   IF DAC_P04_OFFSETBINARY | DAC_P04_TWOSCOMPLEMENT
(0164)     ;; Data is a byte in standard 2's complement form with value in [-31..+31]
(0165)     ;; Following converts it to Sign & Magnitude form "00smmmmm"
(0166)     ;;   where sign, "s", is 1 for negative numbers; 0 for positive
(0167)     ;;   and "m" is the magnitude.
(0168)     asl  A                  ; Multiply by 2 and put sign in Carry flag
    0BBB: 64       ASL   A
(0169)     jnc  StallPositive
    0BBC: D0 07    JNC   0x0BC4
(0170)     cpl  A                  ; "Invert" step of complement 2's complement
    0BBE: 73       CPL   A
(0171)     inc  A                  ; "Add 1"  step of complement 2's complement
    0BBF: 74       INC   A
(0172)     or   A, 40h             ; Make it negative
    0BC0: 29 40    OR    A,64
(0173)     jmp  StallMagSet
    0BC2: 80 06    JMP   0x0BC9
(0174) StallPositive:
(0175)     nop
    0BC4: 40       NOP   
(0176)     nop
    0BC5: 40       NOP   
(0177)     nop
    0BC6: 40       NOP   
(0178)     jmp  StallMagSet
    0BC7: 80 01    JMP   0x0BC9
(0179) StallMagSet:
(0180)     asr  A                  ; Divide by two to finish conversion
    0BC9: 67       ASR   A
(0181)   ENDIF
(0182) 
(0183)     ;; Data is in Sign & Magnitude form.
(0184)     ;; Set FCap and ClockPhase bits
(0185)     or   A, DAC_P04_CR0_HIBITS
    0BCA: 29 80    OR    A,128
    0BCC: 43 65 01 OR    REG[101],1
(0186)     M8C_Stall
(0187)     mov  reg[DAC_P04_CR0], A
    0BCF: 60 98    MOV   REG[152],A
    0BD1: 41 65 FE AND   REG[101],254
(0188)     M8C_Unstall
(0189)     ret
    0BD4: 7F       RET   
(0190) 
(0191) ;;---------------------------------------------------------------------------
(0192) ;; Stop - Cuts power to the user module.
(0193) ;;
(0194) ;; INPUTS:  None
(0195) ;; OUTPUTS: None
(0196) ;;---------------------------------------------------------------------------
(0197)  DAC_P04_Stop:
(0198) _DAC_P04_Stop:
(0199)     and reg[DAC_P04_CR3], ~bPWRMASK
DAC_P04_Stop:
_DAC_P04_Stop:
    0BD5: 41 9B FC AND   REG[155],252
(0200)     ret
    0BD8: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\DAC_P03.ASM
(0001) ;;************************************************************************
(0002) ;;************************************************************************
(0003) ;;
(0004) ;;  DAC_P03.ASM (from DAC6.asm user module template)
(0005) ;;  Rev C, 2002 Mar 30
(0006) ;;
(0007) ;;  Assembler source for 6-bit Switched Capacitor DAC API
(0008) ;;
(0009) ;;  Copyright (c) Cypress MicroSystems 2001-2002. All Rights Reserved.
(0010) ;;
(0011) ;;************************************************************************
(0012) ;;************************************************************************
(0013) ;;
(0014) 
(0015) export  DAC_P03_Start
(0016) export _DAC_P03_Start
(0017) export  DAC_P03_SetPower
(0018) export _DAC_P03_SetPower
(0019) 
(0020) export  DAC_P03_WriteBlind
(0021) export _DAC_P03_WriteBlind
(0022) export  DAC_P03_WriteStall
(0023) export _DAC_P03_WriteStall
(0024) 
(0025) export  DAC_P03_Stop
(0026) export _DAC_P03_Stop
(0027) 
(0028) ;; -----------------------------------------------------------------
(0029) ;;                         Register Definitions
(0030) ;; -----------------------------------------------------------------
(0031) ;;
(0032) ;; Uses 1 Switched Cap Block configured as shown. This API depends
(0033) ;; on knowing the exact personalization of CR0 and CR3 bitfields
(0034) ;; for time efficiency.
(0035) ;;
(0036) ;; * For a Mask/Val pair, this simply indicates that the value is
(0037) ;;   determined by the user either through config-time parameteriza-
(0038) ;;   tion or run-time manipulation.
(0039) ;;
(0040) ;; BIT FIELD         Mask/Val Function
(0041) ;; -----------------    ----- --------------------
(0042) ;; CR0.FCap             80/1  Feedback cap size 32
(0043) ;; CR0.ClockPhase       40/0  Normal phase
(0044) ;; CR0.ASign            20/*  User parameter
(0045) ;; CR0.ACap             1F/*  User parameter
(0046) ;;
(0047) ;; CR1.ACMux            E0/2  (SCA) A:VRef High, C:Don't Care
(0048) ;; CR1.AMux             E0/4  (SCB) VRef High
(0049) ;; CR1.BCap             1F/0  Prune B-input branch
(0050) ;;
(0051) ;; CR2.AnalogBus        80/*  User Parameter: Output Bus Enable
(0052) ;; CR2.CmpBus           40/0  Comparator Bus Disable
(0053) ;; CR2.AutoZero         20/1  Auto-Zero enabled on Phi 1
(0054) ;; CR2.CCap             1F/0  Prune C-input branch
(0055) ;;
(0056) ;; CR3.ARefSelect       C0/0  Use AGND (to invert)
(0057) ;; CR3.FSW1             20/1  Feedback Cap Used
(0058) ;; CR3.FSW2             10/1  Feedback Cap Grounded for AZ
(0059) ;; CR3.BMux             0C/0  (SCA) Don't Care - this branch pruned
(0060) ;; CR3.BSW              08/0  (SCB) Don't Care - this branch pruned
(0061) ;; CR3.BMux             04/0  (SCB) Don't Care - this branch pruned
(0062) ;; CR3.PWR              03/*  User Parameter: Power, def=OFF
(0063) ;;
(0064) 
(0065) include "DAC_P03.inc"
(0066) include "m8c.inc"
(0067) 
(0068) cOFFSET:   equ 31               ; Conversion term for offset binary to 2's C
(0069) bPWRMASK:  equ 03h              ; Power bitfield in Switched Cap CR3 reg
(0070) bCR3:      equ 30h              ; Except for power bits, CR3 ALWAYS looks
(0071)                                 ;    like this regardless of SC block type
(0072)                                 ;    or where the DAC gets mapped.
(0073) 
(0074) area text (ROM, REL)
(0075) 
(0076) ;;---------------------------------------------------------------------------
(0077) ;; Start / SetPower - Applies power setting to the module's SoCblocs
(0078) ;;
(0079) ;; INPUTS: A contains the power setting 0=Off, 1=Low, 2=Med, 3=High
(0080) ;; OUTUTS: None
(0081) ;;---------------------------------------------------------------------------
(0082)  DAC_P03_Start:
(0083) _DAC_P03_Start:
(0084)  DAC_P03_SetPower:
(0085) _DAC_P03_SetPower:
(0086)         and A, bPWRMASK
_DAC_P03_SetPower:
_DAC_P03_Start:
DAC_P03_SetPower:
DAC_P03_Start:
    0BD9: 21 03    AND   A,3
(0087)         or  A, bCR3             ; Set all other bits in addition to power
    0BDB: 29 30    OR    A,48
(0088)         mov reg[DAC_P03_CR3], A
    0BDD: 60 93    MOV   REG[147],A
(0089)         ret
    0BDF: 7F       RET   
(0090) 
(0091) ;;---------------------------------------------------------------------------
(0092) ;; WriteBlind
(0093) ;; ----------
(0094) ;;
(0095) ;; Modify the DAC's update value without worrying about the clocks
(0096) ;;   Lowest overhead, but output may not settle to correct value until the
(0097) ;;   phi2 of next full cycle following the write.
(0098) ;;
(0099) ;; INPUTS: The accumulator, A, contains the input in the appropriate format.
(0100) ;;   The data format is determined by the setting of the DataFormat parameter
(0101) ;;   in the Device Editor.
(0102) ;;
(0103) ;; OUTPUTS: Analog output voltage reflects new value
(0104) ;;---------------------------------------------------------------------------
(0105)  DAC_P03_WriteBlind:
(0106) _DAC_P03_WriteBlind:
(0107) 
(0108)   IF DAC_P03_OFFSETBINARY
(0109)     ;; Data is an unsigned byte value in [0..62] (i.e., 63 unique values).
(0110)     ;; Following converts it to 2's complement:
(0111)     sub  A, cOFFSET         ; Apply the offset
_DAC_P03_WriteBlind:
DAC_P03_WriteBlind:
    0BE0: 11 1F    SUB   A,31
(0112)   ENDIF
(0113)   IF DAC_P03_OFFSETBINARY | DAC_P03_TWOSCOMPLEMENT
(0114)     ;; Data is a byte in standard 2's complement form with value in [-31..+31]
(0115)     ;; Following converts it to Sign & Magnitude form "00smmmmm"
(0116)     ;;   where sign, "s", is 1 for negative numbers; 0 for positive
(0117)     ;;   and "m" is the magnitude.
(0118)     asl  A                  ; Multiply by 2 and put sign in Carry flag
    0BE2: 64       ASL   A
(0119)     jnc  BlindPositive
    0BE3: D0 07    JNC   0x0BEB
(0120)     ;; Neg to pos by "Invert & Add 1" procedure, but data is shifted!
(0121)     cpl  A                  ; bit 0 is a "1" so, following 1 byte "inc" works
    0BE5: 73       CPL   A
(0122)     inc  A                  ;   (otherwise, we'd have to "add A, 2")
    0BE6: 74       INC   A
(0123)     or   A, 40h             ; Make it negative by forcing sign bit
    0BE7: 29 40    OR    A,64
(0124)     jmp  BlindMagSet
    0BE9: 80 06    JMP   0x0BF0
(0125) BlindPositive:
(0126)     nop
    0BEB: 40       NOP   
(0127)     nop
    0BEC: 40       NOP   
(0128)     nop
    0BED: 40       NOP   
(0129)     jmp  BlindMagSet
    0BEE: 80 01    JMP   0x0BF0
(0130) BlindMagSet:
(0131)     asr  A                  ; Divide by two to finish up
    0BF0: 67       ASR   A
(0132)   ENDIF
(0133) 
(0134)     ;; Data is in Sign & Magnitude form.
(0135)     ;; Set FCap and ClockPhase bits
(0136)     or   A, DAC_P03_CR0_HIBITS
    0BF1: 29 80    OR    A,128
(0137)     mov  reg[DAC_P03_CR0], A
    0BF3: 60 90    MOV   REG[144],A
(0138)     ret
    0BF5: 7F       RET   
(0139) 
(0140) ;;---------------------------------------------------------------------------
(0141) ;; WriteStall
(0142) ;; ----------
(0143) ;;
(0144) ;; Modify the DAC's update value, stalling the CPU if necessary.
(0145) ;;   This routine should be used with fast analog clocks or when the
(0146) ;;   resulting interrupt latencies, comparable to the update period,
(0147) ;;   can be tolerated comfortably.
(0148) ;;
(0149) ;; INPUTS: The accumulator, A, contains the input in the appropriate format.
(0150) ;;   The data format is determined by the setting of the DataFormat parameter
(0151) ;;   in the Device Editor.
(0152) ;;
(0153) ;; OUTPUTS: Analog output voltage reflects new value
(0154) ;;---------------------------------------------------------------------------
(0155)  DAC_P03_WriteStall:
(0156) _DAC_P03_WriteStall:
(0157) 
(0158)   IF DAC_P03_OFFSETBINARY
(0159)     ;; Data is an unsigned byte value in [0..62] (i.e., 63 unique values).
(0160)     ;; Following converts it to 2's complement:
(0161)     sub  A, cOFFSET         ; Apply the offset
_DAC_P03_WriteStall:
DAC_P03_WriteStall:
    0BF6: 11 1F    SUB   A,31
(0162)   ENDIF
(0163)   IF DAC_P03_OFFSETBINARY | DAC_P03_TWOSCOMPLEMENT
(0164)     ;; Data is a byte in standard 2's complement form with value in [-31..+31]
(0165)     ;; Following converts it to Sign & Magnitude form "00smmmmm"
(0166)     ;;   where sign, "s", is 1 for negative numbers; 0 for positive
(0167)     ;;   and "m" is the magnitude.
(0168)     asl  A                  ; Multiply by 2 and put sign in Carry flag
    0BF8: 64       ASL   A
(0169)     jnc  StallPositive
    0BF9: D0 07    JNC   0x0C01
(0170)     cpl  A                  ; "Invert" step of complement 2's complement
    0BFB: 73       CPL   A
(0171)     inc  A                  ; "Add 1"  step of complement 2's complement
    0BFC: 74       INC   A
(0172)     or   A, 40h             ; Make it negative
    0BFD: 29 40    OR    A,64
(0173)     jmp  StallMagSet
    0BFF: 80 06    JMP   0x0C06
(0174) StallPositive:
(0175)     nop
    0C01: 40       NOP   
(0176)     nop
    0C02: 40       NOP   
(0177)     nop
    0C03: 40       NOP   
(0178)     jmp  StallMagSet
    0C04: 80 01    JMP   0x0C06
(0179) StallMagSet:
(0180)     asr  A                  ; Divide by two to finish conversion
    0C06: 67       ASR   A
(0181)   ENDIF
(0182) 
(0183)     ;; Data is in Sign & Magnitude form.
(0184)     ;; Set FCap and ClockPhase bits
(0185)     or   A, DAC_P03_CR0_HIBITS
    0C07: 29 80    OR    A,128
    0C09: 43 65 01 OR    REG[101],1
(0186)     M8C_Stall
(0187)     mov  reg[DAC_P03_CR0], A
    0C0C: 60 90    MOV   REG[144],A
    0C0E: 41 65 FE AND   REG[101],254
(0188)     M8C_Unstall
(0189)     ret
    0C11: 7F       RET   
(0190) 
(0191) ;;---------------------------------------------------------------------------
(0192) ;; Stop - Cuts power to the user module.
(0193) ;;
(0194) ;; INPUTS:  None
(0195) ;; OUTPUTS: None
(0196) ;;---------------------------------------------------------------------------
(0197)  DAC_P03_Stop:
(0198) _DAC_P03_Stop:
(0199)     and reg[DAC_P03_CR3], ~bPWRMASK
_DAC_P03_Stop:
DAC_P03_Stop:
    0C12: 41 93 FC AND   REG[147],252
(0200)     ret
    0C15: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\DAC_P02.ASM
(0001) ;;************************************************************************
(0002) ;;************************************************************************
(0003) ;;
(0004) ;;  DAC_P02.ASM (from DAC6.asm user module template)
(0005) ;;  Rev C, 2002 Mar 30
(0006) ;;
(0007) ;;  Assembler source for 6-bit Switched Capacitor DAC API
(0008) ;;
(0009) ;;  Copyright (c) Cypress MicroSystems 2001-2002. All Rights Reserved.
(0010) ;;
(0011) ;;************************************************************************
(0012) ;;************************************************************************
(0013) ;;
(0014) 
(0015) export  DAC_P02_Start
(0016) export _DAC_P02_Start
(0017) export  DAC_P02_SetPower
(0018) export _DAC_P02_SetPower
(0019) 
(0020) export  DAC_P02_WriteBlind
(0021) export _DAC_P02_WriteBlind
(0022) export  DAC_P02_WriteStall
(0023) export _DAC_P02_WriteStall
(0024) 
(0025) export  DAC_P02_Stop
(0026) export _DAC_P02_Stop
(0027) 
(0028) ;; -----------------------------------------------------------------
(0029) ;;                         Register Definitions
(0030) ;; -----------------------------------------------------------------
(0031) ;;
(0032) ;; Uses 1 Switched Cap Block configured as shown. This API depends
(0033) ;; on knowing the exact personalization of CR0 and CR3 bitfields
(0034) ;; for time efficiency.
(0035) ;;
(0036) ;; * For a Mask/Val pair, this simply indicates that the value is
(0037) ;;   determined by the user either through config-time parameteriza-
(0038) ;;   tion or run-time manipulation.
(0039) ;;
(0040) ;; BIT FIELD         Mask/Val Function
(0041) ;; -----------------    ----- --------------------
(0042) ;; CR0.FCap             80/1  Feedback cap size 32
(0043) ;; CR0.ClockPhase       40/0  Normal phase
(0044) ;; CR0.ASign            20/*  User parameter
(0045) ;; CR0.ACap             1F/*  User parameter
(0046) ;;
(0047) ;; CR1.ACMux            E0/2  (SCA) A:VRef High, C:Don't Care
(0048) ;; CR1.AMux             E0/4  (SCB) VRef High
(0049) ;; CR1.BCap             1F/0  Prune B-input branch
(0050) ;;
(0051) ;; CR2.AnalogBus        80/*  User Parameter: Output Bus Enable
(0052) ;; CR2.CmpBus           40/0  Comparator Bus Disable
(0053) ;; CR2.AutoZero         20/1  Auto-Zero enabled on Phi 1
(0054) ;; CR2.CCap             1F/0  Prune C-input branch
(0055) ;;
(0056) ;; CR3.ARefSelect       C0/0  Use AGND (to invert)
(0057) ;; CR3.FSW1             20/1  Feedback Cap Used
(0058) ;; CR3.FSW2             10/1  Feedback Cap Grounded for AZ
(0059) ;; CR3.BMux             0C/0  (SCA) Don't Care - this branch pruned
(0060) ;; CR3.BSW              08/0  (SCB) Don't Care - this branch pruned
(0061) ;; CR3.BMux             04/0  (SCB) Don't Care - this branch pruned
(0062) ;; CR3.PWR              03/*  User Parameter: Power, def=OFF
(0063) ;;
(0064) 
(0065) include "DAC_P02.inc"
(0066) include "m8c.inc"
(0067) 
(0068) cOFFSET:   equ 31               ; Conversion term for offset binary to 2's C
(0069) bPWRMASK:  equ 03h              ; Power bitfield in Switched Cap CR3 reg
(0070) bCR3:      equ 30h              ; Except for power bits, CR3 ALWAYS looks
(0071)                                 ;    like this regardless of SC block type
(0072)                                 ;    or where the DAC gets mapped.
(0073) 
(0074) area text (ROM, REL)
(0075) 
(0076) ;;---------------------------------------------------------------------------
(0077) ;; Start / SetPower - Applies power setting to the module's SoCblocs
(0078) ;;
(0079) ;; INPUTS: A contains the power setting 0=Off, 1=Low, 2=Med, 3=High
(0080) ;; OUTUTS: None
(0081) ;;---------------------------------------------------------------------------
(0082)  DAC_P02_Start:
(0083) _DAC_P02_Start:
(0084)  DAC_P02_SetPower:
(0085) _DAC_P02_SetPower:
(0086)         and A, bPWRMASK
_DAC_P02_Start:
_DAC_P02_SetPower:
DAC_P02_SetPower:
DAC_P02_Start:
    0C16: 21 03    AND   A,3
(0087)         or  A, bCR3             ; Set all other bits in addition to power
    0C18: 29 30    OR    A,48
(0088)         mov reg[DAC_P02_CR3], A
    0C1A: 60 9F    MOV   REG[159],A
(0089)         ret
    0C1C: 7F       RET   
(0090) 
(0091) ;;---------------------------------------------------------------------------
(0092) ;; WriteBlind
(0093) ;; ----------
(0094) ;;
(0095) ;; Modify the DAC's update value without worrying about the clocks
(0096) ;;   Lowest overhead, but output may not settle to correct value until the
(0097) ;;   phi2 of next full cycle following the write.
(0098) ;;
(0099) ;; INPUTS: The accumulator, A, contains the input in the appropriate format.
(0100) ;;   The data format is determined by the setting of the DataFormat parameter
(0101) ;;   in the Device Editor.
(0102) ;;
(0103) ;; OUTPUTS: Analog output voltage reflects new value
(0104) ;;---------------------------------------------------------------------------
(0105)  DAC_P02_WriteBlind:
(0106) _DAC_P02_WriteBlind:
(0107) 
(0108)   IF DAC_P02_OFFSETBINARY
(0109)     ;; Data is an unsigned byte value in [0..62] (i.e., 63 unique values).
(0110)     ;; Following converts it to 2's complement:
(0111)     sub  A, cOFFSET         ; Apply the offset
DAC_P02_WriteBlind:
_DAC_P02_WriteBlind:
    0C1D: 11 1F    SUB   A,31
(0112)   ENDIF
(0113)   IF DAC_P02_OFFSETBINARY | DAC_P02_TWOSCOMPLEMENT
(0114)     ;; Data is a byte in standard 2's complement form with value in [-31..+31]
(0115)     ;; Following converts it to Sign & Magnitude form "00smmmmm"
(0116)     ;;   where sign, "s", is 1 for negative numbers; 0 for positive
(0117)     ;;   and "m" is the magnitude.
(0118)     asl  A                  ; Multiply by 2 and put sign in Carry flag
    0C1F: 64       ASL   A
(0119)     jnc  BlindPositive
    0C20: D0 07    JNC   0x0C28
(0120)     ;; Neg to pos by "Invert & Add 1" procedure, but data is shifted!
(0121)     cpl  A                  ; bit 0 is a "1" so, following 1 byte "inc" works
    0C22: 73       CPL   A
(0122)     inc  A                  ;   (otherwise, we'd have to "add A, 2")
    0C23: 74       INC   A
(0123)     or   A, 40h             ; Make it negative by forcing sign bit
    0C24: 29 40    OR    A,64
(0124)     jmp  BlindMagSet
    0C26: 80 06    JMP   0x0C2D
(0125) BlindPositive:
(0126)     nop
    0C28: 40       NOP   
(0127)     nop
    0C29: 40       NOP   
(0128)     nop
    0C2A: 40       NOP   
(0129)     jmp  BlindMagSet
    0C2B: 80 01    JMP   0x0C2D
(0130) BlindMagSet:
(0131)     asr  A                  ; Divide by two to finish up
    0C2D: 67       ASR   A
(0132)   ENDIF
(0133) 
(0134)     ;; Data is in Sign & Magnitude form.
(0135)     ;; Set FCap and ClockPhase bits
(0136)     or   A, DAC_P02_CR0_HIBITS
    0C2E: 29 80    OR    A,128
(0137)     mov  reg[DAC_P02_CR0], A
    0C30: 60 9C    MOV   REG[156],A
(0138)     ret
    0C32: 7F       RET   
(0139) 
(0140) ;;---------------------------------------------------------------------------
(0141) ;; WriteStall
(0142) ;; ----------
(0143) ;;
(0144) ;; Modify the DAC's update value, stalling the CPU if necessary.
(0145) ;;   This routine should be used with fast analog clocks or when the
(0146) ;;   resulting interrupt latencies, comparable to the update period,
(0147) ;;   can be tolerated comfortably.
(0148) ;;
(0149) ;; INPUTS: The accumulator, A, contains the input in the appropriate format.
(0150) ;;   The data format is determined by the setting of the DataFormat parameter
(0151) ;;   in the Device Editor.
(0152) ;;
(0153) ;; OUTPUTS: Analog output voltage reflects new value
(0154) ;;---------------------------------------------------------------------------
(0155)  DAC_P02_WriteStall:
(0156) _DAC_P02_WriteStall:
(0157) 
(0158)   IF DAC_P02_OFFSETBINARY
(0159)     ;; Data is an unsigned byte value in [0..62] (i.e., 63 unique values).
(0160)     ;; Following converts it to 2's complement:
(0161)     sub  A, cOFFSET         ; Apply the offset
DAC_P02_WriteStall:
_DAC_P02_WriteStall:
    0C33: 11 1F    SUB   A,31
(0162)   ENDIF
(0163)   IF DAC_P02_OFFSETBINARY | DAC_P02_TWOSCOMPLEMENT
(0164)     ;; Data is a byte in standard 2's complement form with value in [-31..+31]
(0165)     ;; Following converts it to Sign & Magnitude form "00smmmmm"
(0166)     ;;   where sign, "s", is 1 for negative numbers; 0 for positive
(0167)     ;;   and "m" is the magnitude.
(0168)     asl  A                  ; Multiply by 2 and put sign in Carry flag
    0C35: 64       ASL   A
(0169)     jnc  StallPositive
    0C36: D0 07    JNC   0x0C3E
(0170)     cpl  A                  ; "Invert" step of complement 2's complement
    0C38: 73       CPL   A
(0171)     inc  A                  ; "Add 1"  step of complement 2's complement
    0C39: 74       INC   A
(0172)     or   A, 40h             ; Make it negative
    0C3A: 29 40    OR    A,64
(0173)     jmp  StallMagSet
    0C3C: 80 06    JMP   0x0C43
(0174) StallPositive:
(0175)     nop
    0C3E: 40       NOP   
(0176)     nop
    0C3F: 40       NOP   
(0177)     nop
    0C40: 40       NOP   
(0178)     jmp  StallMagSet
    0C41: 80 01    JMP   0x0C43
(0179) StallMagSet:
(0180)     asr  A                  ; Divide by two to finish conversion
    0C43: 67       ASR   A
(0181)   ENDIF
(0182) 
(0183)     ;; Data is in Sign & Magnitude form.
(0184)     ;; Set FCap and ClockPhase bits
(0185)     or   A, DAC_P02_CR0_HIBITS
    0C44: 29 80    OR    A,128
    0C46: 43 65 01 OR    REG[101],1
(0186)     M8C_Stall
(0187)     mov  reg[DAC_P02_CR0], A
    0C49: 60 9C    MOV   REG[156],A
    0C4B: 41 65 FE AND   REG[101],254
(0188)     M8C_Unstall
(0189)     ret
    0C4E: 7F       RET   
(0190) 
(0191) ;;---------------------------------------------------------------------------
(0192) ;; Stop - Cuts power to the user module.
(0193) ;;
(0194) ;; INPUTS:  None
(0195) ;; OUTPUTS: None
(0196) ;;---------------------------------------------------------------------------
(0197)  DAC_P02_Stop:
(0198) _DAC_P02_Stop:
(0199)     and reg[DAC_P02_CR3], ~bPWRMASK
DAC_P02_Stop:
_DAC_P02_Stop:
    0C4F: 41 9F FC AND   REG[159],252
(0200)     ret
    0C52: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\BAUDCL~1.ASM
(0001) ;------------------------------------------------------------------------------
(0002) ;  FILENAME:   BAUDCLKint.asm
(0003) ;   VERSION:   REV B, 2002 Mar 30
(0004) ;------------------------------------------------------------------------------
(0005) ;  DESCRIPTION:
(0006) ;     Interrupt handler routine for Counter8 user module instance:
(0007) ;        BAUDCLK.
(0008) ;------------------------------------------------------------------------------
(0009) ;	Copyright (c) Cypress MicroSystems 2000-2002.  All Rights Reserved.
(0010) ;------------------------------------------------------------------------------
(0011) 
(0012) include  "BAUDCLK.inc"
(0013) 
(0014) ;-----------------------------------------------------
(0015) ;  Export interrupt handler
(0016) ;     NOTE that interrupt handler is NOT exported
(0017) ;     for access by C function.  Interrupt handlers
(0018) ;     are not callable by C functions.
(0019) ;-----------------------------------------------------
(0020) export   BAUDCLKINT
(0021) 
(0022) ;-----------------------------------------------------------------------------
(0023) ;  FUNCTION NAME: BAUDCLKInt
(0024) ;
(0025) ;  DESCRIPTION:
(0026) ;     Counter8 interrupt handler for instance BAUDCLK.  
(0027) ;
(0028) ;     This is a place holder function.  If the user requires use of an interrupt
(0029) ;     handler for this function, then place code where specified.
(0030) ;
(0031) ;  ARGUMENTS:
(0032) ;     none.
(0033) ;
(0034) ;  RETURNS:
(0035) ;     none.
(0036) ;
(0037) ;  SIDE EFFECTS:
(0038) ;     none.
(0039) ;
(0040) ;  THEORY of OPERATION:  
(0041) ;     none.
(0042) ;
(0043) ;-----------------------------------------------------------------------------
(0044) BAUDCLKINT:
(0045)    ;--------------------------
(0046)    ; Place user code here!!!
(0047)    ;--------------------------
(0048)    reti
BAUDCLKINT:
    0C53: 7E       RETI  
FILE: E:\CONTES~1\ENTRY201\LIB\BAUDCLK.ASM
(0001) ;------------------------------------------------------------------------------
BAUDCLK_EnableInt:
_BAUDCLK_EnableInt:
    0C54: 43 E1 04 OR    REG[225],4
(0002) ;  FILENAME:   BAUDCLK.asm
(0003) ;   VERSION:   Rev B, 2002 Mar 30
(0004) ;------------------------------------------------------------------------------
(0005) ;  DESCRIPTION:
(0006) ;     BAUDCLK Counter8 User Module API.
(0007) ;------------------------------------------------------------------------------
(0008) ;	Copyright (c) Cypress MicroSystems 2000-2002. All Rights Reserved.
(0009) ;------------------------------------------------------------------------------
(0010) 
(0011) ;-----------------------------------------------
(0012) ; include instance specific register definitions
(0013) ;-----------------------------------------------
(0014) include "m8c.inc"
(0015) include "BAUDCLK.inc"
(0016) 
(0017) area text (ROM, REL)
(0018) 
(0019) ;-------------------------------------------------------------------
(0020) ;  Declare the functions global for both assembler and C compiler.
(0021) ;
(0022) ;  Note that there are two names for each API. First name is 
(0023) ;  assembler reference. Name with underscore is name refence for
(0024) ;  C compiler.  Calling function in C source code does not require 
(0025) ;  the underscore.
(0026) ;-------------------------------------------------------------------
(0027) export   BAUDCLK_EnableInt
(0028) export  _BAUDCLK_EnableInt
(0029) export   BAUDCLK_DisableInt
(0030) export  _BAUDCLK_DisableInt
(0031) export   BAUDCLK_Start
(0032) export  _BAUDCLK_Start
(0033) export   BAUDCLK_Stop
(0034) export  _BAUDCLK_Stop
(0035) export   BAUDCLK_WritePeriod
(0036) export  _BAUDCLK_WritePeriod
(0037) export   BAUDCLK_WriteCompareValue
(0038) export  _BAUDCLK_WriteCompareValue
(0039) export   bBAUDCLK_ReadCompareValue
(0040) export  _bBAUDCLK_ReadCompareValue
(0041) export   bBAUDCLK_ReadCounter
(0042) export  _bBAUDCLK_ReadCounter
(0043) 
(0044) ;-----------
(0045) ;  EQUATES
(0046) ;-----------
(0047) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit 
(0048) bfINPUT_REG_CLOCK_MASK:    equ   0Fh   ; input register clock mask
(0049) 
(0050) ;-----------------------------------------------------------------------------
(0051) ;  FUNCTION NAME: BAUDCLK_EnableInt
(0052) ;
(0053) ;  DESCRIPTION:
(0054) ;     Enables this counter's interrupt by setting the interrupt enable mask bit
(0055) ;     associated with this User Module. Remember to call the global interrupt
(0056) ;     enable function by using the macro: M8C_EnableGInt.
(0057) ;
(0058) ;  ARGUMENTS:
(0059) ;     none.
(0060) ;
(0061) ;  RETURNS:
(0062) ;     none.
(0063) ;
(0064) ;  SIDE EFFECTS:
(0065) ;     none.
(0066) ;
(0067) ;  THEORY of OPERATION:  
(0068) ;     Sets the specific user module interrupt enable mask bit.
(0069) ;
(0070) ;-----------------------------------------------------------------------------
(0071)  BAUDCLK_EnableInt:
(0072) _BAUDCLK_EnableInt:
(0073)    M8C_EnableIntMask BAUDCLK_INT_REG, bBAUDCLK_INT_MASK
(0074)    ret	
    0C57: 7F       RET   
_BAUDCLK_DisableInt:
BAUDCLK_DisableInt:
    0C58: 5D FF    MOV   A,REG[255]
    0C5A: 70 FE    AND   F,254
    0C5C: 41 E1 FB AND   REG[225],251
    0C5F: 21 80    AND   A,128
    0C61: A0 03    JZ    0x0C65
    0C63: 71 01    OR    F,1
(0075) 
(0076) 	
(0077) ;-----------------------------------------------------------------------------
(0078) ;  FUNCTION NAME: BAUDCLK_DisableInt
(0079) ;
(0080) ;  DESCRIPTION:
(0081) ;     Disables this counter's interrupt by clearing the interrupt enable mask bit
(0082) ;     associated with this User Module. 
(0083) ;
(0084) ;  ARGUMENTS:
(0085) ;     none.
(0086) ;
(0087) ;  RETURNS:
(0088) ;     none.
(0089) ;
(0090) ;  SIDE EFFECTS:
(0091) ;     none.
(0092) ;
(0093) ;  THEORY of OPERATION:  
(0094) ;     Clears the specific user module interrupt enable mask bit.
(0095) ;
(0096) ;-----------------------------------------------------------------------------
(0097)  BAUDCLK_DisableInt:
(0098) _BAUDCLK_DisableInt:
(0099)    
(0100)    M8C_DisableIntMask BAUDCLK_INT_REG, bBAUDCLK_INT_MASK
(0101)    ret
    0C65: 7F       RET   
(0102) 
(0103) 
(0104) ;-----------------------------------------------------------------------------
(0105) ;  FUNCTION NAME: BAUDCLK_Start
(0106) ;
(0107) ;  DESCRIPTION:
(0108) ;     Sets the start bit in the Control register of this user module.  The
(0109) ;     counter will begin counting on the next input clock as soon as the 
(0110) ;     enable input is asserted high.
(0111) ;
(0112) ;  ARGUMENTS:
(0113) ;     none.
(0114) ;
(0115) ;  RETURNS:
(0116) ;     none.
(0117) ;
(0118) ;  SIDE EFFECTS:
(0119) ;     none.
(0120) ;
(0121) ;  THEORY of OPERATION:  
(0122) ;     Set the start bit in the Control register.
(0123) ;
(0124) ;-----------------------------------------------------------------------------
(0125)  BAUDCLK_Start:
(0126) _BAUDCLK_Start:
(0127)    or    REG[BAUDCLK_CONTROL_REG], bfCONTROL_REG_START_BIT
_BAUDCLK_Start:
BAUDCLK_Start:
    0C66: 43 2B 01 OR    REG[43],1
(0128)    ret	
    0C69: 7F       RET   
(0129) 
(0130) 
(0131) ;-----------------------------------------------------------------------------
(0132) ;  FUNCTION NAME: BAUDCLK_Stop
(0133) ;
(0134) ;  DESCRIPTION:
(0135) ;     Disables counter operation.
(0136) ;
(0137) ;  ARGUMENTS:
(0138) ;     none.
(0139) ;
(0140) ;  RETURNS:
(0141) ;     none.
(0142) ;
(0143) ;  SIDE EFFECTS:
(0144) ;     After this function completes, the Count register will latch any data
(0145) ;     written to the Period register.  Writing to the Period register is 
(0146) ;     performed using the BAUDCLK_WritePeriod function.
(0147) ;
(0148) ;  THEORY of OPERATION:  
(0149) ;     Clear the start bit in the Control register.
(0150) ;
(0151) ;-----------------------------------------------------------------------------
(0152)  BAUDCLK_Stop:
(0153) _BAUDCLK_Stop:
(0154)    and   REG[BAUDCLK_CONTROL_REG], ~bfCONTROL_REG_START_BIT
_BAUDCLK_Stop:
BAUDCLK_Stop:
    0C6A: 41 2B FE AND   REG[43],254
(0155)    ret	
    0C6D: 7F       RET   
(0156) 
(0157) 
(0158) ;-----------------------------------------------------------------------------
(0159) ;  FUNCTION NAME: BAUDCLK_WritePeriod
(0160) ;
(0161) ;  DESCRIPTION:
(0162) ;     Write the period value into the Period register.
(0163) ;
(0164) ;  ARGUMENTS:
(0165) ;     BYTE  bPeriodValue - period count - passed in the Accumulator.
(0166) ;
(0167) ;  RETURNS:
(0168) ;     none.
(0169) ;
(0170) ;  SIDE EFFECTS:
(0171) ;     If the counter user module is stopped, then this value will also be
(0172) ;     latched into the Count register.
(0173) ;
(0174) ;  THEORY of OPERATION:  
(0175) ;     Write data into the Period register.
(0176) ;
(0177) ;-----------------------------------------------------------------------------
(0178)  BAUDCLK_WritePeriod:
(0179) _BAUDCLK_WritePeriod:
(0180)    tst   REG[BAUDCLK_CONTROL_REG], bfCONTROL_REG_START_BIT
_BAUDCLK_WritePeriod:
BAUDCLK_WritePeriod:
    0C6E: 49 2B 01 TST   REG[43],1
(0181)    jnz   .CounterRunning
    0C71: B0 19    JNZ   0x0C8B
(0182) 
(0183) ; Counter is stopped.  Due to chip errata, we have to set the clock low for
(0184) ; the write to the period register to cause the data to be immediately transferred
(0185) ; into the Counter.
(0186) .CounterStopped:
(0187)    push  X
    0C73: 10       PUSH  X
(0188)    mov   X, A                                   ; save the period argument
    0C74: 5C       MOV   X,A
    0C75: 71 10    OR    F,16
(0189)    M8C_SetBank1
(0190)    mov   A, REG[BAUDCLK_INPUT_REG]             ; save the context of the clock - input register
    0C77: 5D 29    MOV   A,REG[41]
(0191)    push  A
    0C79: 08       PUSH  A
(0192)    and   REG[BAUDCLK_INPUT_REG], F0h           ; set the clock signal low
    0C7A: 41 29 F0 AND   REG[41],240
    0C7D: 70 EF    AND   F,239
(0193)    M8C_SetBank0
(0194)    mov   A, X                                      
    0C7F: 5B       MOV   A,X
(0195)    mov   REG[BAUDCLK_PERIOD_REG], A                ; set the period register with the new period
    0C80: 60 29    MOV   REG[41],A
(0196)    pop   A
    0C82: 18       POP   A
    0C83: 71 10    OR    F,16
(0197)    M8C_SetBank1
(0198)    mov   REG[BAUDCLK_INPUT_REG], A             ; restore the clock
    0C85: 60 29    MOV   REG[41],A
    0C87: 70 EF    AND   F,239
(0199)    M8C_SetBank0
(0200)    pop   X
    0C89: 20       POP   X
(0201)    ret
    0C8A: 7F       RET   
(0202) 
(0203) ; Counter is running - write the period into the period register.
(0204) ; Upon Terminal Count this value will get loaded into the counter.
(0205) .CounterRunning:
(0206)    mov   REG[BAUDCLK_PERIOD_REG], A
    0C8B: 60 29    MOV   REG[41],A
(0207)    ret
    0C8D: 7F       RET   
(0208) 
(0209) 
(0210) ;-----------------------------------------------------------------------------
(0211) ;  FUNCTION NAME: BAUDCLK_WriteCompareValue
(0212) ;
(0213) ;  DESCRIPTION:
(0214) ;     Writes compare value into the CompareValue register.
(0215) ;
(0216) ;  ARGUMENTS:
(0217) ;     BYTE  bCompareValue - compare value count - passed in Accumulator.
(0218) ;
(0219) ;  RETURNS:
(0220) ;     none.
(0221) ;
(0222) ;  SIDE EFFECTS:
(0223) ;     none.
(0224) ;
(0225) ;  THEORY of OPERATION:  
(0226) ;     Write data into the CompareValue register.
(0227) ;
(0228) ;-----------------------------------------------------------------------------
(0229)  BAUDCLK_WriteCompareValue:
(0230) _BAUDCLK_WriteCompareValue:
(0231)    mov   REG[BAUDCLK_COMPARE_REG], A
BAUDCLK_WriteCompareValue:
_BAUDCLK_WriteCompareValue:
    0C8E: 60 2A    MOV   REG[42],A
(0232)    ret
    0C90: 7F       RET   
(0233) 
(0234) 
(0235) ;-----------------------------------------------------------------------------
(0236) ;  FUNCTION NAME: bBAUDCLK_ReadCompareValue
(0237) ;
(0238) ;  DESCRIPTION:
(0239) ;     Reads the CompareValue register.
(0240) ;
(0241) ;  ARGUMENTS:
(0242) ;     none.
(0243) ;
(0244) ;  RETURNS:
(0245) ;     BYTE  bCompareValue - value read from CompareValue register - returned
(0246) ;                           in the Accumulator.
(0247) ;
(0248) ;  SIDE EFFECTS:
(0249) ;     none.
(0250) ;
(0251) ;  THEORY of OPERATION:  
(0252) ;     Read the CompareValue register and return value in A.
(0253) ;
(0254) ;-----------------------------------------------------------------------------
(0255)  bBAUDCLK_ReadCompareValue:
(0256) _bBAUDCLK_ReadCompareValue:
(0257)    mov   A, REG[BAUDCLK_COMPARE_REG]
_bBAUDCLK_ReadCompareValue:
bBAUDCLK_ReadCompareValue:
    0C91: 5D 2A    MOV   A,REG[42]
(0258)    ret
    0C93: 7F       RET   
bBAUDCLK_ReadCounter:
_bBAUDCLK_ReadCounter:
    0C94: 71 10    OR    F,16
(0259) 
(0260) 
(0261) ;-----------------------------------------------------------------------------
(0262) ;  FUNCTION NAME: bBAUDCLK_ReadCounter
(0263) ;
(0264) ;  DESCRIPTION:
(0265) ;     Reads the count in the Count register.
(0266) ;
(0267) ;  ARGUMENTS:
(0268) ;     none.
(0269) ;
(0270) ;  RETURNS:
(0271) ;     BYTE  bCount - current count value in Count register.
(0272) ;
(0273) ;  SIDE EFFECTS:
(0274) ;     Reading the Count register may cause the Count register to miss
(0275) ;     one or more counts due to the fact that the clock is stopped while
(0276) ;     the Count register is read.  The preferred method is to use the 
(0277) ;     interrupt feature to determine when the Count has arrived at a 
(0278) ;     specified value.
(0279) ;
(0280) ;  THEORY of OPERATION:  
(0281) ;     Reading the Count register causes its value to be latched into the 
(0282) ;     CompareValue register.  Care must be taken to stop the clock and save 
(0283) ;     the CompareValue register's contents before reading the Count.
(0284) ;
(0285) ;-----------------------------------------------------------------------------
(0286)  bBAUDCLK_ReadCounter:
(0287) _bBAUDCLK_ReadCounter:
(0288) 
(0289)    ; save the input register clock setting
(0290)    M8C_SetBank1
(0291)    mov   A, REG[BAUDCLK_INPUT_REG]
    0C96: 5D 29    MOV   A,REG[41]
(0292)    push  A
    0C98: 08       PUSH  A
(0293)    ; disable the clock
(0294)    and   REG[BAUDCLK_INPUT_REG], ~bfINPUT_REG_CLOCK_MASK
    0C99: 41 29 F0 AND   REG[41],240
    0C9C: 70 EF    AND   F,239
(0295)    M8C_SetBank0
(0296) 
(0297)    ; save the CompareValue register value
(0298)    mov   A, REG[BAUDCLK_COMPARE_REG]    
    0C9E: 5D 2A    MOV   A,REG[42]
(0299)    push  A
    0CA0: 08       PUSH  A
(0300)    ; Read the counter. This latches the counter data into
(0301)    ; the CompareValue register.  This may cause an interrupt.
(0302)    mov   A, REG[BAUDCLK_COUNTER_REG]    
    0CA1: 5D 28    MOV   A,REG[40]
(0303)    ; Read the CompareValue register, which contains the counter value
(0304)    mov   A, REG[BAUDCLK_COMPARE_REG]    
    0CA3: 5D 2A    MOV   A,REG[42]
(0305)    ; Save the Count value in X
(0306)    mov   X, A
    0CA5: 5C       MOV   X,A
(0307)    ; Restore the CompareValue register
(0308)    pop   A
    0CA6: 18       POP   A
(0309)    mov   REG[BAUDCLK_COMPARE_REG], A
    0CA7: 60 2A    MOV   REG[42],A
    0CA9: 71 10    OR    F,16
(0310) 
(0311)    ; restore the input register clock setting
(0312)    M8C_SetBank1
(0313)    pop   A
    0CAB: 18       POP   A
(0314)    mov   REG[BAUDCLK_INPUT_REG], A
    0CAC: 60 29    MOV   REG[41],A
    0CAE: 70 EF    AND   F,239
(0315)    M8C_SetBank0
(0316) 
(0317)    ; Get the saved read counter value
(0318)    mov   A, X
    0CB0: 5B       MOV   A,X
(0319) 
(0320)    ret
    0CB1: 7F       RET   
FILE: E:\CONTES~1\ENTRY201\LIB\ADCINT.ASM
(0001) ;;********************************************************************
(0002) ;;********************************************************************
(0003) ;;  ADCINC12int.asm
(0004) ;;
(0005) ;;  Assembler source for interrupt routines the 12 bit Incremential
(0006) ;;  A/D converter.
(0007) ;;
(0008) ;;  Rev D, 2002 Mar 30
(0009) ;;
(0010) ;;  Copyright: Cypress MicroSystems 2000-2002.  All Rights Reserved.
(0011) ;;
(0012) ;;*********************************************************************
(0013) ;;*********************************************************************
(0014) include "ADC.inc"
(0015) include "m8c.inc"
(0016) 
(0017) export  ADC_CNT_INT
(0018) export  ADC_TMR_INT
(0019) export  ADC_cTimerU
(0020) export  ADC_cCounterU
(0021) export _ADC_iIncr
(0022) export  ADC_iIncr
(0023) export _ADC_fIncr
(0024) export  ADC_fIncr
(0025) export  ADC_bIncrC
(0026) 
(0027) area bss(RAM) 
(0028)     ADC_cTimerU:   BLK  1   ;The Upper byte of the Timer
(0029)     ADC_cCounterU: BLK  1   ;The Upper byte of the Counter
(0030)    _ADC_iIncr:
(0031)     ADC_iIncr:     BLK  2   ;A/D value
(0032)    _ADC_fIncr:
(0033)     ADC_fIncr:     BLK  1   ;Data Valid Flag
(0034)     ADC_bIncrC:    BLK  1   ;# of times to run A/D
(0035) 
(0036) area text(ROM,REL)
(0037) 
(0038) LowByte:   equ 1
(0039) HighByte:  equ 0
(0040)  
(0041) ;;------------------------------------------------------------------
(0042) ;;  CNT_INT:
(0043) ;;  Increment  the upper (software) half on the counter whenever the
(0044) ;;  lower (hardware) half of the counter underflows.
(0045) ;;  INPUTS:  None.
(0046) ;;  OUTPUTS: None.  
(0047) ;;------------------------------------------------------------------
(0048) ADC_CNT_INT:
(0049)    inc [ADC_cCounterU]
ADC_CNT_INT:
    0CB2: 76 41    INC   [ADC_cCounterU]
(0050)    reti
    0CB4: 7E       RETI  
(0051) 
(0052) ;;------------------------------------------------------------------
(0053) ;;  TMR_INT:
(0054) ;;  This routine allows the counter to collect data for 64 timer cycles
(0055) ;;  This routine then holds the integrater in reset for one cycle while
(0056) ;;  the A/D value is calculated.
(0057) ;;  INPUTS:  None.
(0058) ;;  OUTPUTS: None.  
(0059) ;;------------------------------------------------------------------
(0060) ADC_TMR_INT:
(0061)    dec [ADC_cTimerU]
ADC_TMR_INT:
    0CB5: 7A 40    DEC   [ADC_cTimerU]
(0062) ;  if(upper count >0 )
(0063)    jz  else1
    0CB7: A0 02    JZ    0x0CBA
(0064)       reti
    0CB9: 7E       RETI  
(0065)    else1:;(upper count decremented to 0)
(0066)       tst reg[ADC_AtoDcr3],10h
    0CBA: 49 8B 10 TST   REG[139],16
(0067)       jz   else2
    0CBD: A0 0E    JZ    0x0CCC
(0068) ;     if(A/D has been in reset mode)
(0069)          mov reg[ADC_CounterCR0],01h   ; Enable Counter
    0CBF: 62 27 01 MOV   REG[39],1
(0070)          and reg[ADC_AtoDcr3],~10h     ; Enable Analog Integrator
    0CC2: 41 8B EF AND   REG[139],239
(0071) IF ADC_NoAZ
(0072)          and reg[ADC_AtoDcr2],~20h
    0CC5: 41 8A DF AND   REG[138],223
(0073) ENDIF
(0074)          mov [ADC_cTimerU],(1<<(ADC_NUMBITS - 6))
    0CC8: 55 40 40 MOV   [ADC_cTimerU],64
(0075)                                                     ; This will be the real counter value
(0076)          reti
    0CCB: 7E       RETI  
(0077)       else2:;(A/D has been in integrate mode)
(0078)          mov reg[ADC_CounterCR0],00h   ;disable counter
    0CCC: 62 27 00 MOV   REG[39],0
(0079)          or  F,01h                                  ;Enable the interrupts
    0CCF: 71 01    OR    F,1
(0080)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0081)          ; Good place to add code to switch inputs for multiplexed input to ADC
(0082)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0083) IF ADC_NoAZ
(0084)          or  reg[ADC_AtoDcr2],20h      ;Reset Integrator
    0CD1: 43 8A 20 OR    REG[138],32
(0085) ENDIF
(0086)          or  reg[ADC_AtoDcr3],10h
    0CD4: 43 8B 10 OR    REG[139],16
(0087)          push A
    0CD7: 08       PUSH  A
(0088)          mov A, reg[ADC_CounterDR0]    ;read Counter
    0CD8: 5D 24    MOV   A,REG[36]
(0089)          mov A, reg[ADC_CounterDR2]    ;now you really read the data
    0CDA: 5D 26    MOV   A,REG[38]
(0090)          cpl A
    0CDC: 73       CPL   A
(0091)          cmp [ADC_cCounterU],(1<<(ADC_NUMBITS - 7))
    0CDD: 3C 41 20 CMP   [ADC_cCounterU],32
(0092)          jnz endif10
    0CE0: B0 05    JNZ   0x0CE6
(0093) ;        if(max positive value)
(0094)             dec [ADC_cCounterU]
    0CE2: 7A 41    DEC   [ADC_cCounterU]
(0095)             mov A,ffh
    0CE4: 50 FF    MOV   A,255
(0096)          endif10:
(0097)          asr [ADC_cCounterU]                              ; divide by 4
    0CE6: 68 41    ASR   [ADC_cCounterU]
(0098)          rrc A
    0CE8: 6D       RRC   A
(0099)          asr [ADC_cCounterU]
    0CE9: 68 41    ASR   [ADC_cCounterU]
(0100)          rrc A
    0CEB: 6D       RRC   A
(0101) ;
(0102)          mov [(ADC_iIncr + HighByte)],[ADC_cCounterU]
    0CEC: 5F 42 41 MOV   [ADC_iIncr],[ADC_cCounterU]
(0103)          mov [(ADC_iIncr + LowByte)],A
    0CEF: 53 43    MOV   [ADC_iIncr+1],A
(0104)          mov [ADC_fIncr],01h          ;Set AD data flag
    0CF1: 55 44 01 MOV   [ADC_fIncr],1
(0105)          pop A
    0CF4: 18       POP   A
(0106)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0107)          ; User code here for interrupt system.
(0108)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0109)          cmp [ADC_bIncrC],00h
    0CF5: 3C 45 00 CMP   [ADC_bIncrC],0
(0110)          jz  endif3
    0CF8: A0 17    JZ    0x0D10
(0111) ;        if(ADC_bIncrC is not zero)
(0112)             dec [ADC_bIncrC]
    0CFA: 7A 45    DEC   [ADC_bIncrC]
(0113)             jnz endif4
    0CFC: B0 13    JNZ   0x0D10
(0114) ;           if(ADC_bIncrC has decremented down to zero to 0)
(0115)                mov reg[ADC_TimerCR0],00h          ;disable the Timer
    0CFE: 62 23 00 MOV   REG[35],0
(0116)                mov reg[ADC_CounterCR0],00h        ;disable the Counter
    0D01: 62 27 00 MOV   REG[39],0
(0117)                nop
    0D04: 40       NOP   
(0118)                nop
    0D05: 40       NOP   
(0119)                and reg[INT_MSK1],~(ADC_TimerMask | ADC_CounterMask)
    0D06: 41 E1 FC AND   REG[225],252
(0120)                                                                ;Disable both interrupts
(0121) IF ADC_NoAZ
(0122)                or  reg[ADC_AtoDcr2],20h           ;Reset Integrator
    0D09: 43 8A 20 OR    REG[138],32
(0123) ENDIF
(0124)                or  reg[ADC_AtoDcr3],10h
    0D0C: 43 8B 10 OR    REG[139],16
(0125)                reti
    0D0F: 7E       RETI  
(0126)             endif4:;
(0127)          endif3:;
(0128)       endif2:;
(0129)       mov [ADC_cTimerU],1                         ;Set Timer for one cycle of reset
    0D10: 55 40 01 MOV   [ADC_cTimerU],1
(0130)       mov [ADC_cCounterU],(-(1<<(ADC_NUMBITS - 7))) ;Set Counter hardware for easy enable
    0D13: 55 41 E0 MOV   [ADC_cCounterU],224
(0131)       mov reg[ADC_CounterDR1],ffh 
    0D16: 62 25 FF MOV   REG[37],255
(0132)       reti
    0D19: 7E       RETI  
FILE: E:\CONTES~1\ENTRY201\LIB\ADC.ASM
(0001) ;;********************************************************************
(0002) ;;********************************************************************
(0003) ;;  ADCINC12.asm
(0004) ;;
(0005) ;;  Assembler source for the 12 bit Incremential A/D converter.
(0006) ;;
(0007) ;;  REV D, 2002 MAR 30
(0008) ;;
(0009) ;;  Copyright: Cypress MicroSystems 2000-2002.  All Rights Reserved.
(0010) ;;
(0011) ;;*********************************************************************
(0012) ;;*********************************************************************
(0013) 
(0014) export  ADC_Start
(0015) export _ADC_Start
(0016) export  ADC_SetPower
(0017) export _ADC_SetPower
(0018) export  ADC_Stop
(0019) export _ADC_Stop
(0020) export  ADC_GetSamples
(0021) export _ADC_GetSamples
(0022) export  ADC_StopAD
(0023) export _ADC_StopAD
(0024) export  ADC_fIsData
(0025) export _ADC_fIsData
(0026) export  ADC_iGetData
(0027) export _ADC_iGetData
(0028) export  ADC_ClearFlag
(0029) export _ADC_ClearFlag
(0030) 
(0031) include "ADC.inc"
(0032) include "m8c.inc"
(0033) 
(0034) LowByte:   equ 1
(0035) HighByte:  equ 0
(0036) 
(0037) 
(0038) ;;------------------------------------------------------------------
(0039) ;;  Start:
(0040) ;;  SetPower:
(0041) ;;  Applies power setting to the module's analog PSoc block.
(0042) ;;  INPUTS:  A contains the power setting
(0043) ;;  OUTPUTS: None.  
(0044) ;;------------------------------------------------------------------
(0045)  ADC_Start:
(0046) _ADC_Start:
(0047)  ADC_SetPower:
(0048) _ADC_SetPower:
(0049)    push X            ;save X
_ADC_SetPower:
ADC_Start:
_ADC_Start:
ADC_SetPower:
    0D1A: 10       PUSH  X
(0050)    mov  X,SP	   ;X will point at next pushed value
    0D1B: 4F       MOV   X,SP
(0051)    and  A,03h
    0D1C: 21 03    AND   A,3
(0052)    push A		   ;X points at copy of A
    0D1E: 08       PUSH  A
(0053)    mov  A,reg[ADC_AtoDcr3]
    0D1F: 5D 8B    MOV   A,REG[139]
(0054)    and  A,~03h       ;clear power bits
    0D21: 21 FC    AND   A,252
(0055)    or   A,[ X ]
    0D23: 2B 00    OR    A,[X+0]
(0056)    mov  reg[ADC_AtoDcr3],A
    0D25: 60 8B    MOV   REG[139],A
(0057)    pop  A
    0D27: 18       POP   A
(0058)    pop  X
    0D28: 20       POP   X
(0059)    ret
    0D29: 7F       RET   
(0060) 
(0061) ;;------------------------------------------------------------------
(0062) ;;  Stop:
(0063) ;;  SetPower:
(0064) ;;  Removes power from the module's analog PSoc block.
(0065) ;;  INPUTS:  None.
(0066) ;;  OUTPUTS: None.  
(0067) ;;------------------------------------------------------------------
(0068)  ADC_Stop:
(0069) _ADC_Stop:
(0070)    and reg[ADC_AtoDcr3], ~03h
_ADC_Stop:
ADC_Stop:
    0D2A: 41 8B FC AND   REG[139],252
(0071)    ret
    0D2D: 7F       RET   
(0072) 
(0073) ;;------------------------------------------------------------------
(0074) ;;  Get_Samples:
(0075) ;;  SetPower:
(0076) ;;  Starts the A/D convertor and will place data is memory.  A flag
(0077) ;;  is set whenever a new data value is available.
(0078) ;;  INPUTS:  A passes the number of samples (0 is continous).
(0079) ;;  OUTPUTS: None.  
(0080) ;;------------------------------------------------------------------
(0081)  ADC_GetSamples:
(0082) _ADC_GetSamples:
(0083)    mov [ADC_bIncrC],A	      ;number of samples
ADC_GetSamples:
_ADC_GetSamples:
    0D2E: 53 45    MOV   [ADC_bIncrC],A
(0084)    or  reg[INT_MSK1],(ADC_TimerMask | ADC_CounterMask )
    0D30: 43 E1 03 OR    REG[225],3
(0085)                                           ;Enable both interrupts
(0086)    mov [ADC_cTimerU],1       ;Force the Timer to do one cycle of rest
    0D33: 55 40 01 MOV   [ADC_cTimerU],1
(0087) IF ADC_NoAZ
(0088)    or  reg[ADC_AtoDcr2],20h  ;force the Integrator into reset
    0D36: 43 8A 20 OR    REG[138],32
(0089) ENDIF
(0090)    or  reg[ADC_AtoDcr3],10h
    0D39: 43 8B 10 OR    REG[139],16
(0091)    mov [ADC_cCounterU],(-(1<<(ADC_NUMBITS - 7)));Initialize Counter
    0D3C: 55 41 E0 MOV   [ADC_cCounterU],224
(0092)    mov reg[ADC_TimerDR1],ffh
    0D3F: 62 21 FF MOV   REG[33],255
(0093)    mov reg[ADC_CounterDR1],ffh
    0D42: 62 25 FF MOV   REG[37],255
(0094)    mov reg[ADC_TimerCR0],01h ;enable the Timer
    0D45: 62 23 01 MOV   REG[35],1
(0095)    mov [ADC_fIncr],00h       ;A/D Data Ready Flag is reset
    0D48: 55 44 00 MOV   [ADC_fIncr],0
(0096)    ret
    0D4B: 7F       RET   
(0097) 
(0098) ;;------------------------------------------------------------------
(0099) ;;  StopAD:
(0100) ;;  Completely shuts down the A/D is an orderly manner.  Both the
(0101) ;;  Timer and COunter interrupts are disabled.
(0102) ;;  INPUTS:  None.
(0103) ;;  OUTPUTS: None.  
(0104) ;;------------------------------------------------------------------
(0105)  ADC_StopAD:
(0106) _ADC_StopAD:
(0107)    mov reg[ADC_TimerCR0],00h       ;disable the Timer
ADC_StopAD:
_ADC_StopAD:
    0D4C: 62 23 00 MOV   REG[35],0
(0108)    mov reg[ADC_CounterCR0],00h     ;disable the Counter
    0D4F: 62 27 00 MOV   REG[39],0
(0109)    nop
    0D52: 40       NOP   
(0110)    nop
    0D53: 40       NOP   
    0D54: 5D FF    MOV   A,REG[255]
    0D56: 70 FE    AND   F,254
    0D58: 41 E1 FC AND   REG[225],252
    0D5B: 21 80    AND   A,128
    0D5D: A0 03    JZ    0x0D61
    0D5F: 71 01    OR    F,1
(0111)    ;Disable both interrupts
(0112)    M8C_DisableIntMask INT_MSK1, (ADC_TimerMask | ADC_CounterMask )
(0113) IF ADC_NoAZ
(0114)    or  reg[ADC_AtoDcr2],20h        ;reset Integrator
    0D61: 43 8A 20 OR    REG[138],32
(0115) ENDIF
(0116)    or  reg[ADC_AtoDcr3],10h
    0D64: 43 8B 10 OR    REG[139],16
(0117)    ret
    0D67: 7F       RET   
(0118) ;;------------------------------------------------------------------
(0119) ;;  fIsData:
(0120) ;;  Returns the status of the A/D Data
(0121) ;;  is set whenever a new data value is available.
(0122) ;;  INPUTS:  None.
(0123) ;;  OUTPUTS: A returned data status A =: 0 no data available
(0124) ;;                                   !=: 0 data available.  
(0125) ;;------------------------------------------------------------------
(0126)  ADC_fIsData:
(0127) _ADC_fIsData:
(0128)    mov A,[ADC_fIncr]
ADC_fIsData:
_ADC_fIsData:
    0D68: 51 44    MOV   A,[ADC_fIncr]
(0129)    ret
    0D6A: 7F       RET   
(0130) 
(0131) ;;------------------------------------------------------------------
(0132) ;;  iGetData:
(0133) ;;  Returns the data from the A/D.  Does not check if data is
(0134) ;;  available.
(0135) ;;  is set whenever a new data value is available.
(0136) ;;  INPUTS:  None.
(0137) ;;  OUTPUTS: X:A returns the A/D data value.  
(0138) ;;------------------------------------------------------------------
(0139)  ADC_iGetData:
(0140) _ADC_iGetData:
(0141)    mov X,[(ADC_iIncr + HighByte)]
ADC_iGetData:
_ADC_iGetData:
    0D6B: 58 42    MOV   X,[ADC_iIncr]
(0142)    mov A,[(ADC_iIncr + LowByte)]
    0D6D: 51 43    MOV   A,[ADC_iIncr+1]
(0143)    ret
    0D6F: 7F       RET   
(0144) 
(0145) ;;------------------------------------------------------------------
(0146) ;;  ClearFlag:
(0147) ;;  clears the data ready flag.
(0148) ;;  INPUTS:  None.
(0149) ;;  OUTPUTS: None.
(0150) ;;------------------------------------------------------------------
(0151)  ADC_ClearFlag:
(0152) _ADC_ClearFlag:
(0153)    mov [ADC_fIncr],00h
ADC_ClearFlag:
_ADC_ClearFlag:
    0D70: 55 44 00 MOV   [ADC_fIncr],0
(0154)    ret
FILE: <library>
    0D73: 7F       RET   
